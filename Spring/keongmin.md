## Spring DI/IoC는 어떻게 동작하나요?
### IoC
- Inversion of Control, 제어 역전
- 객체(빈)를 직접 관리하지 않고 외부(스프링 컨테이너)에서 관리하고 제공받아 사용하는 것 = 객체의 생명주기를 프레임워크나 컨테이너가 관리하는 원칙
### DI
- 사용할 객체를 직접 생성하지 않고 외부에서 생성한 객체를 주입받아 사용하는 객체
- 코드의 결합도를 낮추고 재사용성, 테스트 용이성 향상
- 주입 방법에는 생성자 주입, 필드 주입, setter 통한 주입이 있는데 가장 권장하는 방식은 생성자를 통한 주입이다.

## Spring Bean이란 무엇인가요?
스프링 컨테이너가 관리하는 자바 객체
### 스프링 컨테이너
- 스프링 빈의 생명 주기를 관리하고 생성된 스프링 빈에게 추가적인 기능을 제공하는 역할 (IoC, DI 원리가 여기 적용됨)
- new 연산자, 인터페이스 호출 등의 역할을 대신 해줌 → 외부에서 제어 흐름 관리, 객체들의 의존관계 생성
- @Component 어노테이션을 붙여주면 빈으로 등록 가능

## 스프링 Bean의 생성 과정을 설명해주세요.
객체 생성 → 의존성 설정 → 초기화 → 사용 → 소멸
- 스프링 컨테이너가 초기화될 때 먼저 빈을 생성하고 의존관계 설정한 뒤 프로세스가 완료되면 빈이 지정한 메소드를 호출하여 초기화 진행, 컨테이너가 종료될 때 빈이 지정한 메서드를 호출해 소멸
- 빈 객체의 클래스가 InitializingBean 인터페이스나 Disposable Bean을 구현하기 때문에 해당 인터페이스에서 정의된 메소드를 호출해서 빈 객체를 초기화하거나 종료한다.
- 빈 초기화 어노테이션: @PostConstruct
- 빈 소멸 어노테이션: @PreDestroy

## 스프링 Bean의 Scope에 대해서 설명해주세요.
빈이 존재하는 범위
- 싱글톤: 기본적으로 싱글톤 범위를 가지는데 스프링 컨테이너의 시작과 종료까지 하나의 객체만 사용하는 방식을 의미
    - 컨테이너에서 하나의 빈을 생성하고 여러 요청이 들어오면 미리 생성한 빈을 사용할 수 있도록 반환해주는 방식
- 프로토타입: 빈의 생성부터 의존 관계 주입까지만 관여하는 짧은 스코프
    - 요청이 들어면 빈을 생성하고 필요한 의존 관계 주입, 요청수만큼 생성
    - 같은 동작이라도 각각 생성하여 반환해주고 반환해준 후에는 관리하지 않음
- 웹 관련
    - request: 웹의 요청이 들오고 나갈 때까지 유지
    - session: 웹 세션이 생성되고 종료될 때까지 유지
    - application: 웹의 서블릿 콘텍스트와 같은 범위로 유지

## IoC 컨테이너의 역할은 무엇이 있을까요?
* IoC: 객체 생성부터 생명주기 관리까지 애플리케이션의 흐름을 스프링 컨테이너에서 관리하기 때문에 애플리케에션은 비즈니스 로직에 더 집중하고, 코드의 결합도를 낮추고 유연성 높일 수 있음

### IoC 컨테이너 역할
- IoC 컨테이너는 애플리케이션의 객체 생성과 의존성 주입, 생명주기 관리를 책임지는데 이는 ApplicationContext 인터페이스를 통해 구현하고 애플리케이션 전반에 걸쳐 컴포넌트 관리
- 스프링 빈의 정의와 의존성 설정 → 애플리케이션의 설정, 구성 유연하게 관리 가능
- 애플리케이션의 컴포넌트 간에 필요한 의존성 자동으로 주입 → 어노테이션을 사용할 수 있음
- 애플리케이션의 구성 요소 결합도 낮추고 컴포넌트 재사용성 높여주고 애플리케이션 테스트 및 유지보수 용이하게 해줌

## DI 종류는 어떤것이 있고, 이들의 차이는 무엇인가요?
- 생성자를 통한 주입
    - 가장 권장하는 방식
    - 생성자에 @Autowired 어노테이션 붙여서 주입
    - 초기에 의존 관계 설정되기 때문에 예외 발생 방지 가능
    - 순환참조를 컴파일 단계에서 찾을 수 있다.
    - 유일하게 final 키워드 사용 가능 → 생성자로 인해 인스턴스가 생성될 때 한번만 할당, 객체의 불변성 보장
- 필드 객체 선언을 통한 주입
    - @Autowired 어노테이션만 붙이면 사용 가능하기 때문에 편함
    - 의존성을 주입하기 쉬운만큼 하나의 클래스가 많은 책임을 갖게 될 수 있기 때문에 단일 책임 원칙을 위반할 수 있음
    - 의존 관계 파악이 어렵고 순환 참조 방지 불가
- setter를 통한 주입
    - 선택적인 의존성 주입 가능
    - 주입 받지 않은 구현체를 사용하게 되면 NPE 예외 발생

## Autowiring 과정에 대해서 설명해주세요.
- BeanPostProcessor 라는 라이프 사이클 인터페이스의 구현체인 AutowiredAnnotationBeanPostProcessor에 의해 의존성 주입 실행
- BeanPostProcessor는 초기화 라이프 사이클 이전, 이후에 필요한 부가 작업을 할 수 있는 라이프 사이클 콜백 → 빈이 만들어지는 시점 이전이나 이후에 추가적인 작업을 하고 싶을 때 사용
- AutowiredAnnotationBeanPostProcessor가 빈 초기화 라이프 사이클 이전(빈 인스턴스 생성 이전)에 @Autowired 붙어있는 빈을 찾아 주입

1. BeanFactory(ApplicationContext)가 BeanPostProcessor 타입의 빈을 찾음
2. IoC 컨테이너에 등록되어 있는 다른 빈에게 BeanPostProcessor 적용
3. 다른 빈에 @Autowired 어노테이션을 처리하는 AutowiredAnnotationBeanPostProcessor 의 로직이 적용
4. 의존성 주입 발생

## Spring Web MVC의 Dispatcher Servlet의 동작 원리에 대해서 간단히 설명해주세요.
### Dispatcher Servlet
- HTTP 프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 보내주는 프론트 컨트롤러
> 프론트 컨트롤러: 서블릿 컨테이너 제일 앞단에서 서버로 들어오는 클라이언트의 모든 요청을 받아 처리해주는 컨트롤러
- 클라이언트로부터 어떤 요청이 오게 되면 모든 요청을 먼저 받고 세부 컨트롤러에게 전달하는 역할

### 동작 과정
1. 클라이언트의 요청이 Dispatcher Servlet으로 전달
2. 요청 정보를 통해 요청을 위임한 컨트롤러 찾기 위해 Handlier Mapping으로 전달
3. Handling Mapping이 controller에 처리 요청
4. controller의 처리 결과를 Handler Adapter에서 ModelAndView 객체로 변환해서 Dispatcher Servlet 으로 전달
5. Dispatcher Servlet에서 전달받은 ModelAndView 객체를 이용하여 View 검색
6. viewResolver에서 처리결과를 view에 전달
7. 처리 결과가 포함된 view를 Dispatcher Servlet에 전달
8. Dispatcher Servlet에서 응답을 클라이언트에 전달

## 프론트 컨트롤러 패턴이란 무엇인가요?
- 여러 서블릿 컨트롤러 앞단에 두어 컨트롤러의 공통영역을 처리해주는 역할
- 공통 영역 처리 후 요청에 맞게 컨트롤러로 보내 처리할 수 있도록 해줌
- 프론트 컨트롤러에서 나머지 컨트롤러를 호출하기 때문에 프론트 컨트롤러 제외한 나머지 컨트롤러는 서블릿 사용하지 않아도됨

## Servlet Filter와 Spring Interceptor의 차이는 무엇인가요?
### Spring Filter
Dispatcher Servlet에 요청이 전달되기 전, 후에 url 패턴에 맞는 모든 요청에 대해 부가 작업을 처리할 수 있는 기능 제공 → 스프링 컨테이너가 아닌 톰캣과 같은 웹 컨테이너에 의해 관리가 되고 스프링 범위 밖에서 처리

- 메소드
    - init
        - 필터 객체를 초기화하고 서비스에 추가하기 위한 메소드
        - 초기화한 후에는 doFilter를 통해 처리 실행
    - doFilter
        - url 패턴에 맞는 모든 HTTP 요청이 Dispatcher Servlet으로 전달되기 전에 웹 컨테이너에 의해 실행되는 메소드
        - FilterChain 파라미터를 통해 다음 대상으로 요청 전달
    - destroy
        - 처리된 필터 객체를 웹 컨테이너가 destroy를 호출하여 필터 객체를 종료된 것을 확인해서 후처리로 doFilter에 의해 처리되지 않음

### Spring Interceptor
Dispatcher Servlet이 controller를 호출하기 전후에 요청과 응답을 참조하거나 가공할 수 있는 기능 제공 → 웹 컨테이너가 아닌 Spring 내부 컨텍스트에서 처리, Spring MVC에서 제공하는 기능

Dispatcher Servlet이 Handling mapping을 통해 컨트롤러를 찾도록 요청하는데 그 결과로 HandlerExecutionChain 반환 → 인터셉터가 등록되어 있으면 순차적으로 인터센터를 실행한 뒤 컨트롤러 실행 / 인터셉터 없으면 바로 컨트롤러 실행 (인터셉터가 직접 컨트롤러로 요청 x)

- 메소드
    - preHandle
        - 컨트롤러 이전에 처리해야 하는 전처리 작업이나 요청 정보를 가공하거나 추가하는 경우에 사용
    - postHandle
        - 컨트롤러 이후에 처리해야 하는 후처리 작업이 있을 때 사용
    - afterCompletion
        - 모든 뷰에서 최종 결과를 생성하는 일을 포함해 모든 작업이 완료된 후 실행
        - 요청 처리 중에 사용한 리소스를 반환할 때 사용하기에 적합

### 차이점
1. request, response 객체 조작 가능 여부
    - 필터는 조작 가능 ↔ 인터셉트는 불가
    - 필터는 필터 체이닝 과정에서 원하는 request, response 전달 가능
    - 인터셉터는 현재 인터셉터의 결과가 true/false 인지 에 따라 다음 과정 실행 (request, response 전달 불가)
2. 사용되는 경우
   - 필터
        1. 보안 및 인증/인가 작업
        2. 모든 요청에 대한 로깅, 검사
        3. 이미지/데이터 압축 및 문자열 인코딩
        4. Spring 과 분리되는 작업
   - 인터셉터
        1. 세부적인 보안 및 인증/인가 작업
        2. API 호출에 대한 로깅, 검사
        3. controller로 넘겨주는 정보 가공

## Spring에서 CORS 에러를 해결하기 위한 방법을 설명해주세요.
1. CorsFilter 생성
    - Filter 인터페이스를 구현하는 커스텀 필터 생성
    - doFilter() 부분에 허용해줄 정책에 대해 커스텀
2. @CrossOrigin 어노테이션
    - 컨트롤러 상단부, 메소드 상단부에 어노테이션 추가
    - 설정해줄 컨트롤러나 메소드가 많아지면 모든 곳애 추가해주어야 한다는 단점 존재
3. WebMvcConfigurer 통해 설정
    - WebMvcConfigurer 를 구현한 WebConfig 클래스 내부에서 CORS 관련 설정
  
## Bean/Component 어노테이션에 대해서 설명해주시고, 둘의 차이점에 대해 설명해주세요.
둘다 스프링 컨테이너에 빈을 등록하는 어노테이션

### Bean
- 프로그래머가 직접 제어가 불가능한 외부 라이브러리를 빈으로 등록하려 할 때 사용
- 메소드 레벨에 선언
- Configuration 어노테이션과 함께 사용

### Component
- 프로그래머가 직접 작성한 클래스를 빈으로 등록하기 위한 어노테이션
- 클래스 레벨에 선언

## POJO란 무엇인가요? Spring Framework에서 POJO는 무엇이 될 수 있을까요?
### POJO
- Plain Old Java Object, 자바로 생성하는 순수한 객체
- EJB 등에서 사용되는 java bean이 아닌 getter, setter 로 구성된 가장 순수한 형태의 기본 클래스
- EJB의 사용과 프로그램의 규모 증가로 자바 코드는 가독성이 떨어져서 유지보수가 여려워지고 직접 특정 클래스에 의존하는 등 객체 지향성을 잃어가기 때문에 다시 순수했던 객체지향으로 돌아가자는 취지로 나옴
- 특징
    - default 생성자 있어야 함
    - 다른 자바 프로그램들이 클래스의 값에 접근 가능
    - 미리 정의된 클래스나 인터페이스를 사용하면 안됨
### POJO 프레임워크
POJO 장점과 EJB에서 제공하는 서비스와 기술을 그대로 사용할 수 있도록 도와주는 프레임워크

1. 하이버네이트
    - persistence 기술과 오브젝트-관계형 DB 매핑을 POJO를 이용해서 사용할 수 있게 만드는 POJO 기반의 퍼시스턴스 프레임워크
    - JDBC API를 직접 사용하는 것과 비슷한 성능을 제공, 복잡한 퍼시스턴스 로직 개발 가능
2. Spring
    - 엔터프라이즈 서비스를 POJO 기반으로 만든 비즈니스 오브젝트에서 사용할 수 있게 해주는 프레임워크
    - POJO 프로그래밍을 지향하는 프레임워크이기 때문에 다른 환경, 기술에 종속되지 않도록 IoC/DI, AOP 등을 지원

> [하이버네이트와 스프링의 차이점]
> - 하이버네이트는 JPA 구현체 (인터페이스와 구현체의 관계와 같은)
> - 스프링 data JPA는 JPA에 대한 데이터 접근 추상화, 스프링에서 제공하는 모듈 중 하나로 jpa 위에 추가적인 기능을 제공해서 jpa 기반 개발을 편하게 만들어주는 프레임워크

## Spring Web MVC에서 요청 마다 Thread가 생성되어 Controller를 통해 요청을 수행할텐데, 어떻게 1개의 Controller만 생성될 수 있을까요?
- 생성한 controller 클래스에 대한 정보가 JVM 메모리 영역 중 Method Area에 올라가기 때문에 가능
- controller 하나를 생성하면 객체는 heap 영역에 생성되지만 해당 클래스의 정보는 Method Area에 저장되기 때문에 모든 쓰레드가 접근가능하여 객체의 바이너리 코드 공유 가능
- 여러개의 쓰레드가 싱글톤으로 생성된 controller를 참고하여 실행됨
- controller가 상태를 갖지 않도록 구현하는 것이 중요함

### 쓰레드 풀
- 프로그램 실행에 필요한 쓰레드 미리 생성
- 매 요청마다 쓰레드를 생성하고 소멸하는 것을 성능 저하 일으킬 수 있음 → 쓰레드풀 활용
- 동작 방식
  1. core size만큼 쓰레드 생성
  2. 유저 요청이 들어올 때마다 큐에 저장
  3. 남는 쓰레드가 있다면 큐에서 요청을 꺼내 쓰레드에 할당 후 처리
  4. 쓰레드가 없다면 큐에서 대기
  5. 큐가 꽉차면 쓰레드 새로 생성
  6. 쓰레드가 최대 사이즈에 도달하고 큐도 꽉차면 connection-refused 오류 반환
  7. 큐가 비어있고 core size 이상의 쓰레드가 생성되었을 경우 쓰레드 destroy

## Spring WEB MVC의 근간에는 Java Servlet 이 있는데요. Spring 은 Servlet을 어떻게 구성해서 이를 구현했을까요?
### 서블릿
- 자바를 이용해서 웹 페이지를 동적으로 생성하는 기술
- HTTP 요청을 받아 처리하고 그 결과를 웹 브라우저에게 돌려주는 역할
- 웹 서버가 요청을 받아 서블릿 컨테이너에게 전달하고 서블릿 컨테이너는 요청을 처리할 서블릿을 찾아 실행
- 서블릿 컨테이너는 서블릿 생명주기를 관리하고 요청에 따라 서블릿을 로딩, 초기화, 실행, 종료 하는 역할
- 서블릿이 싱글톤으로 관리되기 때문에 서블릿은 생성되고 소멸되지 않고 같은 요청이 들어오면 또다시 호출 → 이런 서블릿 생명주기를 서블릿 컨테이너에서 담당
### 스프링
- 서블릿을 포함해 다양한 웹 개발 기능 제공하는 프레임워크
- 전면 컨트롤러인 Dispatcher Servlet을 두어 앞단에서 공통 로직을 처리하도록 수행 → 서블릿은 하나만 두고 모든 요청을 다 받음
- 웹 요청 처리 관련된 구현을 직접하지 않고 비즈니스 로직에 집중할 수 있음 (IoC)

## Filter는 Servlet의 스펙이고, Interceptor는 Spring MVC의 스펙입니다. Spring Application에서 Filter와 Interceptor를 통해 예외를 처리할 경우 어떻게 해야 할까요?

### 인터셉터 예외 처리
1. @ExceptionHanlder 어노테이션을 이용해서 에러 핸들링
2. @ControllerAdvie 어노테이션을 사용해서 전체 컨트롤러에 대해 에러 핸들링

### 필터 예외 처리
1. 필터는 @RestControllerAdvice, @ControllerAdvice의 에러 핸들링 범위에 포함되지 못함 → ErrorController에서 처리
2. 필터의 상위에 예외 처리하는 필터를 만들어서 Filter Chain에 추가

> [서블릿 예외에 대한 처리]
>
> WAS에 에러 요청 페이지 상태 코드가 전달되면 WAS에서 직접 URL 요청 → 필터, 서블릿, 인터셉터도 다시 한번 호출되는데 이미 확인된 부분이기 때문에 WAS에서 재요청시 한번더 필터와 인터셉터를 호출하는 것은 비효율적
> 1. Filter Dispatcher Type을 이용한 중복 처리 제거
>    - Dispatcher Type에 현재 요청 타입을 알려줌
>    - Dispatcher Type에 따라 다른 필터를 호출할지 여부 판단 가능
> 2. Interceptor 의 중복 처리
>    - 요청 타입에 따라 인터셉터 호출 설정 불가 (항상 호출)
>    - 요청 경로에 따라 쉽게 인터셉터 추가 제외 가능 → excludePathPatterns를 이용해서 에러 요청 페이지 경로를 제외

## Spring Application을 구동할 때 메서드를 실행시키는 방법에 대해 설명해주세요.
생성자 호출시에 스프링빈이 초기화되지 않으면 NPE 문제가 필드 초기화 과정에서 발생 가능 → 문제를 해결하고 스프링 시작 로딩 때 로직 실행하는 방법

1. @PostConstruct 어노테이션: 특정 클래스의 메소드에 붙여서 해당 클래스의 객체 내 모든 빈들이 초기화 직후 한번 실행되어야 하는 메소드
2. Initializing Bean 인터페이스: PostConstruct 와 방식은 유사하고 어노테이션 대신 InitializingBean 인터페이스와 afterPropertiesSet() 메소드 구현해서 사용
3. ApplicationListener: 특정 빈에 초점을 맞추지 않고 모든 빈의 초기화가 완료된 후에 실행
4. CommandLineRunner: CommandLineRunner 인터페이스의 run 콜백 메소드 안에 원하는 로직 작성 → Spring ApplicationContext 초기화 완료 후에 실행
5. ApplicationRunner: CommandLineRunner 과 동일하게 run이라는 콜백 메소드 안에 로직 작성

## 의존성과 설정값을 생성자 인자로 주입해야 하는 이유에 대해 설명해주세요.
1. 객체의 변경 가능성을 배제하고 불변성 보장
2. 컴파일 시점에 객체를 주입받기 때문에 누락되는 경우 오류 발견 가능, 테스트 코드 작성 가능
3. final 키워드를 사용하기 때문에 컴파일 시점에 누락된 의존성 확인 가능
4. 객체 생성 시점에 순환 참조 에러 확인 가능

## JPA 영속성 컨텍스트의 이점(5가지)을 설명해주세요.
### 영속성 컨텍스트 (Persistence Context)
- Entity를 영구적으로 저장하는 환경
- 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 논리적 개념
- EntityManager를 생성할 때 함께 생성되고(1:1) EntityManager를 통해 접근하고 관리 가능
- 엔티티를 식별자 값으로 구분하기 때문에 식별자 값 반드시 존재
    
### 이점
1. 1차 캐시
   - db 조회하면 db에 쿼리를 날리지 않고 영속성 컨테스트에 저장되어 있는 값을 반환
   - 영속성 컨텍스트에 값이 없을 경우 db에서 값을 조회한 후 1차 캐시에 저장하고 반환
   - DB 조회 횟수 줄일 수 있음
   - 요청이 끝나고 영속성 컨텍스트가 제거되면 1차 캐시도 사라짐
2. 동일성 보장: 1차 캐시에 있는 동일한 인스턴스를 반환하기 때문에 동일성 보장
3. 쓰기 지연: 커밋하는 시점에 쿼리 날리는 것
   - 쓰기 지연 sql 저장소에 쿼리문을 임시로 저장했다가 커밋하는 시점에 저장되어 있는 쿼리를 모아서 날림
   - 하나씩 처리하지 않고 한번에 처리하기 때문에 최적화 가능        
4. 변경 감지: 트랜잭션되면 flush 호출하고 엔티티와 1차 캐시의 스냅샷 비교 → 변경이 있을 경우 update 쿼리를 쓰기 지연 sql에 저장, 커밋 전에 내부적으로 flush 호출해서 변경된 사항 쿼리로 발송
5. 지연 로딩: 연관관계 매핑되어 있는 엔티티 조회시 프록시를 반환하여 쿼리는 진짜 필요할 때 날림

> [Flush]
> - 영속성 컨테스트의 변경 내용을 데이터베이스에 반영
> - 플러시 발생 방법
>   - em.flush()
>   - 트랜잭션 커밋
>   - jpql 커밋 실행

## JPA Propagation 전파단계를 설명해주세요.
### 트랜잭션 전파 속성
- Spring의 @Transactional 어노테이션은 여러 트랜잭션을 묶어서 하나의 트랜잭션 경계를 만들 수 있다.
- 이미 트랜잭션이 진행 중일 때 추가 트랜잭션을 어떻게 진행할지 결정하는 것
    - 기존 트랜잭션에 참여하거나 별도 트랜잭션을 진행하거나 에러를 발생하거나 등을 선택할 수 있다.
### 전파 속성 7가지
- 스프링에는 7가지 속성 존재
- REQUERED
    - default 속성
    - 2개의 논리 트랜잭션을 묶어서 1개의 물리 트랜잭션을 사용하는 것 → 내부 트랜잭션은 기존에 존재하는 외부 트랜잭션에 참여하여 외부 트랜잭션을 그대로 이어감 (외부 트랜잭션 범위가 내부까지 확장)
- REQUERES_NEW
    - 외부 트랜잭션과 내부 트랜잭션을 완전히 분리 → 2개의 물리 트랜잭션 사용, 각각 트랜잭션 별로 커밋과 롤백 수행
    - 2개의 커넥션이 존재하고 내부 트랜잭션이 처리중일 때는 외부 트랜잭션이 대기하기 때문에 데이터베이스 커넥션 고갈 가능
- 이 외에 SUPPORTS, MANDATORY, NOT_SUPPORTED, NEVER, NESTED 가 있음

## JPA를 쓴다면 그 이유에 대해서 설명해주세요.
### JPA
- Java Persistence API, 자바 ORM 기술에 대한 API 표준 명세서
- 자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 효율적으로 관리할 수 있는 프레임워크
- 객체 지향 프로그래밍에서 다루는 복잡한 객체 관계를 RDB가 이애할 수 있는 방식으로 쉽게 변환 가능 → Entity라는 자바 객체와 데이터 베이스 테이블을 매핑하여 객체의 변화를 데이터베이스에 자동으로 반영할 수 있도록 해줌
### 장점
- 개발 생산성, 유지 보수성 향상
- SQL에 의존하지 않고 객체 중심적으로 개발 가능
- 패러다임 불일치 해결
### 고려할 사항
- 불필요한 쿼리 실행 or 데이터베이스와의 상호작용이 비효율적일 수 있기 때문에 성능 최적화를 위한 전략 필요
- N + 1 문제 등 해결 필요

## N + 1 문제는 무엇이고 이것이 발생하는 이유와 이를 해결하는 방법을 설명해주세요.
### N + 1 문제
- 연관관계가 설정된 엔티티를 조회할 경우 데이터 개수만큼 연관관계의 조회 쿼리가 발생하는 문제
- 즉시 로딩일 경우, 데이터를 조회하고 해당 데이터의 연관 관계인 하위 엔티티를 추가로 조회하기 때문에 발생
- 지연 로딩일 경우, 데이터를 조회하고 추가 조회하지는 않지만 하위 엔티티를 사용하게 되면 추가 조회가 발생하기 때문에 결국에는 N + 1 문제 발생
### 해결 방법
1. Fetch Join
    - 지연 로딩으로 설정되어 있는 연관관계에 있는 엔티티에 join 쿼리를 발생시켜 한번에 조회할 수 있는 방법 (미리 join 해놓고 한번에 모든 데이터 호출)
    - db 스키마를 엔티티로 변환해서 영속성 컨텍스트에 저장
        - fetch join을 하면 연관관계는 영속성 컨텍스트에 1차 캐시로 저장되기 때문에 다시 엔티티를 탐색하더라고 조회 쿼리 실행 x
    - 1:N 관계가 두개 이상인 경우 사용할 수 없고 쿼리문 작성 필요
2. @BatchSize
    - 지연 로딩시 프록시 객체를 조회할 때 where in 절로 묶어서 한번에 조회할 수 있게 해주는 옵션
    - fetch join 보다 더 많은 쿼리 개수 발생 가능
3. @EntityGraph
    - attributePaths에 같이 조회할 연관 엔티티명 작성
    - outer join을 기본으로 사용하기 때문에 성능 최적화에 유리하지는 않음 (fetch join은 inner join)
    - 1:N 관계를 여러개 join할 수 있음
