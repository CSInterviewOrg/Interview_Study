## JVM의 구조와 Java의 실행방식을 설명해주세요.
### JVM
- Java virtual machine, 자바 가상 머신
- 자바 코드를 컴퓨터가 이해할 수 있도록 기계어로 변환해주고 운영체제에 구애 받지 않고 프로그램을 실행할 수 있도록 도와주는 중개자 역할
- 가비지 컬렉션을 사용해서 메모리 관리를 자동으로 수행
- 레지스터 기반이 아닌 스택 기반으로 동작
### JVM 구조
크게 Garbage collector, Execution Engine, Class Loader, Runtime Data Area 4가지로 구분
1. **Class Loader**
    - 런타임 시에 동적으로 클래스 파일 로딩하고 runtime data area로 적재
1. **Execution Engine**
    - 메모리에 적재된 바이트 코드를 기계어로 변환해 명령어 단위로 읽어 실행하는 역할
    - 인터프리터 방식을 사용하다가 성능이 떨어질 때에 JIT 컴파일러 방식으로 실행해서 속도 향상 및 성능 최적화
    - JIT 컴파일러는 바이트 코드를 네이티브 코드(기계어)로 바꿔서 실행은 빠르지만 변환하는데 비용 발생
    - Class Loader를 통해 JVM 내의 Runtime Data Area에 배치된 바이트 코드를 명령어 단위로 읽어서 실행
1. **Garbage Collector**
    - 힙 메모리 영역에 생성된 객체 중에서 참조되지 않은 객체를 탐색 후 제거
1. **Runtime Data Area**
    - JVM의 메모리 영역, 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역
    1. **Method Area**
        1. 모든 쓰레드가 공유하는 메모리 영역
        2. 클래스, 인터페이스, 메소드, 필드 등의 바이트 코드 보관
    2. **Heap area**
        1. 모든 쓰레드가 공유, 생성된 모든 객체와 배열이 저장되는 영역
        2. 호출이 끝난 후, 삭제되지 않고 유지되다가 GC가 참조되지 않는 메모리 확인해서 제거하는 영역
    3. **Stack area**
        1. 쓰레드 마다 존재
        2. 메서드 안에서 사용되는 값, 호출되는 메서드의 매개변수, 지역변수 등을 임시로 저장
    4. **PC Register**
        1. 쓰레드마다 하나씩 존재하고 쓰레드 시작시 생성
        2. 쓰레드가 어떤 부분을 무슨 명령으로 실행해야 할지에 대한 기록하는 부분
        3. 현재 수행 중인 JVM 명령의 주소
    7. **Native method stack**
        1. 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역
### Java 실행 방식
1. 자바 컴파일러가 자바 소스 파일을 바이트 코드로 변환
2. Class Loader를 통해 바이트 코드를 JVM으로 로딩하여 Runtime Data Area에 배치
3. Execution Engine이 메모리 영역에 올라온 바이트 코드 실행

## GC가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.
### 가비지 컬렉션
자바의 메모리 관리 방법, heap 영역에서 더이상 사용하지 않는 객체의 메모리를 주기적으로 검사해서 삭제하는 역할
### 필요성
한정적인 메모리 자원을 효율적으로 사용하기 위해 필요하지 않은 부분은 지워서 메모리 누수 방지
### 동작 방식
- 객체가 참조되고 있는 상태(Reachable)와 아닌 상태(Unreachable)로 구분
    > 참고되고 있는 상태: 다른 영역에서 힙 영역에 있는 객체를 참조하는 경우
- Mark and Sweep 방식
    - 대상 객체를 식별하고 제거하며 객체가 제거되어 파편화된 메모리 영역을 앞에서부터 채워나가는 작업 수행
### 동작 과정
- 객체의 생존 기간에 따라 힙 영역을 young과 old 2가지 영역으로 설계
    - Young 영역
        - 새롭게 생성된 객체가 할당되는 영역
        - 많은 객체가 young 영역에 생성되었다가 사라짐 (대부분의 객체는 일회성이고 메모리에 오랫동안 남아있는 경우는 흔하지 않음)
        - young 영역에 대한 가비지 컬렉션 = Minor GC
    - Old 영역
        - young 영역에서 살아남은 객체가 복사되는 영역
        - young 영역보다 크게 할당, 영역 크기가 큰 만큼 가비지 적게 발생
        - old 영역에 대한 가비지 컬렉션 = Major GC or Full GC
- 공통적인 방식
    - Stop the world
        - 가비지 컬렉션 실행을 위해 JVM이 애플리케이션의 실행을 멈추는 작업
        - GC를 실행하는 쓰레드 제외한 모든 쓰레드의 작업 중단
    - Mark and sweep
        - 객체 탐색하고 식별하여 사용되고 있지 않은 객체를 메모리에서 제거
- Minor GC
    - 상대적으로 공간이 작아 메모리상의 객체를 찾아 제거할 때 드는 시간이 적음
    - 처음 생성되면 Eden 영역에 위치 → Eden 영역이 꽉차면 Minor GC 실행 → Mark 동작을 통해 reachable 객체 탐색 → 살아남은 객체는 Survivor 영역으로 이동 → reachable 객체는 메모리 해제(sweep) 과정 반복
- Major GC
    - 상대적으로 큰 공간을 가지기 때문에 객체 제거에 많은 시간 소요
    - 객체의 age(살아남은 횟수)가 임계값에 도달하면 Old 영역으로 이동(promotion) → Old 영역에 공간이 꽉차면 Major GC 실행(stop the world)
- 이외에 다른 방식
    - Serial GC
    - Parallel GC
    - CMS GC
    - G1 GC
    
## 컬렉션 프레임워크에 대해서 설명해주세요.
다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합
= 데이터를 저장하는 자료구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현해놓은 것

* 데이터를 저장하는 자료 구조에 따라 주요 인터페이스 정의
   * List
   * Set
   * Map
   이 중에서 List, Set은 모두 Collection 인터페이스를 상속 받지만, Map은 구조상의 차이로 별도로 정의 => List, Set의 공통된 부분을 Collection에서 정의

## 제네릭에 대해서 설명해주세요.
데이터의 타입을 일반화하는 것 = 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법

- 컴파일 시에 미리 타입 검사를 수행하기 때문에 가지는 장점
    - 클래스나 메소드 내부에서 사용되는 객체의 타입 안정성 상승
    - 반환값에 대한 타입 변환 및 테스트 리소스 감소

## 애노테이션에 대해서 설명해주세요.
주석과 같은 역할을 하면서 코드에 특별한 의미, 기능 부여

- 장점
    - 컴파일러에게 코드 작성 문법 에러를 체크하도록 정보 제공
    - 소프트웨어 개발 환경이 빌드나 배포시 코드를 자동으로 생성할 수 있도록 정보 제공
    - 런타임에 특정 기능을 실행하도록 정보 제공

## 오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있을까요?
둘다 메소드의 다형성을 구현하는 것에 사용
### 오버라이딩
* 상속받은 메소드를 재정의하는 것
* 부모 클래스에서 정의한 메소드를 자식 클래스에서 재정의하며 상속받은 메소드를 상황에 맞게 사용 가능 => 코드의 재사용성, 확장성 상승
### 오버로딩
* 같은 이름의 메소드를 여러 개 정의하는 것
* 메소드의 이름은 동일하지만 파라미터의 타입이나 개수의 차이를 통해 같은 기능을 하는 메소드를 다양한 방식으로 호출 가능 => 코드의 가독성, 재사용성 상승

> @ Override 어노테이션 사용 이유
> 부모 클래스에 있는 메소드를 오버 라이드 했다는 것을 명시적으로 선언
> 여러 개의 메소드가 있을 경우 어떤 메소드가 오버라이드 되었는지 명시적으로 표시
> 컴파일시 문법 체크 가능

## 인터페이스와 추상클래스의 차이점에 대해 설명해주세요.
설계의 목적과 프로젝트의 요구사항에 따라 사용 결정
### 인터페이스
* 모든 메서드가 추상 메서드로 구성되어 구현 클래스에서 구현해야 함
* 구현 객체가 같은 동작을 보장하도록 하기 위해 사용
* 다중 상속을 지원하기 때문에 유연성, 확장성 제공
### 추상 클래스
* 추상, 일반 메서드 모두 포함 가능
* 공통적인 기능은 미리 구현하고 일부 기능은 자식 클래스에서 구현함으로써 코드의 중복 방지, 유지 보수 용이, 개발 시간 단축 가능
* 단일 상속만 지원

## 클래스는 무엇이고 객체는 무엇인가요?
설계도 <-> 설계도를 바탕으로 생성된 실체
### 클래스
객체를 생성하기 위한 틀, 객체의 속성과 행위 정의
### 객체
클래스에 정의된 속성과 행위를 실제로 구현하는 것, 프로그램에서 실제로 작업을 수행하는 주체
