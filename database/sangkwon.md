# 데이터베이스 개요

## 데이터베이스란 무엇인가요?

데이터베이스란 데이터를 저장하고 검색하며 수정할 수 있으며 삭제할 수 있는 데이터 관리 시스템입니다.

## RDBMS와 NoSQL의 차이점은 무엇인가요?

- **RDBMS**의 구조는 행과 열입니다. 이 행과 열을 기준으로 데이터가 관리되며 스키마의 형식이 정의되어 있어 정의되어 있는 형식으로 데이터를 관리할 수 있습니다. 또한 트랜잭션의 일관성을 보장하기에 데이터의 무결성 측면에서 장점이 있으며 성능을 향상시킬 때 수직적 확장에 의존합니다.
- **NoSQL**의 구조는 행과 열이 아닌 다양한 형태로 데이터를 관리하는 구조입니다. 스키마가 고정되어 있기에 사전에 정의될 필요 없이 데이터를 관리할 수 있습니다. NoSQL은 가용성과 확장성 측면에 이점이 있기에 트랜잭션 처리에 대해서는 일부적으로 지원합니다. 또한 NoSQL은 수평적 확장이 가능하여 대용량 데이터 처리에 장점이 있습니다.

## SQL이란 무엇이며, SQL의 종류에는 무엇이 있나요?

- SQL은 데이터베이스를 사용하기 위한 프로그래밍 언어입니다. SQL의 종류로는 DDL, DML, DCL, TCL이 존재합니다.
  - **DDL**: 데이터베이스의 구조(테이블, 인덱스 등)를 정의하고 수정
  - **DML**: 데이터베이스에 저장된 데이터를 조회, 삽입, 수정, 삭제
  - **DCL**: 데이터에 대한 액세스를 제어
  - **TCL**: 트랜잭션을 관리하고 데이터의 일관성을 유지하는 데 사용

## 데이터베이스 스키마란 무엇인가요?

관계형 데이터베이스에서 데이터가 저장되는 형식을 말하며 테이블, 열, 데이터 타입, 키, 제약 조건 등등을 이용하여 정의한 구조를 말합니다. 이 스키마를 다양한 관점에서 바라볼 수 있으며 개념 스키마, 논리적 스키마, 물리적 스키마가 있습니다.

- **개념 스키마**: 데이터베이스의 구조를 고수준에서 바라보는 것을 말하며 ERD를 이용해서 표현한 수준의 스키마를 의미합니다.
- **논리적 스키마**: 데이터베이스의 구조를 행과 열, 키, 제약조건 등등을 이용해서 표현한 수준의 스키마를 말하며 데이터베이스와 독립적인 수준의 스키마를 의미합니다.
- **물리적 스키마**: 실제로 데이터가 어떻게 관리되는지를 정의하는 수준의 단계로 DBMS과 하드웨어에 영향을 받는 수준의 스키마를 말합니다.

## 테이블과 뷰(View)의 차이점은 무엇인가요?

- **테이블**은 데이터베이스에 정의된 형식으로 되어 있는 물리적인 저장소를 말합니다. **뷰**는 가상의 테이블로 기존의 테이블과 데이터를 참조하여 생성된 가상의 테이블을 말합니다.
- 테이블은 데이터를 저장, 수정, 삭제가 가능하지만 뷰는 데이터를 조회할 수밖에 없습니다.

## 기본키(Primary Key)와 외래키(Foreign Key)의 차이점은 무엇인가요?

- **기본키**는 각 레코드를 구별하기 위한 컬럼을 말하며 **외래키**는 테이블과 테이블 간의 관계를 설정하기 위한 컬럼을 말합니다. 외래키는 한 테이블에서 다른 테이블의 기본키를 참조하는 컬럼을 말합니다. 외래키는 참조 무결성을 보장하기에 테이블과 다른 테이블 간의 데이터 일관성을 보장합니다.

## ACID란 무엇이며, 각각의 의미를 설명해주세요.

- **ACID**는 트랜잭션의 신뢰성과 무결성을 보장하기 위한 원칙을 말합니다.
  - **원자성(Atomicity)**: 트랜잭션은 전체가 실행되거나, 실패 시 아무것도 실행되지 않음을 보장하는 원칙
  - **일관성(Consistency)**: 트랜잭션 전후에 데이터베이스는 항상 유효한 상태를 보장하는 원칙을 의미
  - **고립성(Isolation)**: 트랜잭션은 다른 트랜잭션의 영향을 받지 않는 원칙
  - **지속성(Durability)**: 트랜잭션이 완료된 후에는 그 결과가 영구적으로 저장되는 원칙

## 트랜잭션이란 무엇인가요?

데이터베이스에서 논리적인 작업의 단위를 의미합니다. 예를 들어서 하나의 쿼리를 실행하는 것이 하나의 트랜잭션이 될 수도 있으며 여러 개의 쿼리가 하나의 트랜잭션이 될 수도 있습니다.

## 데이터베이스의 정규화(Normalization)란 무엇이며, 그 목적은 무엇인가요?

테이블 내에서 중복된 데이터를 제거하여 데이터 일관성을 유지하기 위해 테이블의 구조를 개선해 나가는 과정입니다. 결과적으로 중복된 데이터를 제거하기에 데이터베이스 서버의 불필요한 디스크 및 메모리 낭비를 방지할 수 있으며 데이터의 신뢰성 측면에 향상을 위하기에 정규화를 진행합니다.

- **1차 정규화**: 각 컬럼이 하나의 값을 가질 수 있도록 정규화하는 과정입니다.
- **2차 정규화**: 기본키가 아닌 모든 컬럼이 기본키의 일부에 종속되지 않도록 정규화하는 과정입니다.
- **3차 정규화**: 기본키가 아닌 모든 컬럼이 기본키에 종속되지 않도록 정규화하는 과정입니다.

## 역정규화(Denormalization)란 무엇이며, 언제 사용하나요?

역정규화는 정규화의 과정을 반대로 진행하는 과정으로 정규화를 통해 분리된 테이블을 다시 합치는 과정을 의미합니다. 데이터의 중복과 신뢰성이 떨어지는 대신에 테이블 간의 복잡한 조인 연산을 줄여 읽기 성능을 향상시키기 위해 진행합니다.

## INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN의 차이점은 무엇인가요?

- **INNER JOIN**: 두 테이블의 공통적인 데이터들에 대해서만 결합합니다.
- **LEFT JOIN**: 왼쪽 테이블의 모든 데이터와 조인 조건을 만족하는 오른쪽 테이블의 데이터에 대해서만 결합합니다. 오른쪽 테이블에 매칭되는 행이 없는 값에 대해서는 NULL로 데이터가 채워집니다.
- **RIGHT JOIN**: 오른쪽 테이블의 모든 데이터와 조인 조건을 만족하는 왼쪽 테이블의 데이터에 대해서만 결합합니다. 왼쪽 테이블에 매칭되는 행이 없는 값에 대해서는 NULL로 데이터가 채워집니다.
- **FULL JOIN**: 양쪽 테이블의 모든 행을 반환합니다. 조인 조건이 만족되는 행에 대하여 조인 테이블에 데이터가 없는 경우 NULL로 데이터가 채워집니다.

## GROUP BY와 HAVING의 차이점은 무엇인가요?

**GROUP BY**는 특정 조건에 한하여 데이터를 그룹화 하는 것을 말하며 **HAVING**은 그룹화 된 데이터에 대해서 특정 조건으로 필터링하는 것을 말합니다.

## WHERE와 HAVING의 차이점은 무엇인가요?

**WHERE** 절은 테이블의 개별 행에 대해서 필터링을 하는 것이며 **HAVING**은 **GROUP BY** 절에 의해 그룹화 된 개별 행에 대해서 필터링을 하는 것입니다.

## DISTINCT 키워드는 무엇을 하는가요?

중복된 데이터를 제거하는 키워드입니다.
- **DISTINCT**는 결과 값에 대해서 다시 한번 풀 스캔을 하여 중복된 데이터를 제거하기기에 레코드 수가 많을 경우 쿼리 성능에 안 좋을 수 있습니다.

## 서브쿼리란 무엇이며, 서브쿼리의 종류에는 무엇이 있나요?

서브쿼리는 쿼리 내에서 또 다른 쿼리를 중첩해서 사용하는 쿼리 형식을 말합니다.

- **스칼라 서브쿼리**: 단일 값을 반환하는 서브 쿼리
- **행 서브쿼리**: 하나의 행을 반환하는 서브 쿼리
- **테이블 서브쿼리**: 결과 값을 임시 테이블 형태로 반환하는 서브쿼리
- **상관 서브쿼리**: 서브 쿼리가 메인 쿼리에 의존하는 형태의 서브쿼리
- **비상관 서브쿼리**: 서브 쿼리가 메인 쿼리와 독립적인 형태의 서브쿼리

## UNION과 UNION ALL의 차이점은 무엇인가요?

- **UNION**: 두 개 이상의 쿼리를 조합할 때 중복된 결과 값을 제거하는 쿼리
- **UNION ALL**: 두 개 이상의 쿼리를 조합할 때 중복된 결과 값을 포함하는 쿼리

## EXISTS와 IN의 차이점은 무엇인가요?

- **EXISTS**: 특정 조건을 만족하는 데이터가 존재하는지만 확인하는 것으로 데이터의 실제 값을 비교하지 않습니다.
- **IN**: 특정 조건을 만족하는 데이터가 존재하며 데이터의 실제 값을 비교하기에 단순하게 데이터를 확인하는 경우 **EXISTS** 키워드보다 성능이 좋지 않습니다.

## COUNT, SUM, AVG, MIN, MAX 같은 집계 함수에 대해 설명해주세요.

- **COUNT**: 데이터 집합 내의 행 수를 반환합니다.
- **SUM**: 데이터 집합 내의 값을 합산하여 반환합니다.
- **AVG**: 데이터 집합 내의 값의 평균을 반환합니다.
- **MIN**: 데이터 집합 내의 최소값을 반환합니다.
- **MAX**: 데이터 집합 내의 최대값을 반환합니다.

## 데이터베이스에서 뷰(View)란 무엇이며, 장단점은 무엇인가요?

- **뷰**란 실제 데이터를 특정 조건에 한하여 필터링 된 레코드들에 대해서 구성된 임시 테이블을 말합니다.
  - **장점**: 필터링된 레코드들이 저장되어 있기에 결과 값들을 재사용할 수 있다는 장점이 있습니다.
  - **단점**: 뷰는 동적으로 SELECT한 데이터를 사용하기에 뷰를 호출할 때마다 계속해서 SELECT가 되기에 성능 측면에서 단점이 있습니다.

## CASE문을 사용하여 조건부로 데이터를 조회하는 방법을 설명해주세요.
- **단순 CASE 문**: 특정 값이 주어진 조건과 일치할 때 결과를 반환하는 방식
```sql
SELECT EmployeeID, Name,
       CASE DepartmentID
           WHEN 1 THEN 'Sales'
           WHEN 2 THEN 'Marketing'
           WHEN 3 THEN 'Engineering'
           ELSE 'Other'
       END AS DepartmentName
FROM Employees;
```

- **검색 CASE 문**: 특정 조건이 주어진 조건과 일치할 때 결과를 반환하는 방식
```sql
SELECT EmployeeID, Name, Salary,
       CASE
           WHEN Salary < 30000 THEN 'Low'
           WHEN Salary BETWEEN 30000 AND 70000 THEN 'Medium'
           WHEN Salary > 70000 THEN 'High'
           ELSE 'Unknown'
       END AS SalaryCategory
FROM Employees;
```

# 데이터베이스 인덱스 및 트랜잭션

## 인덱스란 무엇인가요?

- **데이터베이스에서 데이터 조회 성능을 향상시키기 위한 구조**
- **인덱스를 통해 테이블의 레코드에 접근하기에 보다 빠른 조회 가능**
- **인덱스 데이터를 저장하기 위한 별도의 데이터 공간(디스크 공간)이 필요**
- **레코드를 INSERT, UPDATE, DELETE 할 때 인덱스 컬럼도 같이 진행해야 하기에 해당 기능들에 대해서는 성능 저하 발생**
  - 조회 성능과 수정 기능은 반비례 관계

## 클러스터드 인덱스(Clustered Index)와 넌클러스터드 인덱스(Non-clustered Index)의 차이점은 무엇인가요?

- **레코드가 저장될 때 어떻게 저장되는지가 다릅니다.**

### 클러스터드 인덱스
- **테이블의 실제 데이터가 인덱스에 의해 정렬된 상태로 저장**
- **테이블의 행 자체가 클러스터드 인덱스의 순서에 따라 디스크에 물리적으로 배치**
- **하나의 정렬된 기준으로 데이터가 저장되기에 테이블에 클러스터드 인덱스는 한 개**
  - **일반적으로 테이블의 클러스터드 인덱스는 기본키로 설정**

### 넌클러스터드 인덱스
- **테이블의 실제 데이터와는 별도로 인덱스 자체에 대한 정보만 정렬**
- **이를 통해서 테이블의 실제 레코드에 대한 참조 값을 인덱스가 가지고 있는 상태**
- **검색 성능은 클러스터드 인덱스가 더 좋음**

## 인덱스를 언제 사용하는 것이 적합한가요?

- **INSERT, UPDATE, DELETE 키워드를 잘 사용하지 않고 SELECT 키워드를 많이 사용하는 컬럼에 대해서 사용**

## 인덱스 사용이 성능에 미치는 영향은 무엇인가요?

- **인덱스를 통한 데이터 접근으로 데이터 조회 성능 향상**
- **이미 정렬되어 있는 인덱스를 통한 데이터 정렬 성능 향상**
- **조인 과정 시 인덱스를 통한 조인 성능 향상**
- **데이터 변경 시 이미 정렬되어 있는 인덱스를 다시 한번 정렬 하기에 쓰기, 수정, 삭제 기능 저하**
- **인덱스에 대한 별도의 데이터 저장 공간이 필요하기에 디스크 사용 공간 증가**

## 인덱스의 구조는 무엇인가요?

### B-Tree 인덱스 구조
- **인덱스가 균형 잡힌 트리 구조를 가지고 있는 형태**
- **각 노드는 자신이 가질 수 있는 최소, 최대 자식 노드 개수가 있으며 트리의 높이를 최대한 낮게 유지하도록 균형을 이룸**
- **각 노드 key:value 형태로 이루어져 있으며 key 값은 인덱스에 대한 ID 값, value는 실제 레코드에 대한 주소 값을 가지고 있는 형태**
- **루트 노드에서 자식 노드로 특정 키 값을 탐색하는 과정으로 동작**

### B+Tree 인덱스 구조
- **리프 노드에만 실제 데이터 주소 값을 가지며 각 리프 노드는 연결 리스트 형태로 이루어져 있는 인덱스 구조**
- **B-Tree 인덱스 구조의 경우 리프 노드 이전에 데이터를 탐색할 수 있기에 특정 케이스에 대해 B-Tree 인덱스 구조가 더 빠를 수 있음**
- **하지만 리프 노드에만 실제 데이터가 있기에 검색 속도가 균일하고 연결 리스트로 되어 있기에 범위 탐색에 보다 효과적임**

### 해시 테이블 구조
- **key:value 형태의 인덱스 구조**
- **각 키에 접근할 때 시간 복잡도가 O(1)이지만 범위 검색을 진행할 경우 인덱스가 순서대로 저장되어 있지 않기에 범위 탐색 시 모든 버킷에 대해서 전체 탐색을 진행해야 함**

## 인덱스를 너무 많이 만들면 성능에 어떤 영향이 있나요?

- **인덱스도 결국에는 스캔 과정이 필요하기에 인덱스가 너무 많은 경우 인덱스 스캔 자체의 성능이 떨어짐**
- **인덱스도 결국에는 디스크와 같은 저장공간이 필요하기에 저장 공간이 너무 많아지면 디스크 I/O가 많아지고 이에 따라서 디스크에서 메모리로 불러오는 과정이 느려짐 → 이에 따라 쿼리 성능 자체에 영향을 줌**

## Composite Index(복합 인덱스)란 무엇인가요?

- **두 개 이상의 컬럼에 대해서 하나의 인덱스로 설정하는 것**
- **column1과 column2에 대해서 단일 인덱스로 설정 후 해당 컬럼에 대해 조건을 같이 사용하면 두 컬럼에 대해서 각각 독립적으로 탐색한 후 탐색 결과를 연산해야 함 → 복합 인덱스 사용 시 두 조건을 동시에 만족하는 인덱스를 통해 탐색**
- **실제 동작 과정은 첫 번째 인덱스를 사용한 후 두 번째 인덱스를 사용하기에 첫 번째 인덱스를 통해 탐색 범위를 줄이는 것이 중요함**

## 인덱스 설계 시 주의해야 할 점은 무엇인가요?

- **카디널리티가 높은 컬럼에 대해서 인덱스를 설계하는 것이 중요 → 인덱스가 실제 레코드를 참조하는 탐색 범위를 줄일 수 있기 때문**

## 데이터베이스에서 인덱스의 재구성(Rebuild)과 재구성하지 않음(Reorganize)은 무엇이 다른가요?

- **인덱스는 페이지로 이루어짐 → 페이지는 루트 페이지(Tree 구조에서 노드의 시작점), 내부 페이지(자식 페이지에 대한 위치 값을 가지는 페이지), 자식 페이지(실제 데이터에 대한 위치 값을 가지는 페이지)로 구성**
- **내부 페이지와 자식 페이지는 2개 이상이며 데이터가 새로 생기거나 삭제될 때 균형을 이뤘던 페이지가 불균형을 이루게 되며 페이지에서 빈 공간이 생기게 됨 → 이러한 현상을 조각화라고 표현하며 이는 조회 성능에 영향을 줌**

### 인덱스 재구성 (Rebuild)
- **기존 인덱스를 삭제하고 새로운 인덱스를 설정으로 조각화를 제거하는 방법**
- **인덱스를 삭제하고 새로 생성하기에 시간 소요가 큼**

### 인덱스 재구성하지 않음 (Reorganize)
- **기존 인덱스의 페이지를 재정렬하는 방식으로 조각화를 줄이는 방법**
- **정렬하는 방식이기에 페이지의 빈 공간에 대해서 최적화를 이루는 것 뿐이여서 제한적인 조각화 해결 가능**

## 인덱스 힌트(Index Hint)란 무엇이며, 언제 사용하나요?

- **인덱스 힌트: SQL 쿼리 실행 시 특정 인덱스를 사용하도록 명시적으로 사용하도록 하는 방법**
- **옵티마이저가 자동 선택한 인덱스가 비효율적이거나 특정 인덱스의 성능 테스트를 하기 위해 사용**

## 트랜잭션의 고립 수준(Isolation Level)에 대해 설명해주세요.

1. **Read Uncommitted**
   - **다른 트랜잭션이 커밋하지 않은 데이터에 대해서 읽기 가능한 수준**
   - **커밋을 보장하지 않기에 읽었던 데이터가 롤백 되는 경우에 대한 잘못된 데이터를 읽을 수 있음**

2. **Read Committed**
   - **다른 트랜잭션이 커밋한 데이터에 대해서 읽기 가능한 수준**
   - **트랜잭션 T1이 두 번의 SELECT를 진행한다고 했을 때 트랜잭션 T2가 T1 첫 번째 이후 값을 변경하면 트랜잭션 T1에서 첫 번째와 두 번째 SELECT 결과 값이 달라짐**

3. **Repeatable Read**
   - **트랜잭션이 시작 될 때와 끝날 때 읽은 데이터의 값이 동일함을 보장하는 수준**
   - **트랜잭션이 진행될 때 해당 트랜잭션이 끝나는 동안 다른 트랜잭션이 자신이 사용하고 있는 데이터에 대해서 변경을 못하게 막음**
   - **대신에 새로운 레코드를 추가하거나 삭제는 가능**

4. **Serializable**
   - **모든 트랜잭션이 모두 독립적인 수준으로 진행됨을 보장하는 수준**
   - **트랜잭션들을 처리할 때 모든 트랜잭션에 순서성을 부여해서 독립적으로 처리하도록 함**
   - **동시에 트랜잭션을 처리할 경우 경쟁 상태에 빠질 수 있음**

## Dirty Read, Non-repeatable Read, Phantom Read에 대해 설명해주세요.

- **Dirty Read:** Read Uncommitted 격리 수준에서 발생하며 커밋 되지 않고 롤백된 데이터를 읽는 현상
- **Non-repeatable Read:** Read Uncommitted, Read Committed 격리 수준에서 발생하며 동일 트랜잭션에서 데이터를 읽을 때 값이 달라지는 현상
- **Phantom Read:** Read Uncommitted, Read Committed, Repeatable Read에서 발생하며 같은 트랜잭션으로 처리될 때 레코드의 개수가 달라지는 현상

## 낙관적 잠금(Optimistic Locking)과 비관적 잠금(Pessimistic Locking)의 차이점은 무엇인가요?

- **낙관적 잠금(Optimistic Locking):** 트랜잭션의 커밋 시점에 기존에 데이터 값과 변경이 되면 해당 트랜잭션을 재시도 하거나 롤백하는 방식 → 실제로 락을 걸지는 않음
- **비관적 잠금(Pessimistic Locking):** 트랜잭션이 접근하는 시점에 무조건적으로 락을 걸어 다른 트랜잭션이 접근하는 것을 막는 방식

## 트랜잭션에서 발생할 수 있는 동시성 문제에는 어떤 것들이 있나요?

- **Dirty Read**
- **Non-repeatable Read**
- **Phantom Read**

## Deadlock이란 무엇이며, 이를 방지하는 방법은 무엇인가요?

- **Deadlock:** 각각 자원을 가지고 있는 트랜잭션들이 동시에 다른 트랜잭션에 접근할 때 모두가 대기 상태에 빠지는 것
- **해결 방법:** 데드락에 빠진 트랜잭션 중 하나의 트랜잭션에 대해서 롤백을 처리하여 나머지 트랜잭션이 대기 상태에서 벗어나게 하는 방법, 테이블 단위의 락에서 레코드 단위의 락으로 락의 빈도수를 줄이는 방법 등

## 트랜잭션 로그(Transaction Log)란 무엇인가요?

- **데이터베이스 시스템에서 트랜잭션의 모든 변경 사항과 작업을 기록하는 로그**

## 데이터베이스 커밋과 롤백의 차이점은 무엇인가요?

- **커밋:** 트랜잭션이 성공적으로 처리 되어 결과 값을 데이터베이스에 영구적으로 반영하는 것
- **롤백:** 트랜잭션 과정 중 실패하여 트랜잭션이 시작되기 이전의 데이터베이스 상태로 돌아가는 것

## 트랜잭션 타임아웃이란 무엇인가요?

- **트랜잭션을 처리할 때 최대 시간을 의미, 해당 시간이 넘어가면 롤백 처리 됨**

## 쿼리 튜닝(Query Tuning)이란 무엇인가요?
- SQL 쿼리의 실행 시간을 줄이고 CPU, 메모리, I/O와 같은 시스템 리소스를 최소한으로 사용하도록 쿼리를 개선하는 것
- 쿼리 튜닝 과정은 자주 사용되는 WHERE 절의 컬럼에 대해서 인덱스 또는 복합 인덱스로 설정, JOIN 시 인덱스 설정을 하거나 비효율적인 서브쿼리를 JOIN으로 바꿔서 진행

## 쿼리 실행 계획(Execution Plan)이란 무엇이며, 이를 분석하는 방법을 설명해주세요.
- 쿼리 실행 계획이란 데이터베이스 옵티마이저가 쿼리를 실행하기 전에 최적의 실행 경로를 결정하고, 그 경로가 데이터베이스에서 어떻게 동작하는지, 어디에서 성능 병목 현상이 발생하는지를 분석하는 것
- **id: 실행 순서를 표시하는 숫자**
- **select_type:** SQL문을 구성하는 SELECT 문의 유형을 출력하는 항목
    - SIMPLE: UNION, 내부 쿼리가 없는 SELECT 문
    - PRIMARY: 서브쿼리를 감싸는 외부 쿼리이거나 UNION이 포함된 SQL 문의 첫 번째 SELECT
    - SUBQUERY: 독립적으로 수행되는 서브쿼리
    - DERIVED: 서브쿼리 또는 뷰에서 유도된 테이블.
- table: 해당 단계에서 접근하는 **테이블의 이름**
- partitions: 쿼리에 사용된 파티션 정보
- type: join 타입
    - **system**: 테이블에 하나의 행만 있는 경우.
    - **const**: 인덱스의 유일한 값을 사용하여 해당 테이블을 한 번만 읽는 경우.
    - **eq_ref**: 주로 **primary key** 또는 **unique key**와 조인할 때 발생.
    - **ref**: 인덱스를 통해 테이블을 참조하는 조인.
    - **range**: **범위 검색**을 할 때, 예를 들어 `BETWEEN`, `>`, `<` 등을 사용한 경우.
    - **index**: **인덱스 스캔**을 의미하며, 인덱스 전체를 읽음
    - **ALL**: **전체 테이블 스캔**으로, 성능이 가장 낮은 방식입니다. 이 경우 쿼리 튜닝이 필요
- possible_keys: 쿼리에서 사용할 수 있는 **인덱스 목록**
- key: 실제로 사용된 인덱스
- key_len: 인덱스를 사용한 키의 길이
- ref: 인덱스와 비교된 컬럼
- rows: 예상 처리 row의 개수
- filtered: 조건에 따라 필터링 된 행의 비율로 100%에 가까울수록 좋음
- Extra: 추가 정보
    - **Using index**: **커버링 인덱스**가 사용되었다는 의미로 테이블을 사용하지 않고 인덱스만 사용함 → 좋음
    - **Using where**: **WHERE 조건**이 적용
    - **Using temporary**: 임시 테이블이 사용
    - **Using filesort**: **파일 정렬**이 사용 → 좋지 못함

## 인덱스 스캔(Index Scan)과 테이블 스캔(Table Scan)의 차이점은 무엇인가요?

- 인덱스 스캔: 검색 시 인덱스를 사용한 스캔으로 인덱스를 적용한 컬럼을 사용할 때 사용 됨, 사용 됐다라는 의미는 WHERE, JOIN 등등 키워드에 인덱스 사용을 의미
- 테이블 스캔: 검색 시 인덱스를 사용하지 않고 테이블의 모든 레코드에 대해서 순차적으로 하나씩 스캔, 인덱스를 전혀 사용하지 않았기에 조회 성능이 느림 ↔ 반대로 테이블의 레코드가 너무 적을 경우에는 테이블 스캔이 인덱스 스캔보다 효율적일 수 있음

## 데이터베이스에서 Partitioning이란 무엇인가요?**

- 레코드나 인덱스가 너무 많은 하나의 테이블을 여러 개의 테이블로 쪼개는 것을 의미 → 쿼리 성능 향상
- 반대로 파티셔닝을 진행하면 테이블이 쪼개지기에 테이블간의 조인이 발생하면 오히려 쿼리 성능이 안좋아질 수 있음 → 조인이 잘 안되지 않는 선에서 파티셔닝을 처리해야 함
- Range Partitioning (범위 파티셔닝): 데이터를 특정 범위로 파티셔닝 하는 방법, ex) 기간
- List Partitioning (리스트 파티셔닝): 데이터를 특정 타입을 기준으로 파티셔닝 하는 방법, ex) 결제 유형
- Hash Partitioning (해시 파티셔닝): 데이터의 특정 값을 해싱 값을 기준으로 파티셔닝 하는 방법
- Key Partitioning (키 파티셔닝): 기본키 또는 특정 키 값을 기준으로 파티셔닝 하는 방법

## Sharding이란 무엇이며, 언제 사용하나요?**

- 하나의 데이터베이스에 저장되어 있는 데이터를 여러 개의 데이터베이스 서버로 분할하는 방법 → 스케일 아웃 방식 → 이 때 각 샤딩된 데이터베이스 서버를 샤드라고 표현
- 샤딩된 각 테이터베이스의 테이블 구조는 동일하지만 저장 되어 있는 데이터가 서로 다름
- 범위 기반 샤딩: 데이터를 범위 기반으로 샤딩하는 방법, ex) 기간
- 해시 기반 샤딩: 특정 컬럼에 대한 데이터에 대해서 해싱 처리를 한 값을 기준으로 샤딩하는 방법
- 키-값 기반 샤딩: 기본 키 혹은 특정 키(컬럼)을 기준으로 샤딩하는 방법
- 분할된 샤드에서 데이터를 찾는 방법: 샤딩 전략에 따른 샤딩 키 값을 기준으로 샤드를 찾음, ex) 샤딩 전략이 해시 기반일 경우 요청 데이터에 대해서 해싱 처리한 값으로 샤드를 찾는 방법, 또는 Application에서 샤딩 키 값을 가지는 비즈니스 로직을 이용해서 샤드에 접근

## 데이터베이스의 캐싱 전략에는 어떤 것들이 있나요?**

- 쿼리 결과 캐싱 (Query Result Caching): 특정 쿼리의 결과를 캐시에 저장하여 동일한 쿼리가 들어왔을 때 데이터베이스에 다시 요청하지 않고, 캐시에 저장된 결과를 반환하는 방법
- 페이지 캐싱 (Page Caching): 데이터베이스 페이지(일정 크기의 데이터 블록)를 캐시에 저장한 후 해당 페이지에 대한 요청이 들어오면 캐시에서 제공하는 방식
- **객체 캐싱 (Object Caching): 이터베이스에서 읽은 개별 객체나 레코드를 캐시에 저장하는 방식. 자주 조회되는 특정 객체(예: 사용자 프로필, 상품 정보)를 캐시에 저장해, 이후에는 데이터베이스를 조회하지 않고 캐시에서 데이터를 반환하는 방식**
- 읽기 전용 캐시(Read-Through Cache): 데이터베이스에서 데이터를 가져오지 않고, 캐시에서 직접 데이터를 읽는 방식. 캐시에 데이터가 없으면 데이터베이스에서 읽어와 캐시에 저장하고, 이후 캐시에서 응답하는 방식
- 쓰기 전용 캐시(Write-Through Cache): 데이터를 수정하거나 삽입할 때, 캐시와 데이터베이스에 동시에 기록하는 방식 읽기는 캐시에서 빠르게 처리하고, 쓰기는 캐시와 DB에 동시에 처리하여 일관성을 유지 → 쓰기에 반영된 결과에 대해서 바로 읽기 작업이 있을 때 캐시에서 반영하기 위함

## 풀 테이블 스캔(Full Table Scan)이 발생하는 원인은 무엇인가요?**

- 인덱스를 사용하지 못하는 경우
- 키워드가 인덱스를 사용하지 못하는 경우 → LIKE 키워드와 같이 패턴 검색을 진행할 때 인덱스를 사용하지 못함
- 옵티마이저가 인덱스를 사용한 스캔보다 풀 스캔이 효율적인 경우

## SQL 쿼리 최적화 방법에는 어떤 것이 있나요?**

- 불필요한 “SELECT *” 방지
- IN 키워드 대신 EXISTS 키워드 사용
- 조인 최적화 → 조인 시 레코드 수가 적은 테이블을 구동 테이블로 설정
- 불필요한 데이터 개수를 줄이기 위해 LIMIT 키워드 사용

## 조회 성능을 높이기 위한 방법에는 무엇이 있나요?**

## 데이터베이스 성능 모니터링 도구나 기법에 대해 설명해주세요.**
- Zabbix, Datadog, Prometheus
- 데이터베이스 성능 모니티링 시 어떤 것을 모니터링 해야하는가? → CPU 사용량, 메모리 사용량, Disk I/O 등등..
