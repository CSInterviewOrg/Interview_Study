# 데이터베이스 개요

## 데이터베이스란 무엇인가요?

데이터베이스란 데이터를 저장하고 검색하며 수정할 수 있으며 삭제할 수 있는 데이터 관리 시스템입니다.

## RDBMS와 NoSQL의 차이점은 무엇인가요?

- **RDBMS**의 구조는 행과 열입니다. 이 행과 열을 기준으로 데이터가 관리되며 스키마의 형식이 정의되어 있어 정의되어 있는 형식으로 데이터를 관리할 수 있습니다. 또한 트랜잭션의 일관성을 보장하기에 데이터의 무결성 측면에서 장점이 있으며 성능을 향상시킬 때 수직적 확장에 의존합니다.
- **NoSQL**의 구조는 행과 열이 아닌 다양한 형태로 데이터를 관리하는 구조입니다. 스키마가 고정되어 있기에 사전에 정의될 필요 없이 데이터를 관리할 수 있습니다. NoSQL은 가용성과 확장성 측면에 이점이 있기에 트랜잭션 처리에 대해서는 일부적으로 지원합니다. 또한 NoSQL은 수평적 확장이 가능하여 대용량 데이터 처리에 장점이 있습니다.

## SQL이란 무엇이며, SQL의 종류에는 무엇이 있나요?

- SQL은 데이터베이스를 사용하기 위한 프로그래밍 언어입니다. SQL의 종류로는 DDL, DML, DCL, TCL이 존재합니다.
  - **DDL**: 데이터베이스의 구조(테이블, 인덱스 등)를 정의하고 수정
  - **DML**: 데이터베이스에 저장된 데이터를 조회, 삽입, 수정, 삭제
  - **DCL**: 데이터에 대한 액세스를 제어
  - **TCL**: 트랜잭션을 관리하고 데이터의 일관성을 유지하는 데 사용

## 데이터베이스 스키마란 무엇인가요?

관계형 데이터베이스에서 데이터가 저장되는 형식을 말하며 테이블, 열, 데이터 타입, 키, 제약 조건 등등을 이용하여 정의한 구조를 말합니다. 이 스키마를 다양한 관점에서 바라볼 수 있으며 개념 스키마, 논리적 스키마, 물리적 스키마가 있습니다.

- **개념 스키마**: 데이터베이스의 구조를 고수준에서 바라보는 것을 말하며 ERD를 이용해서 표현한 수준의 스키마를 의미합니다.
- **논리적 스키마**: 데이터베이스의 구조를 행과 열, 키, 제약조건 등등을 이용해서 표현한 수준의 스키마를 말하며 데이터베이스와 독립적인 수준의 스키마를 의미합니다.
- **물리적 스키마**: 실제로 데이터가 어떻게 관리되는지를 정의하는 수준의 단계로 DBMS과 하드웨어에 영향을 받는 수준의 스키마를 말합니다.

## 테이블과 뷰(View)의 차이점은 무엇인가요?

- **테이블**은 데이터베이스에 정의된 형식으로 되어 있는 물리적인 저장소를 말합니다. **뷰**는 가상의 테이블로 기존의 테이블과 데이터를 참조하여 생성된 가상의 테이블을 말합니다.
- 테이블은 데이터를 저장, 수정, 삭제가 가능하지만 뷰는 데이터를 조회할 수밖에 없습니다.

## 기본키(Primary Key)와 외래키(Foreign Key)의 차이점은 무엇인가요?

- **기본키**는 각 레코드를 구별하기 위한 컬럼을 말하며 **외래키**는 테이블과 테이블 간의 관계를 설정하기 위한 컬럼을 말합니다. 외래키는 한 테이블에서 다른 테이블의 기본키를 참조하는 컬럼을 말합니다. 외래키는 참조 무결성을 보장하기에 테이블과 다른 테이블 간의 데이터 일관성을 보장합니다.

## ACID란 무엇이며, 각각의 의미를 설명해주세요.

- **ACID**는 트랜잭션의 신뢰성과 무결성을 보장하기 위한 원칙을 말합니다.
  - **원자성(Atomicity)**: 트랜잭션은 전체가 실행되거나, 실패 시 아무것도 실행되지 않음을 보장하는 원칙
  - **일관성(Consistency)**: 트랜잭션 전후에 데이터베이스는 항상 유효한 상태를 보장하는 원칙을 의미
  - **고립성(Isolation)**: 트랜잭션은 다른 트랜잭션의 영향을 받지 않는 원칙
  - **지속성(Durability)**: 트랜잭션이 완료된 후에는 그 결과가 영구적으로 저장되는 원칙

## 트랜잭션이란 무엇인가요?

데이터베이스에서 논리적인 작업의 단위를 의미합니다. 예를 들어서 하나의 쿼리를 실행하는 것이 하나의 트랜잭션이 될 수도 있으며 여러 개의 쿼리가 하나의 트랜잭션이 될 수도 있습니다.

## 데이터베이스의 정규화(Normalization)란 무엇이며, 그 목적은 무엇인가요?

테이블 내에서 중복된 데이터를 제거하여 데이터 일관성을 유지하기 위해 테이블의 구조를 개선해 나가는 과정입니다. 결과적으로 중복된 데이터를 제거하기에 데이터베이스 서버의 불필요한 디스크 및 메모리 낭비를 방지할 수 있으며 데이터의 신뢰성 측면에 향상을 위하기에 정규화를 진행합니다.

- **1차 정규화**: 각 컬럼이 하나의 값을 가질 수 있도록 정규화하는 과정입니다.
- **2차 정규화**: 기본키가 아닌 모든 컬럼이 기본키의 일부에 종속되지 않도록 정규화하는 과정입니다.
- **3차 정규화**: 기본키가 아닌 모든 컬럼이 기본키에 종속되지 않도록 정규화하는 과정입니다.

## 역정규화(Denormalization)란 무엇이며, 언제 사용하나요?

역정규화는 정규화의 과정을 반대로 진행하는 과정으로 정규화를 통해 분리된 테이블을 다시 합치는 과정을 의미합니다. 데이터의 중복과 신뢰성이 떨어지는 대신에 테이블 간의 복잡한 조인 연산을 줄여 읽기 성능을 향상시키기 위해 진행합니다.

## INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN의 차이점은 무엇인가요?

- **INNER JOIN**: 두 테이블의 공통적인 데이터들에 대해서만 결합합니다.
- **LEFT JOIN**: 왼쪽 테이블의 모든 데이터와 조인 조건을 만족하는 오른쪽 테이블의 데이터에 대해서만 결합합니다. 오른쪽 테이블에 매칭되는 행이 없는 값에 대해서는 NULL로 데이터가 채워집니다.
- **RIGHT JOIN**: 오른쪽 테이블의 모든 데이터와 조인 조건을 만족하는 왼쪽 테이블의 데이터에 대해서만 결합합니다. 왼쪽 테이블에 매칭되는 행이 없는 값에 대해서는 NULL로 데이터가 채워집니다.
- **FULL JOIN**: 양쪽 테이블의 모든 행을 반환합니다. 조인 조건이 만족되는 행에 대하여 조인 테이블에 데이터가 없는 경우 NULL로 데이터가 채워집니다.

## GROUP BY와 HAVING의 차이점은 무엇인가요?

**GROUP BY**는 특정 조건에 한하여 데이터를 그룹화 하는 것을 말하며 **HAVING**은 그룹화 된 데이터에 대해서 특정 조건으로 필터링하는 것을 말합니다.

## WHERE와 HAVING의 차이점은 무엇인가요?

**WHERE** 절은 테이블의 개별 행에 대해서 필터링을 하는 것이며 **HAVING**은 **GROUP BY** 절에 의해 그룹화 된 개별 행에 대해서 필터링을 하는 것입니다.

## DISTINCT 키워드는 무엇을 하는가요?

중복된 데이터를 제거하는 키워드입니다.
- **DISTINCT**는 결과 값에 대해서 다시 한번 풀 스캔을 하여 중복된 데이터를 제거하기기에 레코드 수가 많을 경우 쿼리 성능에 안 좋을 수 있습니다.

## 서브쿼리란 무엇이며, 서브쿼리의 종류에는 무엇이 있나요?

서브쿼리는 쿼리 내에서 또 다른 쿼리를 중첩해서 사용하는 쿼리 형식을 말합니다.

- **스칼라 서브쿼리**: 단일 값을 반환하는 서브 쿼리
- **행 서브쿼리**: 하나의 행을 반환하는 서브 쿼리
- **테이블 서브쿼리**: 결과 값을 임시 테이블 형태로 반환하는 서브쿼리
- **상관 서브쿼리**: 서브 쿼리가 메인 쿼리에 의존하는 형태의 서브쿼리
- **비상관 서브쿼리**: 서브 쿼리가 메인 쿼리와 독립적인 형태의 서브쿼리

## UNION과 UNION ALL의 차이점은 무엇인가요?

- **UNION**: 두 개 이상의 쿼리를 조합할 때 중복된 결과 값을 제거하는 쿼리
- **UNION ALL**: 두 개 이상의 쿼리를 조합할 때 중복된 결과 값을 포함하는 쿼리

## EXISTS와 IN의 차이점은 무엇인가요?

- **EXISTS**: 특정 조건을 만족하는 데이터가 존재하는지만 확인하는 것으로 데이터의 실제 값을 비교하지 않습니다.
- **IN**: 특정 조건을 만족하는 데이터가 존재하며 데이터의 실제 값을 비교하기에 단순하게 데이터를 확인하는 경우 **EXISTS** 키워드보다 성능이 좋지 않습니다.

## COUNT, SUM, AVG, MIN, MAX 같은 집계 함수에 대해 설명해주세요.

- **COUNT**: 데이터 집합 내의 행 수를 반환합니다.
- **SUM**: 데이터 집합 내의 값을 합산하여 반환합니다.
- **AVG**: 데이터 집합 내의 값의 평균을 반환합니다.
- **MIN**: 데이터 집합 내의 최소값을 반환합니다.
- **MAX**: 데이터 집합 내의 최대값을 반환합니다.

## 데이터베이스에서 뷰(View)란 무엇이며, 장단점은 무엇인가요?

- **뷰**란 실제 데이터를 특정 조건에 한하여 필터링 된 레코드들에 대해서 구성된 임시 테이블을 말합니다.
  - **장점**: 필터링된 레코드들이 저장되어 있기에 결과 값들을 재사용할 수 있다는 장점이 있습니다.
  - **단점**: 뷰는 동적으로 SELECT한 데이터를 사용하기에 뷰를 호출할 때마다 계속해서 SELECT가 되기에 성능 측면에서 단점이 있습니다.

## CASE문을 사용하여 조건부로 데이터를 조회하는 방법을 설명해주세요.
- **단순 CASE 문**: 특정 값이 주어진 조건과 일치할 때 결과를 반환하는 방식
```sql
SELECT EmployeeID, Name,
       CASE DepartmentID
           WHEN 1 THEN 'Sales'
           WHEN 2 THEN 'Marketing'
           WHEN 3 THEN 'Engineering'
           ELSE 'Other'
       END AS DepartmentName
FROM Employees;
```

- **검색 CASE 문**: 특정 조건이 주어진 조건과 일치할 때 결과를 반환하는 방식
```sql
SELECT EmployeeID, Name, Salary,
       CASE
           WHEN Salary < 30000 THEN 'Low'
           WHEN Salary BETWEEN 30000 AND 70000 THEN 'Medium'
           WHEN Salary > 70000 THEN 'High'
           ELSE 'Unknown'
       END AS SalaryCategory
FROM Employees;
```

# 데이터베이스 인덱스 및 트랜잭션

## 인덱스란 무엇인가요?

- **데이터베이스에서 데이터 조회 성능을 향상시키기 위한 구조**
- **인덱스를 통해 테이블의 레코드에 접근하기에 보다 빠른 조회 가능**
- **인덱스 데이터를 저장하기 위한 별도의 데이터 공간(디스크 공간)이 필요**
- **레코드를 INSERT, UPDATE, DELETE 할 때 인덱스 컬럼도 같이 진행해야 하기에 해당 기능들에 대해서는 성능 저하 발생**
  - 조회 성능과 수정 기능은 반비례 관계

## 클러스터드 인덱스(Clustered Index)와 넌클러스터드 인덱스(Non-clustered Index)의 차이점은 무엇인가요?

- **레코드가 저장될 때 어떻게 저장되는지가 다릅니다.**

### 클러스터드 인덱스
- **테이블의 실제 데이터가 인덱스에 의해 정렬된 상태로 저장**
- **테이블의 행 자체가 클러스터드 인덱스의 순서에 따라 디스크에 물리적으로 배치**
- **하나의 정렬된 기준으로 데이터가 저장되기에 테이블에 클러스터드 인덱스는 한 개**
  - **일반적으로 테이블의 클러스터드 인덱스는 기본키로 설정**

### 넌클러스터드 인덱스
- **테이블의 실제 데이터와는 별도로 인덱스 자체에 대한 정보만 정렬**
- **이를 통해서 테이블의 실제 레코드에 대한 참조 값을 인덱스가 가지고 있는 상태**
- **검색 성능은 클러스터드 인덱스가 더 좋음**

## 인덱스를 언제 사용하는 것이 적합한가요?

- **INSERT, UPDATE, DELETE 키워드를 잘 사용하지 않고 SELECT 키워드를 많이 사용하는 컬럼에 대해서 사용**

## 인덱스 사용이 성능에 미치는 영향은 무엇인가요?

- **인덱스를 통한 데이터 접근으로 데이터 조회 성능 향상**
- **이미 정렬되어 있는 인덱스를 통한 데이터 정렬 성능 향상**
- **조인 과정 시 인덱스를 통한 조인 성능 향상**
- **데이터 변경 시 이미 정렬되어 있는 인덱스를 다시 한번 정렬 하기에 쓰기, 수정, 삭제 기능 저하**
- **인덱스에 대한 별도의 데이터 저장 공간이 필요하기에 디스크 사용 공간 증가**

## 인덱스의 구조는 무엇인가요?

### B-Tree 인덱스 구조
- **인덱스가 균형 잡힌 트리 구조를 가지고 있는 형태**
- **각 노드는 자신이 가질 수 있는 최소, 최대 자식 노드 개수가 있으며 트리의 높이를 최대한 낮게 유지하도록 균형을 이룸**
- **각 노드 key:value 형태로 이루어져 있으며 key 값은 인덱스에 대한 ID 값, value는 실제 레코드에 대한 주소 값을 가지고 있는 형태**
- **루트 노드에서 자식 노드로 특정 키 값을 탐색하는 과정으로 동작**

### B+Tree 인덱스 구조
- **리프 노드에만 실제 데이터 주소 값을 가지며 각 리프 노드는 연결 리스트 형태로 이루어져 있는 인덱스 구조**
- **B-Tree 인덱스 구조의 경우 리프 노드 이전에 데이터를 탐색할 수 있기에 특정 케이스에 대해 B-Tree 인덱스 구조가 더 빠를 수 있음**
- **하지만 리프 노드에만 실제 데이터가 있기에 검색 속도가 균일하고 연결 리스트로 되어 있기에 범위 탐색에 보다 효과적임**

### 해시 테이블 구조
- **key:value 형태의 인덱스 구조**
- **각 키에 접근할 때 시간 복잡도가 O(1)이지만 범위 검색을 진행할 경우 인덱스가 순서대로 저장되어 있지 않기에 범위 탐색 시 모든 버킷에 대해서 전체 탐색을 진행해야 함**

## 인덱스를 너무 많이 만들면 성능에 어떤 영향이 있나요?

- **인덱스도 결국에는 스캔 과정이 필요하기에 인덱스가 너무 많은 경우 인덱스 스캔 자체의 성능이 떨어짐**
- **인덱스도 결국에는 디스크와 같은 저장공간이 필요하기에 저장 공간이 너무 많아지면 디스크 I/O가 많아지고 이에 따라서 디스크에서 메모리로 불러오는 과정이 느려짐 → 이에 따라 쿼리 성능 자체에 영향을 줌**

## Composite Index(복합 인덱스)란 무엇인가요?

- **두 개 이상의 컬럼에 대해서 하나의 인덱스로 설정하는 것**
- **column1과 column2에 대해서 단일 인덱스로 설정 후 해당 컬럼에 대해 조건을 같이 사용하면 두 컬럼에 대해서 각각 독립적으로 탐색한 후 탐색 결과를 연산해야 함 → 복합 인덱스 사용 시 두 조건을 동시에 만족하는 인덱스를 통해 탐색**
- **실제 동작 과정은 첫 번째 인덱스를 사용한 후 두 번째 인덱스를 사용하기에 첫 번째 인덱스를 통해 탐색 범위를 줄이는 것이 중요함**

## 인덱스 설계 시 주의해야 할 점은 무엇인가요?

- **카디널리티가 높은 컬럼에 대해서 인덱스를 설계하는 것이 중요 → 인덱스가 실제 레코드를 참조하는 탐색 범위를 줄일 수 있기 때문**

## 데이터베이스에서 인덱스의 재구성(Rebuild)과 재구성하지 않음(Reorganize)은 무엇이 다른가요?

- **인덱스는 페이지로 이루어짐 → 페이지는 루트 페이지(Tree 구조에서 노드의 시작점), 내부 페이지(자식 페이지에 대한 위치 값을 가지는 페이지), 자식 페이지(실제 데이터에 대한 위치 값을 가지는 페이지)로 구성**
- **내부 페이지와 자식 페이지는 2개 이상이며 데이터가 새로 생기거나 삭제될 때 균형을 이뤘던 페이지가 불균형을 이루게 되며 페이지에서 빈 공간이 생기게 됨 → 이러한 현상을 조각화라고 표현하며 이는 조회 성능에 영향을 줌**

### 인덱스 재구성 (Rebuild)
- **기존 인덱스를 삭제하고 새로운 인덱스를 설정으로 조각화를 제거하는 방법**
- **인덱스를 삭제하고 새로 생성하기에 시간 소요가 큼**

### 인덱스 재구성하지 않음 (Reorganize)
- **기존 인덱스의 페이지를 재정렬하는 방식으로 조각화를 줄이는 방법**
- **정렬하는 방식이기에 페이지의 빈 공간에 대해서 최적화를 이루는 것 뿐이여서 제한적인 조각화 해결 가능**

## 인덱스 힌트(Index Hint)란 무엇이며, 언제 사용하나요?

- **인덱스 힌트: SQL 쿼리 실행 시 특정 인덱스를 사용하도록 명시적으로 사용하도록 하는 방법**
- **옵티마이저가 자동 선택한 인덱스가 비효율적이거나 특정 인덱스의 성능 테스트를 하기 위해 사용**

## 트랜잭션의 고립 수준(Isolation Level)에 대해 설명해주세요.

1. **Read Uncommitted**
   - **다른 트랜잭션이 커밋하지 않은 데이터에 대해서 읽기 가능한 수준**
   - **커밋을 보장하지 않기에 읽었던 데이터가 롤백 되는 경우에 대한 잘못된 데이터를 읽을 수 있음**

2. **Read Committed**
   - **다른 트랜잭션이 커밋한 데이터에 대해서 읽기 가능한 수준**
   - **트랜잭션 T1이 두 번의 SELECT를 진행한다고 했을 때 트랜잭션 T2가 T1 첫 번째 이후 값을 변경하면 트랜잭션 T1에서 첫 번째와 두 번째 SELECT 결과 값이 달라짐**

3. **Repeatable Read**
   - **트랜잭션이 시작 될 때와 끝날 때 읽은 데이터의 값이 동일함을 보장하는 수준**
   - **트랜잭션이 진행될 때 해당 트랜잭션이 끝나는 동안 다른 트랜잭션이 자신이 사용하고 있는 데이터에 대해서 변경을 못하게 막음**
   - **대신에 새로운 레코드를 추가하거나 삭제는 가능**

4. **Serializable**
   - **모든 트랜잭션이 모두 독립적인 수준으로 진행됨을 보장하는 수준**
   - **트랜잭션들을 처리할 때 모든 트랜잭션에 순서성을 부여해서 독립적으로 처리하도록 함**
   - **동시에 트랜잭션을 처리할 경우 경쟁 상태에 빠질 수 있음**

## Dirty Read, Non-repeatable Read, Phantom Read에 대해 설명해주세요.

- **Dirty Read:** Read Uncommitted 격리 수준에서 발생하며 커밋 되지 않고 롤백된 데이터를 읽는 현상
- **Non-repeatable Read:** Read Uncommitted, Read Committed 격리 수준에서 발생하며 동일 트랜잭션에서 데이터를 읽을 때 값이 달라지는 현상
- **Phantom Read:** Read Uncommitted, Read Committed, Repeatable Read에서 발생하며 같은 트랜잭션으로 처리될 때 레코드의 개수가 달라지는 현상

## 낙관적 잠금(Optimistic Locking)과 비관적 잠금(Pessimistic Locking)의 차이점은 무엇인가요?

- **낙관적 잠금(Optimistic Locking):** 트랜잭션의 커밋 시점에 기존에 데이터 값과 변경이 되면 해당 트랜잭션을 재시도 하거나 롤백하는 방식 → 실제로 락을 걸지는 않음
- **비관적 잠금(Pessimistic Locking):** 트랜잭션이 접근하는 시점에 무조건적으로 락을 걸어 다른 트랜잭션이 접근하는 것을 막는 방식

## 트랜잭션에서 발생할 수 있는 동시성 문제에는 어떤 것들이 있나요?

- **Dirty Read**
- **Non-repeatable Read**
- **Phantom Read**

## Deadlock이란 무엇이며, 이를 방지하는 방법은 무엇인가요?

- **Deadlock:** 각각 자원을 가지고 있는 트랜잭션들이 동시에 다른 트랜잭션에 접근할 때 모두가 대기 상태에 빠지는 것
- **해결 방법:** 데드락에 빠진 트랜잭션 중 하나의 트랜잭션에 대해서 롤백을 처리하여 나머지 트랜잭션이 대기 상태에서 벗어나게 하는 방법, 테이블 단위의 락에서 레코드 단위의 락으로 락의 빈도수를 줄이는 방법 등

## 트랜잭션 로그(Transaction Log)란 무엇인가요?

- **데이터베이스 시스템에서 트랜잭션의 모든 변경 사항과 작업을 기록하는 로그**

## 데이터베이스 커밋과 롤백의 차이점은 무엇인가요?

- **커밋:** 트랜잭션이 성공적으로 처리 되어 결과 값을 데이터베이스에 영구적으로 반영하는 것
- **롤백:** 트랜잭션 과정 중 실패하여 트랜잭션이 시작되기 이전의 데이터베이스 상태로 돌아가는 것

## 트랜잭션 타임아웃이란 무엇인가요?

- **트랜잭션을 처리할 때 최대 시간을 의미, 해당 시간이 넘어가면 롤백 처리 됨**

## 쿼리 튜닝(Query Tuning)이란 무엇인가요?
- SQL 쿼리의 실행 시간을 줄이고 CPU, 메모리, I/O와 같은 시스템 리소스를 최소한으로 사용하도록 쿼리를 개선하는 것
- 쿼리 튜닝 과정은 자주 사용되는 WHERE 절의 컬럼에 대해서 인덱스 또는 복합 인덱스로 설정, JOIN 시 인덱스 설정을 하거나 비효율적인 서브쿼리를 JOIN으로 바꿔서 진행

## 쿼리 실행 계획(Execution Plan)이란 무엇이며, 이를 분석하는 방법을 설명해주세요.
- 쿼리 실행 계획이란 데이터베이스 옵티마이저가 쿼리를 실행하기 전에 최적의 실행 경로를 결정하고, 그 경로가 데이터베이스에서 어떻게 동작하는지, 어디에서 성능 병목 현상이 발생하는지를 분석하는 것
- **id: 실행 순서를 표시하는 숫자**
- **select_type:** SQL문을 구성하는 SELECT 문의 유형을 출력하는 항목
    - SIMPLE: UNION, 내부 쿼리가 없는 SELECT 문
    - PRIMARY: 서브쿼리를 감싸는 외부 쿼리이거나 UNION이 포함된 SQL 문의 첫 번째 SELECT
    - SUBQUERY: 독립적으로 수행되는 서브쿼리
    - DERIVED: 서브쿼리 또는 뷰에서 유도된 테이블.
- table: 해당 단계에서 접근하는 **테이블의 이름**
- partitions: 쿼리에 사용된 파티션 정보
- type: join 타입
    - **system**: 테이블에 하나의 행만 있는 경우.
    - **const**: 인덱스의 유일한 값을 사용하여 해당 테이블을 한 번만 읽는 경우.
    - **eq_ref**: 주로 **primary key** 또는 **unique key**와 조인할 때 발생.
    - **ref**: 인덱스를 통해 테이블을 참조하는 조인.
    - **range**: **범위 검색**을 할 때, 예를 들어 `BETWEEN`, `>`, `<` 등을 사용한 경우.
    - **index**: **인덱스 스캔**을 의미하며, 인덱스 전체를 읽음
    - **ALL**: **전체 테이블 스캔**으로, 성능이 가장 낮은 방식입니다. 이 경우 쿼리 튜닝이 필요
- possible_keys: 쿼리에서 사용할 수 있는 **인덱스 목록**
- key: 실제로 사용된 인덱스
- key_len: 인덱스를 사용한 키의 길이
- ref: 인덱스와 비교된 컬럼
- rows: 예상 처리 row의 개수
- filtered: 조건에 따라 필터링 된 행의 비율로 100%에 가까울수록 좋음
- Extra: 추가 정보
    - **Using index**: **커버링 인덱스**가 사용되었다는 의미로 테이블을 사용하지 않고 인덱스만 사용함 → 좋음
    - **Using where**: **WHERE 조건**이 적용
    - **Using temporary**: 임시 테이블이 사용
    - **Using filesort**: **파일 정렬**이 사용 → 좋지 못함

## 인덱스 스캔(Index Scan)과 테이블 스캔(Table Scan)의 차이점은 무엇인가요?

- 인덱스 스캔: 검색 시 인덱스를 사용한 스캔으로 인덱스를 적용한 컬럼을 사용할 때 사용 됨, 사용 됐다라는 의미는 WHERE, JOIN 등등 키워드에 인덱스 사용을 의미
- 테이블 스캔: 검색 시 인덱스를 사용하지 않고 테이블의 모든 레코드에 대해서 순차적으로 하나씩 스캔, 인덱스를 전혀 사용하지 않았기에 조회 성능이 느림 ↔ 반대로 테이블의 레코드가 너무 적을 경우에는 테이블 스캔이 인덱스 스캔보다 효율적일 수 있음

## 데이터베이스에서 Partitioning이란 무엇인가요?**

- 레코드나 인덱스가 너무 많은 하나의 테이블을 여러 개의 테이블로 쪼개는 것을 의미 → 쿼리 성능 향상
- 반대로 파티셔닝을 진행하면 테이블이 쪼개지기에 테이블간의 조인이 발생하면 오히려 쿼리 성능이 안좋아질 수 있음 → 조인이 잘 안되지 않는 선에서 파티셔닝을 처리해야 함
- Range Partitioning (범위 파티셔닝): 데이터를 특정 범위로 파티셔닝 하는 방법, ex) 기간
- List Partitioning (리스트 파티셔닝): 데이터를 특정 타입을 기준으로 파티셔닝 하는 방법, ex) 결제 유형
- Hash Partitioning (해시 파티셔닝): 데이터의 특정 값을 해싱 값을 기준으로 파티셔닝 하는 방법
- Key Partitioning (키 파티셔닝): 기본키 또는 특정 키 값을 기준으로 파티셔닝 하는 방법

## Sharding이란 무엇이며, 언제 사용하나요?**

- 하나의 데이터베이스에 저장되어 있는 데이터를 여러 개의 데이터베이스 서버로 분할하는 방법 → 스케일 아웃 방식 → 이 때 각 샤딩된 데이터베이스 서버를 샤드라고 표현
- 샤딩된 각 테이터베이스의 테이블 구조는 동일하지만 저장 되어 있는 데이터가 서로 다름
- 범위 기반 샤딩: 데이터를 범위 기반으로 샤딩하는 방법, ex) 기간
- 해시 기반 샤딩: 특정 컬럼에 대한 데이터에 대해서 해싱 처리를 한 값을 기준으로 샤딩하는 방법
- 키-값 기반 샤딩: 기본 키 혹은 특정 키(컬럼)을 기준으로 샤딩하는 방법
- 분할된 샤드에서 데이터를 찾는 방법: 샤딩 전략에 따른 샤딩 키 값을 기준으로 샤드를 찾음, ex) 샤딩 전략이 해시 기반일 경우 요청 데이터에 대해서 해싱 처리한 값으로 샤드를 찾는 방법, 또는 Application에서 샤딩 키 값을 가지는 비즈니스 로직을 이용해서 샤드에 접근

## 데이터베이스의 캐싱 전략에는 어떤 것들이 있나요?**

- 쿼리 결과 캐싱 (Query Result Caching): 특정 쿼리의 결과를 캐시에 저장하여 동일한 쿼리가 들어왔을 때 데이터베이스에 다시 요청하지 않고, 캐시에 저장된 결과를 반환하는 방법
- 페이지 캐싱 (Page Caching): 데이터베이스 페이지(일정 크기의 데이터 블록)를 캐시에 저장한 후 해당 페이지에 대한 요청이 들어오면 캐시에서 제공하는 방식
- **객체 캐싱 (Object Caching): 이터베이스에서 읽은 개별 객체나 레코드를 캐시에 저장하는 방식. 자주 조회되는 특정 객체(예: 사용자 프로필, 상품 정보)를 캐시에 저장해, 이후에는 데이터베이스를 조회하지 않고 캐시에서 데이터를 반환하는 방식**
- 읽기 전용 캐시(Read-Through Cache): 데이터베이스에서 데이터를 가져오지 않고, 캐시에서 직접 데이터를 읽는 방식. 캐시에 데이터가 없으면 데이터베이스에서 읽어와 캐시에 저장하고, 이후 캐시에서 응답하는 방식
- 쓰기 전용 캐시(Write-Through Cache): 데이터를 수정하거나 삽입할 때, 캐시와 데이터베이스에 동시에 기록하는 방식 읽기는 캐시에서 빠르게 처리하고, 쓰기는 캐시와 DB에 동시에 처리하여 일관성을 유지 → 쓰기에 반영된 결과에 대해서 바로 읽기 작업이 있을 때 캐시에서 반영하기 위함

## 풀 테이블 스캔(Full Table Scan)이 발생하는 원인은 무엇인가요?**

- 인덱스를 사용하지 못하는 경우
- 키워드가 인덱스를 사용하지 못하는 경우 → LIKE 키워드와 같이 패턴 검색을 진행할 때 인덱스를 사용하지 못함
- 옵티마이저가 인덱스를 사용한 스캔보다 풀 스캔이 효율적인 경우

## SQL 쿼리 최적화 방법에는 어떤 것이 있나요?**

- 불필요한 “SELECT *” 방지
- IN 키워드 대신 EXISTS 키워드 사용
- 조인 최적화 → 조인 시 레코드 수가 적은 테이블을 구동 테이블로 설정
- 불필요한 데이터 개수를 줄이기 위해 LIMIT 키워드 사용

## 조회 성능을 높이기 위한 방법에는 무엇이 있나요?**

## 데이터베이스 성능 모니터링 도구나 기법에 대해 설명해주세요.**
- Zabbix, Datadog, Prometheus
- 데이터베이스 성능 모니티링 시 어떤 것을 모니터링 해야하는가? → CPU 사용량, 메모리 사용량, Disk I/O 등등..

## 엔터티(Entity)와 어트리뷰트(Attribute)란 무엇인가요?**
- 엔티티: 데이터베이스에서 관리하는 개체나 객체를 의미
    - 엔티티 특징
        - 각 엔티티는 독립적으로 존재해야 함
        - 각 엔티티는 고유하게 식별되어야 하며 주 식별자를 통해서 식별됨
        - 엔티티는 다른 엔티티와 최소 한개 이상의 관계를 가져야 함
    - 엔티티 분류
        - 개념 엔티티: 물리적 형태를 지니지 않는 개념적 엔티티. ex) 수업, 조직, 계약 ..
        - 유형 엔티티: 물리적 형태를 지닌 엔티티. ex) 사원, 학생, 물품 ..
        - 사건 엔티티: 업무를 수행하면서 발생하는 이벤트성 엔티티. ex) 주문, 청구 ..
- 어트리뷰트(속성): 엔티티가 가진 특징이나 속성을 의미
    - 어트리뷰트의 특징
        - 어트리뷰트는 더이상 쪼개지지 않는 단위를 가져야 함
        - 하나의 속성은 하나의 값만을 가져야 함 → 하나의 레코드에 전화번호라는 컬럼이 있는 경우 “010-1234-5678”, “010-5678-1234”와 같이 두개의 값이 있으면 안됨
    - 어트리뷰트 분류
        - 기본 속성: 업무로부터 추출한 모든 속성으로 가장 일반적인 속성
        - 설계 속성: 업무상 필요한 데이터 이외의 데이터 모델링을 위해 새로 정의한 속성
        - 파생 속성: 다른 속성에 의해 영향을 받아 생성된 속생
- 학생이라는 엔티티에 나이, 성별.. 과 같은 어트리뷰트가 존재하는 형태

## ERD(Entity-Relationship Diagram)란 무엇인가요?**

- ERD란 엔티티간의 관계를 시각적으로 표현한 다이어그램입니다.
- ERD는 엔티티, 어트리뷰트, 관계로 이루어져 있으며 관계는 카디널리티에 따라서 표현됩니다.
    - 여기서 엔티티간의 카디널리티와 레코드간의 카디널리티는 서로 다른 맥락으로 쓰입니다. 엔티티간의 카디널리티는 하나의 엔티티가 다른 엔티티와 얼마나 많은 관계를 맺을 수 있는지를 의미합니다.

## 1:1, 1:N, N:M 관계를 설명해주세요.**
- 1:1 관계: 하나의 엔티티의 인스턴스가 다른 엔티티의 인스턴스와 하나의 관계만 성립될 때. ex) 사람과 주민등록번호는 1대1 관계
- 1:N 관계: 하나의 엔티티의 인스턴스가 다른 엔티티의 여러 인스턴스와 관계가 성립될 때. ex) 교수(1)와 강좌(N은 1대 N 관계
- N:M 관계: 각각의 엔티티의 인스턴스가 상대 엔티티의 여러 인스턴스와 관계가 성립될 때. ex) 학생(N)과 강좌(M) 관계
- 여기서 의미하는 인스턴스란 엔티티에 해당되는 하나의 레코드를 의미함

## 테이블 간의 관계를 모델링할 때 주의해야 할 점은 무엇인가요?**
- 데이터 무결성 유지: 외래키를 이용하여 참조 무결성을 유지, 제약 조건을 설정하여 데이터 변경에 따른 무결성 유지
- 올바른 관계 정의: 두 엔티티간의 관계를 분석한 후 1:1, 1:N, M:N 관계 정의
- 중복 데이터 방지: 정규화를 이용하여 중복 데이터 제거

## 데이터베이스의 차수(Degree)와 카디널리티(Cardinality)에 대해 설명해주세요.**
- 차수: 데이터베이스의 테이블에서 컬럼의 개수를 의미
- 카디널리티
    - 테이블 카디널리티: 테이블의 전체 레코드 수를 의미
    - 컬럼 카디널리티: 특정 컬럼이 존재하는 레코드의 개수 중 컬럼 기준으로 중복되지 않은 레코드의 개수

## 데이터 무결성이란 무엇이며, 무결성을 유지하는 방법은 무엇인가요?**
- 데이터 무결성이란 데이터의 신뢰성을 보장하는 특성으로 데이터가 일관적으로 유지되는 특성을 말합니다.
- 무결성 유형
    - 참조 무결성: 데이터베이스 내의 테이블간의 관계가 옳바르게 유지되는 특성으로 외래키가 유효한 참조를 하며 참조된 레코드가 변경되거나 삭제될 때 일관성을 유지하는 특성
    - 논리적 무결성: 데이터가 논리적으로 일관성을 유지하는 방법으로 데이터의 타입, 범위 등등이 옳바르게 정의되고 유지되는 특성
    - 도메인 무결성: 데이터에 정의된 형식이 도메인 내에 있어야 하는 특성으로 나이가 음수일 수 없는 특성과 같은 것을 말합니다.
    - 행 무결성: 각 행이 유일해야 함을 보장하는 특성으로 주로 기본키를 통해 특성이 보장됩니다.
    - 물리적 무결성: 데이터가 손상되지 않은 채로 유지되는 특성으로 주로 하드웨어에 따라 보장됩니다.
- 무결성 유지 방법
    - 기본 키 제약 조건: 기본 키를 통해 각 행이 유일함을 식별하고 보장합니다.
    - 외래 키 제약 조건: 외래 키를 통해 테이블간의 참조 무결성을 보장합니다.
    - 유일 제약 조건: 특정 컬럼의 값이 중복되지 않도록 합니다.
    - 체크 제약 조건: 데이터가 특정 조건을 만족하도록 합니다.

## ORM(Object-Relational Mapping)이란 무엇인가요?**
- ORM이란 객체 지향 프로그래밍에서의 객체와 관계형 데이터베이스를 매핑해주는 기술입니다.
- ORM을 통해 Mapping 되는 것은 아래와 같습니다.
    - 객체와 테이블 매핑
    - 자동 쿼리 생성
    - 데이터베이스 추상화
    - 객체의 영속성 관리

## 데이터베이스의 외래키 제약조건(Cascade Delete, Cascade Update)이란 무엇인가요?**
- 두 키워드는 외래 키가 걸려있는 부모 테이블의 레코드가 삭제될 때 자식 테이블의 레코드를 어떻게 처리할지에 대한 외래 키 제약조건 옵션입니다.
- Cascade Delete: 부모 테이블의 레코드가 삭제될 때 이에 연관된 자식 테이블의 레코드도 삭제되는 제약 조건
- Cascade Update: 부모 테이블의 데이터가 변경될 때 이에 연관된 자식 테이블의 데이터도 변경하는 제약 조건

## NoSQL의 데이터 모델링 전략은 RDBMS와 어떻게 다른가요?**
- 문서 기반(Document-oriented) 데이터베이스: 관련된 row를 하나의 Document에 포함시키게 하여 JOIN 연산이 없도록 모델링을 합니다.
- 그래프 기반(Graph-based) 데이터베이스: 각 노드간의 관계 중심으로 모델링을 합니다.
- 키-값 저장소(Key-Value Store) 데이터베이스: 고유한 key 값에 따른 value 형태를 1:1 구조로 모델링 합니다.

## 데이터베이스의 물리적 설계와 논리적 설계의 차이점은 무엇인가요?**
- 논리적 설계: 데이터베이스의 개념적 구조를 설계하는 것으로 엔티티간의 관계, 데이터에 따른 유형 혹은 범위, 제약 조건들을 설계하는 단계입니다. 엔티티와 속성 그리고 관계를 정의하는 것에 포커스를 두며 ERD를 이용합니다.
- 물리적 설계: 데이터베이스에 따라 물리적으로 데이터가 어떻게 저장 될지를 설계하는 것을 말합니다. 특정 데이터베이스의 성능, 인덱스, 파티셔닝 등등에 포커스를 둡니다.

## 데이터베이스의 복제(Replication)란 무엇이며, 어떤 종류가 있나요?**
- 데이터베이스 복제란 데이터를 여러 데이터베이스의 인스턴스에 복제하는 것을 말합니다. 레플리케이션을 이용하면 성능 향상과 장애 복구와 같은 기능들을 사용할 수 있습니다.
- Replication 유형
    - 마스터-슬레이브 Replication: 하나의 마스터 노드가 쓰기 작업을 진행하며 여러 슬레이브 노드가 읽기 작업을 진행하는 복제 유형, 마스터 노드에서 슬레이브 노드로 동기화 진행
        - 비동기 복제 방식: 마스터 노드가 슬레이브 노드로 데이터를 동기화 할 때 주기적으로 진행하며 마스터 노드가 동기화 처리를 할 때 마스터 노드의 쓰기 작업에는 영향이 덜함
        - 동기 복제 방식: 마스터 노드가 슬레이브 노드로 데이터를 동기화 할 때 쓰기 작업이 끝나면 바로 진행하는 방식으로 동기화 작업에 따라 쓰기 작업이 영향을 받음(쓰기 → 동기화 → 동기화 완료 → 다음 쓰기 진행)
    - 마스터-마스터 Replication: 두 개 이상의 노드가 쓰기 작업과 읽기 작업을 진행하며 각 노드는 서로 동기화를 진행하는 복제 유형 → 데이터 충돌이 발생할 수 있음

## 데이터베이스 페일오버(Failover)란 무엇인가요?**
- 데이터베이스 페일오버: 데이터베이스 서버에서 장애가 났을 때 자동 또는 수동으로 백업 서버로 전환하는 과정을 말함 → 자동으로 전환 시 자동 페일오버, 관리자가 수동으로 전환 시 수동 페일오버
- 장애가 발생해도 서비스가 정상적으로 진행되기 위함

## 데이터 웨어하우스와 데이터 마트의 차이점은 무엇인가요?**
- 데이터 웨어하우스: 데이터 웨어하우스는 전체 조직의 데이터 통합 및 분석을 위한 중앙 저장소입니다. 실시간서으로 데이터가 업데이트 되지 않고 특정 주기에 따라 데이터 업데이트를 진행합니다.(전체 데이터 동기화를 위해)
- 데이터 마트: 데이터 마트는 특정 부서, 팀, 또는 비즈니스 기능을 위한 데이터 저장소입니다. 특정 비즈니스에 따라 분할된 데이터가가 저장됩니다.

## OLTP와 OLAP의 차이점은 무엇인가요?**
- OLTP (Online Transaction Processing): 주로 비즈니스 운영과 관련된 실시간 데이터 처리와 트랜잭션 관리를 목적을 위한 데이터 시스템입니다. 높은 일관성을 유지하며 짧은 트랜잭션을 처리하는 것에 적합한 시스템입니다.
- OLAP (Online Analytical Processing): 데이터 분석과 의사 결정 지원에 초점을 맞춘 데이터 시스템입니다. 대용량 데이터를 주로 처리하며 트랜잭션 관리와 데이터 일관성 유지보다는 대량 데이터 분석, 데이터 집계에 초점을 둔 시스템입니다.

## 데이터베이스에서 백업과 복구 전략에는 어떤 것들이 있나요?**
- 데이터베이스 백업 전략
    - 전체 백업: 데이터베이스의 모든 데이터에 대해서 사본을 만드는 것으로 처리 과정이 느립니다.
    - 차등 백업: 지막 전체 백업 이후 변경된 데이터만을 백업하는 방법으로 효율적으로 백업을 처리할 수 있습니다.
    - 인크리멘탈 백업: 전체 백업 또는 차등 백업 이후 변경된 데이터만을 백업하는 방법입니다.
    - 로그 백업: 데이터베이스 트랜잭션에 대해서 사본을 만드는 것으로 특정 시점의 데이터베이스로 돌아가기 위한 백업입니다.
- 복구 전략
    - 기본 복구: 데이터베이스의 가장 최근 백업 상태로 복구하는 방식으로 전체 백업만을 이용합니다.
    - 완전 복구: 데이터베이스의 최신 상태로 복구하는 방법입니다. 전체 백업, 차등 백업, 로그 백업을 이용합니다.
    - 포인트-인-타임 복구: 특정 시점의 데이터베이스로 복구하는 방법으로 트랜잭션 로그를 이용합니다.
    - 무중단 복구: 실시간으로 데이터베이스의 현재 상태를 유지하며 백업을 진행하는 방식입니다.

## 스냅샷(Snapshot)이란 무엇인가요?**
- 데이터베이스의 파일 시스템에 대한 특정 시간대의 복사본을 말합니다. 이러한 복사본은 읽기 전용이며 전체 데이터베이스의 백업 과정보다 빠르게 진행됩니다.

## 데이터베이스의 고가용성(High Availability)을 유지하기 위한 전략은 무엇인가요?**
- 데이터베이스 고가용성이란 데이터베이스 시스템이 지속적으로 사용할 수 있도록 보장하는 특성을 말합니다.
- 데이터베이스 고가용성 유지 전략: 클러스터링, Replication, 백업 및 복구, 스냅샷, 로드밸런싱, 모니터링

## 분산 데이터베이스의 개념과 장점은 무엇인가요?**
- 분산 데이터베이스란 물리적으로 분산된 데이터베이스 서버에 데이터를 저장하고 관리하는 것을 말합니다. 하지만 클라이언트인 Application, Server는 단일 데이터베이스처럼 사용할 수 있으며 여러 노드 간의 데이터터 일관성을 유지합니다.
- 분산 데이터베이스 장점
    - 확장성: 데이터가 많아질 경우 노드를 추가하면 되기에 확장성 측면에서 이점이 있습니다.
    - 고가용성: 특정 노드에서 장애가 날 경우 서버 전체로 장애 전파가 되지 않음
    - 성능 향상: 병렬 트랜잭션 처리가 가능하며 트랜잭션에 대한 로드 밸런싱이 가능

## 데이터베이스 클러스터링이란 무엇인가요?**
- 데이터베이스 클러스터링이란 여러 데이터베이스 인스턴스를 논리적으로 하나의 인스턴스로 사용하는 기술을 말합니다. → 특정 인스턴스에서 장애가 발생 시 다른 인스턴스로 교체하여 장애 시간 단축, 트랜잭션을 로드 밸런시하여 특정 인스턴스에서의 부하를 방지

데이터 마이그레이션(Migration)이란 무엇인가요?

- 한 시스템에 있는 데이터를 다른 시스템에 옮기는 과정을 말합니다.
- 이 때 데이터를 옮기는 과정 중 데이터의 손실 없이 기존의 데이터가 정확하게 마이그레이션 되어야 합니다.
- 데이터 마이그레이션의 유형은 온프레미스에 있는 데이터를 클라우드로 이전하는 클라우드 마이그레이션과 데이터베이스에 있는 데이터를 다른 데이터베이스로 옮기는 등등이 존재합니다.

**데이터베이스 연결 풀(Connection Pool)이란 무엇인가요?**

- 데이터베이스 커넥션 풀이란 데이터베이스와의 커넥션을 미리 생성한 후 생성된 커넥션을 재사용하는 기법을 말합니다. 커넥션 재사용하는 이유는 커넥션을 생성하고 커넥션을 해제하는 과정에서 오버헤드가 발생할 수 있기 때문에 풀에 있는 커넥션을 재사용합니다.
- 최소 커넥션 = 10, 최대 커넥션 = 50, 유휴 타임 아웃 = 1분인 톰캣 서버에서 30개의 요청이 동시에 왔을 때 커넥션 풀의 상태를 설명해보세요(10개는 이미 사용한다고 가정)
    - 톰캣 서버가 실행되면서 커넥션 풀에 최소 커넥션 수가 10개 생성
    - 30개의 요청을 처리하기 위한 30개의 커넥션이 생성되면서 커넥션 풀에 40개의 커넥션이 존재하는 상태 → 처리 완료 후 사용된 커넥션은 유휴 커넥션 상태로 변경
    - 1분이 지나면서 유휴 커넥션 30개가 제거 → 최소 커넥션인 10개만 존재하는 상태
- 커넥션 풀에 최대 커넥션의 수가 존재하는 상태에서 커넥션이 추가되는 경우 어떻게 되나요?
    - 먼저 커넥션 대기열에 커넥션을 보관합니다. 그리고 커넥션 대기열에 대기열 보관 시간만큼 유지시킨 후 커넥션 풀에서 커넥션이 제거되면 커넥션 대기열에서 보관된 커넥션을 사용하게 됩니다. 만약 커넥션 풀에서 커넥션이 계속 유지된 상태에서 커넥션 대기열에 계속해서 커넥션이 추가되여 최대 커넥션 대기열 개수를 넘어서게 되면 SQLException이 발생하게 됩니다.

데이터베이스에서 동시성 제어를 위해 사용되는 기법은 무엇인가요?

- 공유 락: 공유 락을 걸어 다른 트랜잭션은 해당 레코드에 대해서 읽기만을 보장하게 하는 기법
- 베타 락: 베타 락을 걸어 다른 트랜잭션은 해당 레코드에 대해서 읽기, 쓰기를 모두 제한하는 것을 보장하는 기법
- 낙관적 락: 데이터 중돌이 별로 없다는 것을 가정하여 트랜잭션의 커밋 시점에서 기존 데이터의 값 변경 유무를 체크하여 트랜잭션을 재시도하거나 롤백하는 기법
- 비관적 락: 트랜잭션이 시작되는 시점에서 무조건 락을 걸어 다른 트랜잭션에서는 접근하는 것을 막는 기법

**테이블 조인과 서브쿼리 중 어느 것을 사용해야 하나요?**

- 조인 연산을 사용하는 경우
    - 여러 테이블에서 결합하여 데이터를 조회해야 하는 경우
    - 데이터 셋이 커서 데이터 성능 처리가 필요하는 경우 → 일반적으로 서브 쿼리보다 조인 연산이 더 성능이 우수함
- 서브 쿼리를 사용하는 경우
    - 단일 값을 반환하는 경우
    - 메인 쿼리의 WHERE 절의 조건이 특수한 경우 → 예를 들어서 평균 값, 혹은 MAX 또는 MIN 값을 조건 절로 사용하는 경우 등등..

**데이터베이스에서 컨테이너(DB 컨테이너)란 무엇인가요?**

- 도커 같은 컨테이너 툴을 이용하여 컨테이너화 된 데이터베이스 인스턴스를 실행하는 것을 말합니다.
- 컨테이너의 특징인 OS 또는 Application에서 독립적으로 실행할 수 있는 장점이 있습니다.

**데이터베이스에서 커서(Cursor)란 무엇이며, 언제 사용하나요?**

- 커서란 쿼리 문에 의해서 반환된 결과 값들을 임시적으로 저장하는 메모리 공간을 말합니다. 커서는 메모리 공간이기에 해당 메모리 공간에 저장되어 있는 쿼리 결과 값들을 사용할 때는 Fetch를 사용합니다.
- 커서를 사용하게 되면 해당 데이터 값들에 대해서 순차적으로 접근할 수 있습니다. 그리하여 특정 범위 간격으로 추가 쿼리를 실행하거나 Application에서 단계적으로 비즈니스 로직을 처리할 때 유용합니다.

**데이터베이스의 잠금(Locking) 기법에는 어떤 것들이 있나요?**

- 공유 락, 베타 락, 낙관적 락, 비관적 락

**페이징 쿼리(Pagination)를 효율적으로 작성하는 방법은 무엇인가요?**

- No Offset 구조로 변경하기: 기존의 페이지 번호(offset)과 페이지 사이즈(limit)를 이용하는 방식에서 페이지 번호가 없는 더 보기(More) 방식으로 변경 → 기존의 방식은 앞에 읽었던 행을 다시 읽어서 특정 범위의 결과를 조회하는 방식인데 이 방식에서 조회 시작 부분을 제일 빠르게 탐색하는 방식으로 변경하는 방법 → 마지막으로 탐색된 페이지 번호를 가지고 있는 상태에서 해당 페이지를 시작점으로 탐색
- 커버링 인덱스 사용하기: No offset을 사용할 때 사용하는 방식으로 모든 컬럼에 대해서 인덱스를 사용하는 커버링 인덱스를 이용하여 탐색 성능 최적화를 진행합니다.

**데이터베이스에서 NULL 값을 처리하는 방법을 설명해주세요.**

- 먼저 데이터베이스에서 NULL의 의미는 값이 존재하지 않음을 의미합니다.
- 데이터베이스의 컬럼 옵션에 NULL 제약 조건을 사용하여 데이터가 추가 될 때 NULL의 유무를 체크할 수 있으며 NULL 값을 비교하는 경우 =, !=과 같은 기본 연산자는 사용할 수 없어 IS NULL, IS NOT NULL 연산자를 사용해야 합니다.

**데이터베이스에서 로그(Log) 파일이란 무엇인가요?**

- 일반적으로 데이터베이스 로그 파일이란 데이터베이스에서 발생하는 모든 트랜잭션에 대한 변경 사항을 기록하는 파일을 의미합니다.

**데이터베이스 인스턴스와 스키마의 차이점은 무엇인가요?**

- 데이터베이스 인스턴스란 특정 싲머에서 데이터베이스에 저장된 데이터 집합을 의미합니다. 이 때 말하는 데이터 집합이란 단순하게 실제 저장된 데이터 뿐 아니라 관련된 메모리 및 디스크 구조를 포함합니다.
- 데이터베이스 스키마란 데이터베이스의 구조를 의미합니다. 데이터베이스 테이블 구조, 컬럼, 데이터 타입, 제약 조건과 같은 설계 구조를 의미합니다.

**RDBMS에서 제약조건(Constraint)의 종류에는 무엇이 있나요?**

- 기본 키 제약 조건: 기존 키는 NULL일 수 없으며 유일함을 보장하는 제약 조건, 테이블에 하나만 설정 가능
- 외래 키 제약 조건: 외래 키 값이 참조하는 테이블의 기본 키 값과 일치함을 보장하는 제약 조건
- 유니크 제약 조건: 열의 값이 유일함을 보장하는 제약조건
- NULL 제약 조건: 특정 열이 NULL을 가지거나 가질 수 없음을 보장하는 제약 조건
- 체크 제약 조건: 특정 열의 값이 어떠한 조건을 만족함을 보장하는 제약 조건 → 예를 들어 age 컬럼의 값이 20 이상임을 보장하는 제약 조건

**데이터베이스의 테이블 파티셔닝과 인덱스 파티셔닝의 차이점은 무엇인가요?**

- 테이블 파티셔닝이란 큰 테이블을 작은 테이블로 분할하는 기법입니다.
- 인덱스 파티셔닝이란 테이블 파티셔닝과 마찬가지로 너무 많은 데이터를 가지고 있는 특정 인덱스에 대해서 분할하는 기법을 말합니다. 인덱스 파티셔닝은 테이블과는 별도로 관리되며 조회 성능을 향상시키기 위해 사용됩니다. 인덱스 파티셔닝을 통해서 조회 성능이 향상되는 이유는 인덱스가 파티션으로 나뉘어져서 조회 시 하나의 인덱스 파티션에 대해서만 사용하게 될 경우 해당 인덱스 파티셔닝은 데이터가 이미 분할되어 범위가 좁기에 조회 성능이 향상 됩니다. 또한 각 인덱스 파티션은 병렬 처리가 가능하여 이에 따라 조회 성능이 향상됩니다.

**테이블의 조인 순서가 성능에 미치는 영향은 무엇인가요?**

- 조인이 진행되는 과정은 구동 테이블에서 다른 테이블을 검색하는 것이기에 구동 테이블의 레코드 수와 연결 과정에 대한 순서를 고려하는 것이 좋습니다.
- 일반적으로 구동 테이블의 레코드 수가 적을 경우 조인 검색 성능이 향상되기에 레코드가 적은 순서를 구동 테이블로 설정합니다.
- 조인 연산을 진행할 때 사용되는 컬럼이 인덱스로 설정되어 있는 테이블을 구동 테이블로 설정합니다.
- 카디널리티가 적은 레코드를 많이 가지는 테이블을 기준으로 구동 테이블을 설정합니다.

**OLAP에서 큐브(Cube)란 무엇인가요?**

- 다차원 데이터를 구조화하여 분석할 수 있도록 하는 데이터 모델입니다. 그리하여 데이터를 여러 차원에서 분석하고 시각화 할 수 있게 해주어 대규모 데이터 집합에 대해 신속하고 효율적인 쿼리를 지원합니다.

**데이터베이스 샤딩 시 데이터 일관성을 유지하는 방법은 무엇인가요?**

- 옳바른 샤드 키를 이용하여 각 샤드에 데이터가 고르게 저장될 수 있도록 설계합니다.
- 분산 트랜잭션을 이용하여 각 샤드간의 트랜잭션 처리를 진행하여 일관성을 보장합니다.

**데이터베이스에서 이력 관리(History Tracking)를 위한 설계 방법은 무엇인가요?**

- 데이터를 추가하거나 변경할 때 변경을 진행하는 유저 정보에 대한 컬럼을 추가
- 테이블 컬럼에 데이터가 추가 된 시간, 수정 된 시간에 대한 컬럼을 사용하여 데이터가 추가 되거나 변경 시 해당 값을 사용
- DELETE 절을 사용하는 것이 아닌 삭제 유무 컬럼을 사용하여 플래그 값을 사용하여 논리적인 레코드 삭제 진행 → 실제 데이터가 삭제되는 경우 이력 확인이 어려움

**시계열(Time-series) 데이터베이스란 무엇인가요?**

- 시계열 데이터베이스란 시간에 따라 변화하는 데이터를 관리하는 데이터베이스입니다.
- 데이터를 저장할 때 시간 순서대로 저장하며 대량의 데이터를 저장하기에 중복된 데이터가 있을 수 있어 휴율적인 저장 방식과 압축 방식으로 구조가 이뤄져 있습니다.

**데이터베이스에서 자동 증가(Autoincrement)와 시퀀스(Sequence)의 차이점은 무엇인가요?**

- 자동 증가와 시퀀스 모두 기본 키를 생성하는 방법의 일종입니다.
- 자동 증가는 테이블의 특정 컬럼에 직접 적용 되며 새로운 레코드가 삽입 될 때마다 이전 컬럼의 최대 값 +1을 진행하는 방법입니다. 동시에 데이터가 삽입될 때도 충돌 없이 안전하게 자동 증가가 되며 자동 증가 된 값을 재사용 되지 않음을 유의해야 합니다.
- 시퀀스는 테이블과 독립적으로 시퀀스라는 데이터베이스 객체에서 기본 키를 생성하는 방식으로 해당 시퀀스의 기본 키값을 참조하여 테이블의 기본 키 값에 넣어주는 방법입니다.

**데이터베이스에서 클러스터링 지수(Clustered Index)란 무엇인가요?**

- 클러스터링 인덱스란 데이터 페이지를 물리적으로 정렬하여 저장하는 인덱스를 말합니다. 즉 클러스터링 인덱스에 따라서 물리적으로 데이터가 저장되는 인덱스를 의미합니다. 물리적으로 데이터가 정렬되어 있기에 클러스터링 인덱스로 조회를 하는 경우 조회 성능이 우수합니다. → 대신에 데이터가 추가 되거나 삭제되는 경우 기존의 데이터를 이동해야 하기에 쓰기 및 삭제에 대해서는 성능이 저하될 수 있습니다.
- 테이블은 하나의 클러스터링 인덱스를 가질 수 있으며 일반적으로는 기본 키가 클러스터링 인덱스로 설정됩니다. 하지만 기본 키가 아닌 다른 컬럼에도 클러스터링 인덱스를 설정할 수 있습니다.
