## 데이터베이스란 무엇인가요?
### 데이터베이스
  - 전자적으로 저장되는 데이터 모음
  - 단어, 숫자, 이미지, 비디오, 파일 등을 포함한 모든 유형의 데이터 포함
  - 일반적으로 DBMS 라는 소프트웨어를 사용하여 데이터를 저장, 검색 및 편집 진행
  - 일반적인 유형의 데이터베이스에서 데이터는 처리 및 데이터 쿼리를 효율적으로 수행하기 위해 일련의 테이블에서 행열로 모델링 → 데이터에 쉽게 접근하고 관리, 수정, 제어 등이 가능해짐
  - 대부분의 데이터베이스는 데이터 작성, 쿼리에 SQL 사용
### DBMS
  - 데이터베이스 관리 시스템
  - 데이터베이스와 프로그램 간의 인터페이스 역할을 해서 사용자가 정보의 구성 및 최적화 방법을 검색, 관리할 수 있도록 도와줌
### SQL
  - Structed Qeury Language
  - 데이터를 쿼리, 조작, 정의하고 엑세스 제어를 제공하기 위해 거의 모든 관계형 데이터베이스에서 사용되는 프로그래밍 언어
### 데이터베이스 유형
  - 관계형 데이터베이스
      - 데이터베이스 항목은 열과 행이 있는 테이블 집합으로 구성
  - NoSQL 데이터베이스
      - 비정형 데이터를 저장하고 조작 가능
      - 애플리케이션의 복잡도가 증가함에 따라 사용량 상승
   
## RDBMS와 NoSQL의 차이점은 무엇인가요?
### RDBMS
  - 관계형 데이터베이스
  - 테이블 형식으로 데이터를 저장하고 SQL을 사용하여 데이터 관리
  - 데이터 무결성, 일관성 → 안정성 보장
  - 복잡한 쿼리 지원, 데이터 간의 관계 표현 쉬움
  - 대규모 데이터 처리, 스케일 아웃에 한계 존재 → 은행 등 안정성이 중요한 시스템에서 사용
  - MySQL, PostgreSQL, Oracle 등
### NoSQL
  - 비 관계형 데이터베이스
  - 키-밸류, 도큐먼트, 그래프 등 다양한 데이터 모델 지원, SQL 사용하지 않음
  - 빠른 응답 속도와 처리량, 높은 확장성 → 소셜 네티워크 서비스나 로그성 데이터 저장 시 사용
  - 수편정 확장 가능, 유연하게 데이터 모델 사용 가능
  - 데이터 일관성 보장 x, 데이터 중복 관리 필요
  - MongoDB, Redis 등

## SQL이란 무엇이며, SQL의 종류에는 무엇이 있나요?
### SQL
  - 구조적 쿼리 언어
  - 관계형 데이터베이스에 정보를 저장하고 처리하기 위한 프로그래밍 언어
  - 특징
    - 기본적으로 대소문자 구분 x
    - 명령은 세미콜론으로 끝남
    - 고유값은 따옴표를 사용
    - 객체를 나타낼 때에는 백틱 사용
### SQL 문법 종류
  - DDL: 각 테이블을 정의하기 위해 사용하는 언어 (CREATE, ALTER, DROP, …)
  - DML: 데이터 검색, 삽입, 변경, 삭제 등 관리를 위한 언어 (SELECT, INSERT, UPDATE, …)
  - DCL: 사용자별로 테이블 또는 데이터를 관리하고 접근하는 권한을 다루는 언어 (GRANT, REVOKE, …)

## 데이터베이스 스키마란 무엇인가요?
### 데이터베이스 스키마
  - 관계형 데이터베이스 내에 데이터가 구성되는 방식
  - 속성, 엔티티, 테이블, 엔티티 간의 관계를 포함한 제약 조건 등이 정의
### 스키마 종류
  - 외부 스키마 (User View)
      - 개별 사용자 또는 응용 프로그램이 데이터를 인식하고 상호 작용하는 방식 (실제 데이터를 어떻게 사용자에게 보여줄 것인지)
      - 각 프로그램은 특정 요구사항과 권한에 맞게 서로 다른 외부 스키마 가질 수 있음(여러개 존재 가능) → 전체 데이터베이스의 복잡성 감소
      - 전체 데이터 베이스의 한 논리적 부분 ⇒ 서브 스키마: 응용프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의
  - 개념 스키마 (Local View)
      - 물리적 스토리지, 구현 세부 정보와 관계 없이 데이터베이스에 있는 데이터의 전체 논리 구성
      - 데이터 베이스 파일에 저장되는 데이터 형태를 나타내어 DBA에 의해 구성
      - 외부 스키마와 내부 스키마 연결하는 역할을 하고 모든 프로그램에게 일관된 데이터 보기 제공
      - 데이터베이스 당 한개 존재
  - 내부 스키마 (Physical View)
      - 하드 디스크와 같은 스토리지 미디어에 있는 데이터의 실제 물리적 저장소 및 구성
      - 파일 구조, 인덱스 유무, 데이터 저장 형식 등의 세부 정보 포함
      - 데이터와 상호작용하는 애플리케이션으로부터 세부 정보 숨기고 데이터 저장, 엑세스 및 검색을 최적화하는 역할 → db 실행 속도에 큰 영향을 줌
      - 시스템 프로그래머나 시스템 설계자의 관점

> 데이터베이스 스키마와 인스턴스
> - 스키마는 전체적인 구조를 보여주는 역할, 실제 데이터 포함 x
> - 인스턴스는 데이터베이스의 데이터 샘플 (특정 시점의 스냅샷이기 때문에 변경될 수 있음)

## 테이블과 뷰(View)의 차이점은 무엇인가요?
### Table
  - 행열로 표현될 수 있는 실제 데이터 집합
### View
  - 데이터베이스에 있는 가상 테이블 (실제 데이터를 저장하지 않음)
  - 실제 데이터를 가지고 자주 사용하는 쿼리를 저장해놓고 쿼리를 실행 시켜 새로운 테이블처럼 보여줌 → 조회 가능, 삽입, 삭제 등은 제약 존재 (union, where 문의 조건 필요)
  - 복잡하고 긴 쿼리문을 뷰로 정의하여 접근을 단순화
  - 사용자에게 권한을 다르게 부여할 수 있기 때문에 보안 유지 가능

## 기본키(Primary Key)와 외래키(Foreign Key)의 차이점은 무엇인가요?
### 기본키
  - 테이블에 있는 유일하게 구분되는 키
  - 특징
      - 고유성
      - null 값 허용 불가
      - 일반적으로 숫자나 문자열
      - 테이블의 기본 정렬 기준
### 외래키
  - 한 테이블과 참조되는 다른 테이블 간의 연결되는 기본키 컬럼
  - 다른 기본키를 참조하는 속성, 속성의 집합을 의미
  - 특징
      - 무결성 유지
      - 한 테이블 내에서 외래 키 중복 가능
      - 삭제 및 업데이트 규칙 설정 가능
    
> - 슈퍼키: 각 데이터를 유일하게 식별할 수 있는 속성의 집합
> - 후보키: 각 데이터를 유일하게 식별할 수 있는 최소한의 속성 집합     
> 슈퍼키 > 후보키 > 기본키

## ACID란 무엇이며, 각각의 의미를 설명해주세요.
### ACID
데이터베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 특징
- 원자성: 트랜잭션 내에 실행되는 명령을 하나의 묶음으로 처리하여 내부에서 실행된 명령들이 전부 성공하거나 실패해야 한다는 특징, 여러개의 작접을 묶어 하나의 단위로 봄 → 결과 예측 가능
- 일관성: 트랜잭션 내부에서 처리되는 데이터의 일관성 유지, 에러가 발생해도 실패한 상태로 방치하지 않고 데이터의 상태를 일관되게 유지 → 트랜잭션 전후로 데이터베이스의 상태가 이전과 동일한 상태로 유지 (데이터베이스의 제약이나 규칙 만족해야함)
- 격리성: 트랜잭션 실행 중 다른 트랜잭션에 의해 데이터가 변경되는 것을 방지, 트랜잭션 중간 과정이나 결과를 볼 수 없음
- 지속성: 트랜잭션이 성공적으로 커밋된 후 해당 트랜잭션에 의해 생성, 수정된 데이터가 어떤 상황에서도 보존 → 기록이 영구적으로 저장

## 트랜잭션이란 무엇인가요?
### 트랜잭션
  - 데이터베이스의 상태를 변환시키는 기능을 수행하기 위한 하나 이상의 쿼리를 모아 놓은 하나의 작업 단위
  - 완전히 완료되거나 완전히 완료되지 않을 수 있고 시스템을 일관된 상태로 유지시켜줌

## 데이터베이스의 정규화(Normalization)란 무엇이며, 그 목적은 무엇인가요?
### 정규화
  - 테이블 간 중복된 데이터를 허용하지 않고 데이터 구조를 조직화하고 최적화하는 과정
  - 데이터 중복을 통해 효율성 향상, 무결성 보장
1. 제 1 정규화
  - 테이블의 컬럼이 하나의 데이터만 갖고 여러개의 값을 가지지 않도록 테이블 분해
2. 제 2 정규화
  - 제 1 정규화가 진행된 테이블에 대해 완전 함수 종속을 만족하도록 테이블 분해(복합키 중 하나의 컬럼이 다른 컬럼의 결정자일 경우 컬럼을 분해하여 별도로 관리 - 현재 테이블과 관련 없는 컬럼을 따로 빼는 방식)
  - 완전 함수 종속: 기본키의 부분집합이 결정자가 되지 않는 것 (↔ 부분 함수 종속성)
3. 제 3 정규화
  - 제 2 정규화가 진행된 테이블에 대해 이행적 종속 제거하도록 테이블 분해 (간접적인 종속성 제거)
  - 이행적 종속: A → B, B → C 일 때, A → C 성립
4. BCNF 정규화
  - 제 3 정규화가 진행된 테이블에 대해 모든 결정자가 후보키가 되도록 테이블 분해

## 역정규화(Denormalization)란 무엇이며, 언제 사용하나요?
- Join 연산이 많아질수록 쿼리를 처리하는 성능이 저하될 수 있음
- 무조건 정규화가 좋은 것이 아니라 데이터베이스의 전반적인 성능을 향상시킬 수 있도록 구조화하는 것이 좋음
- 정규화와 반대로 데이터의 중복을 허용하고 엔티티를 다시 통합하거나 분리하여 DB 구조를 재조정하는 과정 → 데이터베이스 비용 최소화

## INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN의 차이점은 무엇인가요?
1. (Inner) Join
    - 교집합 연산
    - 조인하는 테이블 데이터 중 공통적으로 존재하는 데이터만 조인해서 결과 데이터 집합 추출
1. Left (Outer) Join
    - 교집합 연산과 차집합 연산의 합집합 (기준이 되는 테이블은 변형이 없음)
    - 조인하는 테이블 데이터 중 공통적으로 존재하는 데이터와 조인하는 테이블에만 존재하는 데이터를 결과 데이터 집합을 추출
    - 데이터가 존재하지 않는 경우 null로 표시
1. Right (Outer) Join
    - 교집합 연산과 차집합 연산의 합집합 (join 테이블 기준)
1. Full Outer Join
    - 합집합 연산의 결과
    - 모든 결과 데이터 집합

* Outer Join
  - 교집합 + 해당하지 않는 값까지 조회
  - 기준이 되는 테이블 필요
 
## GROUP BY와 HAVING의 차이점은 무엇인가요?
### GROUP BY
원하는 데이터끼리 묶어서 처리할 때 사용
### HAVING
그룹에 대해 조건에 맞는 데이터만 뽑아 사용
- WHERE과의 차이: WHERE는 그룹핑이 진행 되기 전에 데이터를 필터링할 때 사용

## WHERE와 HAVING의 차이점은 무엇인가요?
### WHERE
  - 기본적인 조건절
  - 그룹화 진행 전 모든 필드를 조건으로 둠
### HAVING
  - group by 를 통해 그룹핑을 진행한 뒤 사용
  - 그룹화 진행 후 새로운 테이블에 조건 걸기

## DISTINCT 키워드는 무엇을 하는가요?
### DISTINCT
  - 데이터의 중복을 제거하기 위해 사용
  - SELECT와 함께 사용
  - 임시로 데이터를 저장하고 작업하는 방식으로 작동하기 때문에 추가적인 리소스를 사용하여 성능에 영향을 줄 수 있음

## 서브쿼리란 무엇이며, 서브쿼리의 종류에는 무엇이 있나요?
### 서브쿼리
- 다른 쿼리 내부에 포함되어 있는 SELECT 문
- 서브 쿼리를 포함하는 쿼리를 외부쿼리라고 함 ↔ 내부쿼리(서브쿼리)
- 실행 순서: 서브 쿼리 → 메인 쿼리
- 장점
  - 쿼리를 구조화하여 쿼리의 각 부분을 명확하게 구분 가능
  - 복잡한 Join, Union 보다 가독성이 좋고 비슷한 동작을 수행할 수 있음
- 종류
  - 단일행 서브쿼리
      - 단일행 비교 연산자와 함께 사용할 때는 서브쿼리의 결과가 2개 이상이 되면 안됨
  - 다중행 서브쿼리
      - 서브쿼리 결과가 2개 이상이 된다면 다중행 비교 연산자 사용(IN, ALL, ANY, …)
  - 다중 컬럼 서브쿼리
      - 서브쿼리 결과로 여러 개의 컬럼이 반환되어 메인 쿼리의 조건과 동시에 비교
  - 연관 서브쿼리
      - 서브 쿼리 내에 메인쿼리 컬럼이 사용된 서브쿼리
  - 중첩 서브쿼리
      - WHERE 문에 나타나는 서브쿼리
  - 인라인 뷰
      - FROM 문에 나타나는 서브쿼리
      - 무조건 별칭 지정 필요
  - 스칼라 서브쿼리
      - SELECT 문제 나타나는 서브쿼리
      - 다른 테이블에서 특정 값을 참조할 때 사용
   
## UNION과 UNION ALL의 차이점은 무엇인가요?
합집합 표현할 때 사용       
UNION은 중복을 제거하여 데이터 모두 검사 → 속도 저하 ↔ UNION ALL

## EXISTS와 IN의 차이점은 무엇인가요?
WHERE 절에서 데이터를 조건으로 필터링하기 위해 사용

### EXISTS 연산자
  - 특정 컬럼이 존재하는지 여부 확인 (서브쿼리만 사용 가능)
  - 존재 여부만 확인하고 다음 쿼리 진행 x - Select절 역할 x
  - 성능이 더 좋지만 대용량 데이터가 아닌 이상 큰 차이 없음
### IN 연산자
  - 특정 값 또는 서브쿼리 결과가 포함되는지 여부 확인
  - SELECT 절에서 조회한 컬럼 기준으로 비교
  - 쿼리순서: IN 쿼리 → 메인 쿼리

## COUNT, SUM, AVG, MIN, MAX 같은 집계 함수에 대해 설명해주세요.
### 집계함수
  - 데이터베이스에서 그룹 단위로 데이터를 집계하고 통계적인 값을 계산하기 위해 사용하는 함수 - 여러개의 행을 하나의 결과로 반환
  - SELECT 문에서만 사용 가능
  - 열끼리 연산 수행
1. COUNT: 행의 개수 계산, null 포함한 모든 행의 개수
2. SUM: 숫자 데이터의 합계 계산, null 값 제외
3. AVG: 숫자 데이터의 평균 계산, null 값 제외
4. MAX: 숫자나 문자열 데이터의 최대값 반환, null 값 제외
5. MIN: 숫자나 문자열 데이터의 최소값 반환, null 값 제외

## 데이터베이스에서 뷰(View)란 무엇이며, 장단점은 무엇인가요?
### 뷰
- 접근이 허용된 자료만 제한적으로 보여주기 위해 기본 테이블로부터 생성하는 가상의 테이블
- 물리적으로 저장 장치 내에 저장하지 않음
- 조인문의 사용이 최소화되어 쉽게 사용 가능
- 필요한 데이터만 뷰로 정의해서 처리할 수 있기 때문에 관리 용이하고 명령문 간단해짐
- 참조되는 기본 테이블이나 뷰가 삭제되면 참조한 다른 뷰도 자동으로 제거
- 장점
    - 논리적 데이터 독립성 제공
    - 동일 데이터에 대해 사용자마다 다르게 사용할 수 있음
    - 간단한 데이터 관리
    - 접근 제어를 통해 보안관리
- 단점
    - 독립적인 인덱스 x
    - 뷰의 정의를 변경할 수 없음
    - 삽입, 삭제, 갱신 등에 제약이 있음
 
## CASE문을 사용하여 조건부로 데이터를 조회하는 방법을 설명해주세요.
CASE 문은 조건에 따라 서로 다른 값 반환
1. IF
```sql
CASE WHEN A = 1 THEN "1"
     WHEN A = 2 THEN "2"
     ELSE "3"
END AS ""
```
    
2. SWITCH
```sql
CASE A
     WHEN 1 THEN "1"
     WHEN 2 THEN "2"
     ELSE "3"
END AS ""
```

## 인덱스란 무엇인가요?
- 데이터베이스의 검색 성능 최적화를 위한 도구(자료구조)
- 데이터의 위치와 데이터가 포함된 자료구조를 생성하여 데이터 검색 속도 향상
- 인덱스를 사용하지 않고 WHERE 절과 함께 SELECT를 사용하게 되면 모든 테이블을 조회한 후 조건에 충족하는 데이터 반환 → 데이터 개수가 많아지고 조회 횟수가 늘어날 경우 성능 저하 발생 가능
- 마지막으로 확인해야 하는 위치만 알면 전체 데이터 확인하지 않아도 됨 → 자주 조회하는 컬럼에 인덱스를 걸어 검색 연산 최적화

## 클러스터드 인덱스(Clustered Index)와 넌클러스터드 인덱스(Non-clustered Index)의 차이점은 무엇인가요?
### 클러스터드 인덱스
- 리프 노드에서 인덱스는 항상 정렬을 유지하고, 실제 데이터를 함께 저장(실제 데이터를 인덱스 기준으로 항상 정렬)
- 인덱스로 가장 적합한 컬럼 하나를 클러스터 인덱스로 지정 (주로 PK)
- 항상 정렬된 상태이기 때문에 검색 속도가 빠르지만 삽입, 삭제, 수정이 일어날 때 마다 정렬이 필요하여 속도 저하
- 테이블당 하나만 생성 가능(PK 또는 유니크하고 null이 아닌 컬럼)

### 넌클러스터드 인덱스
- 인덱스 페이지를 별도로 관리, 실제 데이터와는 분리되어 있음(실제 데이터는 정렬 x)
- 리프 노드에서 인덱스는 데이터의 주소값을 저장하고 있고 주소값을 통해 실제 데이터 호출
- 삽입, 삭제, 수정 연산이 빠르지만 검색 속도는 클러스터드 인덱스보다 느림
- 여러개의 인덱스 생성 가능

## 인덱스를 언제 사용하는 것이 적합한가요?
- 삽입, 수정, 삭제가 자주 일어나지 않는 컬럼
- where, join 등 조건문에 자주 사용되는 컬럼

## 인덱스 사용이 성능에 미치는 영향은 무엇인가요?
- 인덱스 테이블: 하나의 테이블을 생성하여 값을 지정 후 사용(인덱스 생성을 위해 추가 공간 필요) → 다른 테이블에 의존적인 새로운 테이블이 하나 생성되기 때문에 인덱스를 많이 생성하면 성능 저하 초래 가능
- 정렬: 이진트리 검색을 사용하기 때문에 기본적으로 정렬 되어 있는데 생성, 수정, 삭제가 자주 발생하게 되면 전체적인 성능 저하 초래 가능

## 인덱스의 구조는 무엇인가요? (예: B-Tree)
1. 해시 테이블
   - key-value 형태로 데이터 저장
   - key를 통해 값에 바로 접근하기 때문에 검색 시 O(1) 시간 복잡도
   - key를 해시 함수를 사용하여 해시 값으로 변환한 후, 해당 해시 값에 해당하는 값을 찾아 검색
   - 등호 연산에는 빠르지만 부등호 연산에는 적합하지 않음(정렬 되어 있지 않기 때문에)
2. B-tree
   - 한 노드에 여러 개의 값 가능, 자식 노드 2개 이상 가능
   - 노드 내 데이터는 정렬된 상태 유지
   - 속도가 빠르고 어떤 값이든 동일한 시간으로 결과 얻기 가능 (균일성), O(logn) 시간 복잡도
   - 균형트리
      - 루트로부터 리프까지의 거리가 일정한 구조(트리 중 성능 안정화)
      - 첫 생성 시에는 균형 트리이지만 삽입, 수정, 삭제가 반복되면서 균형이 무너지고 성능에 영향을 줌
   - 노드에 저장된 값 사이의 포인터를 통해 탐색
3. B+tree
   - B-tree의 확장 개념
   - 실제 데이터는 리프 노드에만 저장(인터널 노드는 key만 가지고 있음)
   - 리프 노드끼리 링크드 리스트로 연결
   - 중복키를 가짐
      - 리프 노드 외에는 data를 저장하지 않기 때문에 메모리 확보 가능 (트리의 높이가 낮아지기 때문에 검색 속도 향상)
      - B-tree 처럼 모든 노드를 확인하지 않고 한번의 선형 탐색을 통해 리프 노드만 확인하면 되기 때문에 검색 속도 빠름
        
## 인덱스를 너무 많이 만들면 성능에 어떤 영향이 있나요?
1. 저장 공간과 성능 비용
    - 추가적인 공간이 필요하기 때문에 데이터베이스 용량 증가
    - 데이터 삽입, 수정, 삭제 시 인덱스 갱신 필요
2. 인덱스를 관리 및 유지 비용

## Composite Index(복합 인덱스)란 무엇인가요?
- 두 개 이상의 컬럼을 포함하는 인덱스
- 여러 컬럼을 동시에 필터링하거나 정렬할 때 유용, 쿼리 성능 향상
- 인덱스 컬럼을 순차적으로 검색하기 때문에 컬럼의 순서가 중요함(가장 자주 사용되는 컬럼을 인덱스 첫번째 컬럼으로 지정하는 것이 좋음)
- B-tree 구조를 사용하여 데이터 저장 - 첫번째 컬럼을 기준으로 정렬된 후 그 다음 컬럼으로 정렬
- 인덱스 생성, 관리 시에는 비용이 많이 발생하기 때문에 필요한 경우에만 생성하여 성능 최적화하는 것이 중요
- 쿼리를 최적화하고 검색 속도 개선 가능
- where, join, order by 에서 자주 사용되는 컬럼을 인덱스로 사용하는 것이 좋음

## 인덱스 설계 시 주의해야 할 점은 무엇인가요?
- 자주 조회하는 유니크한 컬럼 위주로 설계 (중복 개수가 적을수록 좋음)
- 많이 생성하지 않도록 주의 (일반적으로 한 테이블에 3-4개를 권장)
- when, join, order by 등 조건문에서 자주 사용되는 컬럼 사용
- 정수형 자료형이 인덱스 생성시 가장 효율적

## 데이터베이스에서 인덱스의 재구성(Rebuild)과 재구성하지 않음(Reorganize)은 무엇이 다른가요?
- 조각화: 데이터베이스에서 인덱스 내부의 데이터 페이지가 물리적으로 분산되어 저장되는 현상
    - 내부 조각화: 인덱스 페이지 내에서 데이터 추가나 삭제 등으로 인해 빈 공간 발생하는 경우 페이지 읽는 데에 많은 시간 소요
    - 외부 조각화: 인덱스 페이지 간의 물리적 공간이 분산되는 경우 → 인덱스 페이지들이 서로 떨어져서 저장되는 경우 해당 인덱스의 검색 작업은 여러 디스크를 참조하기 때문에 성능 저하 초래
### 인덱스 리빌드 Rebuild
   - 인덱스를 완전히 새롭게 재생성 (기존 인덱스를 제거하고 새로운 인덱스를 생성하여 데이터 정렬
   - 리소스 많이 사용하고 데이터베이스 성능에 영향을 준다.
   - 인덱스 조각화가 심한 경우에 사용하는 것이 좋음
### 인덱스 리오거나이즈 Reorganize
   - 인덱스의 논리적 조각화를 줄이기 위해 인덱스 페이지 재구성
   - 기존 인덱스를 유지하면서 페이지를 정렬하고 공간 재활용
   - 비교적 리소스 사용이 적고 데이터베이스 성능에 영향을 주지 않음
   - 조각화가 적은 경우 사용하는 것이 좋음

## 인덱스 힌트(Index Hint)란 무엇이며, 언제 사용하나요?
### 인덱스 힌트
- 오라클 옵티마이저에게 SQL문 실행을 위한 데이터를 스캔하는 경로, 조인 방법 등을 알려주기 위해 사용자가 SQL 구문에 작성 ⇒ 직접 최적의 실행 경로로 실행되도록 지시하는 구문
- 사용자가 특정 SQL문에서 어떤 인덱스가 선택도가 높은지 알 경우 훨씬 효율적으로 실행할 수 있기 때문에 사용
- 힌트 사용한 경우
    - 엑세스 경로
    - 조인 순서
    - 병렬 및 직렬 처리
    - 옵티마이저의 목표 변경 가능
    - 드라이빙 테이블이 원하는대로 선정
