## 데이터베이스란 무엇인가요?
### 데이터베이스
  - 전자적으로 저장되는 데이터 모음
  - 단어, 숫자, 이미지, 비디오, 파일 등을 포함한 모든 유형의 데이터 포함
  - 일반적으로 DBMS 라는 소프트웨어를 사용하여 데이터를 저장, 검색 및 편집 진행
  - 일반적인 유형의 데이터베이스에서 데이터는 처리 및 데이터 쿼리를 효율적으로 수행하기 위해 일련의 테이블에서 행열로 모델링 → 데이터에 쉽게 접근하고 관리, 수정, 제어 등이 가능해짐
  - 대부분의 데이터베이스는 데이터 작성, 쿼리에 SQL 사용
### DBMS
  - 데이터베이스 관리 시스템
  - 데이터베이스와 프로그램 간의 인터페이스 역할을 해서 사용자가 정보의 구성 및 최적화 방법을 검색, 관리할 수 있도록 도와줌
### SQL
  - Structed Qeury Language
  - 데이터를 쿼리, 조작, 정의하고 엑세스 제어를 제공하기 위해 거의 모든 관계형 데이터베이스에서 사용되는 프로그래밍 언어
### 데이터베이스 유형
  - 관계형 데이터베이스
      - 데이터베이스 항목은 열과 행이 있는 테이블 집합으로 구성
  - NoSQL 데이터베이스
      - 비정형 데이터를 저장하고 조작 가능
      - 애플리케이션의 복잡도가 증가함에 따라 사용량 상승
   
## RDBMS와 NoSQL의 차이점은 무엇인가요?
### RDBMS
  - 관계형 데이터베이스
  - 테이블 형식으로 데이터를 저장하고 SQL을 사용하여 데이터 관리
  - 데이터 무결성, 일관성 → 안정성 보장
  - 복잡한 쿼리 지원, 데이터 간의 관계 표현 쉬움
  - 대규모 데이터 처리, 스케일 아웃에 한계 존재 → 은행 등 안정성이 중요한 시스템에서 사용
  - MySQL, PostgreSQL, Oracle 등
### NoSQL
  - 비 관계형 데이터베이스
  - 키-밸류, 도큐먼트, 그래프 등 다양한 데이터 모델 지원, SQL 사용하지 않음
  - 빠른 응답 속도와 처리량, 높은 확장성 → 소셜 네티워크 서비스나 로그성 데이터 저장 시 사용
  - 수편정 확장 가능, 유연하게 데이터 모델 사용 가능
  - 데이터 일관성 보장 x, 데이터 중복 관리 필요
  - MongoDB, Redis 등

## SQL이란 무엇이며, SQL의 종류에는 무엇이 있나요?
### SQL
  - 구조적 쿼리 언어
  - 관계형 데이터베이스에 정보를 저장하고 처리하기 위한 프로그래밍 언어
  - 특징
    - 기본적으로 대소문자 구분 x
    - 명령은 세미콜론으로 끝남
    - 고유값은 따옴표를 사용
    - 객체를 나타낼 때에는 백틱 사용
### SQL 문법 종류
  - DDL: 각 테이블을 정의하기 위해 사용하는 언어 (CREATE, ALTER, DROP, …)
  - DML: 데이터 검색, 삽입, 변경, 삭제 등 관리를 위한 언어 (SELECT, INSERT, UPDATE, …)
  - DCL: 사용자별로 테이블 또는 데이터를 관리하고 접근하는 권한을 다루는 언어 (GRANT, REVOKE, …)

## 데이터베이스 스키마란 무엇인가요?
### 데이터베이스 스키마
  - 관계형 데이터베이스 내에 데이터가 구성되는 방식
  - 속성, 엔티티, 테이블, 엔티티 간의 관계를 포함한 제약 조건 등이 정의
### 스키마 종류
  - 외부 스키마 (User View)
      - 개별 사용자 또는 응용 프로그램이 데이터를 인식하고 상호 작용하는 방식 (실제 데이터를 어떻게 사용자에게 보여줄 것인지)
      - 각 프로그램은 특정 요구사항과 권한에 맞게 서로 다른 외부 스키마 가질 수 있음(여러개 존재 가능) → 전체 데이터베이스의 복잡성 감소
      - 전체 데이터 베이스의 한 논리적 부분 ⇒ 서브 스키마: 응용프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의
  - 개념 스키마 (Local View)
      - 물리적 스토리지, 구현 세부 정보와 관계 없이 데이터베이스에 있는 데이터의 전체 논리 구성
      - 데이터 베이스 파일에 저장되는 데이터 형태를 나타내어 DBA에 의해 구성
      - 외부 스키마와 내부 스키마 연결하는 역할을 하고 모든 프로그램에게 일관된 데이터 보기 제공
      - 데이터베이스 당 한개 존재
  - 내부 스키마 (Physical View)
      - 하드 디스크와 같은 스토리지 미디어에 있는 데이터의 실제 물리적 저장소 및 구성
      - 파일 구조, 인덱스 유무, 데이터 저장 형식 등의 세부 정보 포함
      - 데이터와 상호작용하는 애플리케이션으로부터 세부 정보 숨기고 데이터 저장, 엑세스 및 검색을 최적화하는 역할 → db 실행 속도에 큰 영향을 줌
      - 시스템 프로그래머나 시스템 설계자의 관점

> 데이터베이스 스키마와 인스턴스
> - 스키마는 전체적인 구조를 보여주는 역할, 실제 데이터 포함 x
> - 인스턴스는 데이터베이스의 데이터 샘플 (특정 시점의 스냅샷이기 때문에 변경될 수 있음)

## 테이블과 뷰(View)의 차이점은 무엇인가요?
### Table
  - 행열로 표현될 수 있는 실제 데이터 집합
### View
  - 데이터베이스에 있는 가상 테이블 (실제 데이터를 저장하지 않음)
  - 실제 데이터를 가지고 자주 사용하는 쿼리를 저장해놓고 쿼리를 실행 시켜 새로운 테이블처럼 보여줌 → 조회 가능, 삽입, 삭제 등은 제약 존재 (union, where 문의 조건 필요)
  - 복잡하고 긴 쿼리문을 뷰로 정의하여 접근을 단순화
  - 사용자에게 권한을 다르게 부여할 수 있기 때문에 보안 유지 가능

## 기본키(Primary Key)와 외래키(Foreign Key)의 차이점은 무엇인가요?
### 기본키
  - 테이블에 있는 유일하게 구분되는 키
  - 특징
      - 고유성
      - null 값 허용 불가
      - 일반적으로 숫자나 문자열
      - 테이블의 기본 정렬 기준
### 외래키
  - 한 테이블과 참조되는 다른 테이블 간의 연결되는 기본키 컬럼
  - 다른 기본키를 참조하는 속성, 속성의 집합을 의미
  - 특징
      - 무결성 유지
      - 한 테이블 내에서 외래 키 중복 가능
      - 삭제 및 업데이트 규칙 설정 가능
    
> - 슈퍼키: 각 데이터를 유일하게 식별할 수 있는 속성의 집합
> - 후보키: 각 데이터를 유일하게 식별할 수 있는 최소한의 속성 집합     
> 슈퍼키 > 후보키 > 기본키

## ACID란 무엇이며, 각각의 의미를 설명해주세요.
### ACID
데이터베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 특징
- 원자성: 트랜잭션 내에 실행되는 명령을 하나의 묶음으로 처리하여 내부에서 실행된 명령들이 전부 성공하거나 실패해야 한다는 특징, 여러개의 작접을 묶어 하나의 단위로 봄 → 결과 예측 가능
- 일관성: 트랜잭션 내부에서 처리되는 데이터의 일관성 유지, 에러가 발생해도 실패한 상태로 방치하지 않고 데이터의 상태를 일관되게 유지 → 트랜잭션 전후로 데이터베이스의 상태가 이전과 동일한 상태로 유지 (데이터베이스의 제약이나 규칙 만족해야함)
- 격리성: 트랜잭션 실행 중 다른 트랜잭션에 의해 데이터가 변경되는 것을 방지, 트랜잭션 중간 과정이나 결과를 볼 수 없음
- 지속성: 트랜잭션이 성공적으로 커밋된 후 해당 트랜잭션에 의해 생성, 수정된 데이터가 어떤 상황에서도 보존 → 기록이 영구적으로 저장

## 트랜잭션이란 무엇인가요?
### 트랜잭션
  - 데이터베이스의 상태를 변환시키는 기능을 수행하기 위한 하나 이상의 쿼리를 모아 놓은 하나의 작업 단위
  - 완전히 완료되거나 완전히 완료되지 않을 수 있고 시스템을 일관된 상태로 유지시켜줌

## 데이터베이스의 정규화(Normalization)란 무엇이며, 그 목적은 무엇인가요?
### 정규화
  - 테이블 간 중복된 데이터를 허용하지 않고 데이터 구조를 조직화하고 최적화하는 과정
  - 데이터 중복을 통해 효율성 향상, 무결성 보장
1. 제 1 정규화
  - 테이블의 컬럼이 하나의 데이터만 갖고 여러개의 값을 가지지 않도록 테이블 분해
2. 제 2 정규화
  - 제 1 정규화가 진행된 테이블에 대해 완전 함수 종속을 만족하도록 테이블 분해(복합키 중 하나의 컬럼이 다른 컬럼의 결정자일 경우 컬럼을 분해하여 별도로 관리 - 현재 테이블과 관련 없는 컬럼을 따로 빼는 방식)
  - 완전 함수 종속: 기본키의 부분집합이 결정자가 되지 않는 것 (↔ 부분 함수 종속성)
3. 제 3 정규화
  - 제 2 정규화가 진행된 테이블에 대해 이행적 종속 제거하도록 테이블 분해 (간접적인 종속성 제거)
  - 이행적 종속: A → B, B → C 일 때, A → C 성립
4. BCNF 정규화
  - 제 3 정규화가 진행된 테이블에 대해 모든 결정자가 후보키가 되도록 테이블 분해

## 역정규화(Denormalization)란 무엇이며, 언제 사용하나요?
- Join 연산이 많아질수록 쿼리를 처리하는 성능이 저하될 수 있음
- 무조건 정규화가 좋은 것이 아니라 데이터베이스의 전반적인 성능을 향상시킬 수 있도록 구조화하는 것이 좋음
- 정규화와 반대로 데이터의 중복을 허용하고 엔티티를 다시 통합하거나 분리하여 DB 구조를 재조정하는 과정 → 데이터베이스 비용 최소화

## INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN의 차이점은 무엇인가요?
1. (Inner) Join
    - 교집합 연산
    - 조인하는 테이블 데이터 중 공통적으로 존재하는 데이터만 조인해서 결과 데이터 집합 추출
1. Left (Outer) Join
    - 교집합 연산과 차집합 연산의 합집합 (기준이 되는 테이블은 변형이 없음)
    - 조인하는 테이블 데이터 중 공통적으로 존재하는 데이터와 조인하는 테이블에만 존재하는 데이터를 결과 데이터 집합을 추출
    - 데이터가 존재하지 않는 경우 null로 표시
1. Right (Outer) Join
    - 교집합 연산과 차집합 연산의 합집합 (join 테이블 기준)
1. Full Outer Join
    - 합집합 연산의 결과
    - 모든 결과 데이터 집합

* Outer Join
  - 교집합 + 해당하지 않는 값까지 조회
  - 기준이 되는 테이블 필요
 
## GROUP BY와 HAVING의 차이점은 무엇인가요?
### GROUP BY
원하는 데이터끼리 묶어서 처리할 때 사용
### HAVING
그룹에 대해 조건에 맞는 데이터만 뽑아 사용
- WHERE과의 차이: WHERE는 그룹핑이 진행 되기 전에 데이터를 필터링할 때 사용

## WHERE와 HAVING의 차이점은 무엇인가요?
### WHERE
  - 기본적인 조건절
  - 그룹화 진행 전 모든 필드를 조건으로 둠
### HAVING
  - group by 를 통해 그룹핑을 진행한 뒤 사용
  - 그룹화 진행 후 새로운 테이블에 조건 걸기

## DISTINCT 키워드는 무엇을 하는가요?
### DISTINCT
  - 데이터의 중복을 제거하기 위해 사용
  - SELECT와 함께 사용
  - 임시로 데이터를 저장하고 작업하는 방식으로 작동하기 때문에 추가적인 리소스를 사용하여 성능에 영향을 줄 수 있음

## 서브쿼리란 무엇이며, 서브쿼리의 종류에는 무엇이 있나요?
### 서브쿼리
- 다른 쿼리 내부에 포함되어 있는 SELECT 문
- 서브 쿼리를 포함하는 쿼리를 외부쿼리라고 함 ↔ 내부쿼리(서브쿼리)
- 실행 순서: 서브 쿼리 → 메인 쿼리
- 장점
  - 쿼리를 구조화하여 쿼리의 각 부분을 명확하게 구분 가능
  - 복잡한 Join, Union 보다 가독성이 좋고 비슷한 동작을 수행할 수 있음
- 종류
  - 단일행 서브쿼리
      - 단일행 비교 연산자와 함께 사용할 때는 서브쿼리의 결과가 2개 이상이 되면 안됨
  - 다중행 서브쿼리
      - 서브쿼리 결과가 2개 이상이 된다면 다중행 비교 연산자 사용(IN, ALL, ANY, …)
  - 다중 컬럼 서브쿼리
      - 서브쿼리 결과로 여러 개의 컬럼이 반환되어 메인 쿼리의 조건과 동시에 비교
  - 연관 서브쿼리
      - 서브 쿼리 내에 메인쿼리 컬럼이 사용된 서브쿼리
  - 중첩 서브쿼리
      - WHERE 문에 나타나는 서브쿼리
  - 인라인 뷰
      - FROM 문에 나타나는 서브쿼리
      - 무조건 별칭 지정 필요
  - 스칼라 서브쿼리
      - SELECT 문제 나타나는 서브쿼리
      - 다른 테이블에서 특정 값을 참조할 때 사용
   
## UNION과 UNION ALL의 차이점은 무엇인가요?
합집합 표현할 때 사용       
UNION은 중복을 제거하여 데이터 모두 검사 → 속도 저하 ↔ UNION ALL

## EXISTS와 IN의 차이점은 무엇인가요?
WHERE 절에서 데이터를 조건으로 필터링하기 위해 사용

### EXISTS 연산자
  - 특정 컬럼이 존재하는지 여부 확인 (서브쿼리만 사용 가능)
  - 존재 여부만 확인하고 다음 쿼리 진행 x - Select절 역할 x
  - 성능이 더 좋지만 대용량 데이터가 아닌 이상 큰 차이 없음
### IN 연산자
  - 특정 값 또는 서브쿼리 결과가 포함되는지 여부 확인
  - SELECT 절에서 조회한 컬럼 기준으로 비교
  - 쿼리순서: IN 쿼리 → 메인 쿼리

## COUNT, SUM, AVG, MIN, MAX 같은 집계 함수에 대해 설명해주세요.
### 집계함수
  - 데이터베이스에서 그룹 단위로 데이터를 집계하고 통계적인 값을 계산하기 위해 사용하는 함수 - 여러개의 행을 하나의 결과로 반환
  - SELECT 문에서만 사용 가능
  - 열끼리 연산 수행
1. COUNT: 행의 개수 계산, null 포함한 모든 행의 개수
2. SUM: 숫자 데이터의 합계 계산, null 값 제외
3. AVG: 숫자 데이터의 평균 계산, null 값 제외
4. MAX: 숫자나 문자열 데이터의 최대값 반환, null 값 제외
5. MIN: 숫자나 문자열 데이터의 최소값 반환, null 값 제외

## 데이터베이스에서 뷰(View)란 무엇이며, 장단점은 무엇인가요?
### 뷰
- 접근이 허용된 자료만 제한적으로 보여주기 위해 기본 테이블로부터 생성하는 가상의 테이블
- 물리적으로 저장 장치 내에 저장하지 않음
- 조인문의 사용이 최소화되어 쉽게 사용 가능
- 필요한 데이터만 뷰로 정의해서 처리할 수 있기 때문에 관리 용이하고 명령문 간단해짐
- 참조되는 기본 테이블이나 뷰가 삭제되면 참조한 다른 뷰도 자동으로 제거
- 장점
    - 논리적 데이터 독립성 제공
    - 동일 데이터에 대해 사용자마다 다르게 사용할 수 있음
    - 간단한 데이터 관리
    - 접근 제어를 통해 보안관리
- 단점
    - 독립적인 인덱스 x
    - 뷰의 정의를 변경할 수 없음
    - 삽입, 삭제, 갱신 등에 제약이 있음
 
## CASE문을 사용하여 조건부로 데이터를 조회하는 방법을 설명해주세요.
CASE 문은 조건에 따라 서로 다른 값 반환
1. IF
```sql
CASE WHEN A = 1 THEN "1"
     WHEN A = 2 THEN "2"
     ELSE "3"
END AS ""
```
    
2. SWITCH
```sql
CASE A
     WHEN 1 THEN "1"
     WHEN 2 THEN "2"
     ELSE "3"
END AS ""
```

## 인덱스란 무엇인가요?
- 데이터베이스의 검색 성능 최적화를 위한 도구(자료구조)
- 데이터의 위치와 데이터가 포함된 자료구조를 생성하여 데이터 검색 속도 향상
- 인덱스를 사용하지 않고 WHERE 절과 함께 SELECT를 사용하게 되면 모든 테이블을 조회한 후 조건에 충족하는 데이터 반환 → 데이터 개수가 많아지고 조회 횟수가 늘어날 경우 성능 저하 발생 가능
- 마지막으로 확인해야 하는 위치만 알면 전체 데이터 확인하지 않아도 됨 → 자주 조회하는 컬럼에 인덱스를 걸어 검색 연산 최적화

## 클러스터드 인덱스(Clustered Index)와 넌클러스터드 인덱스(Non-clustered Index)의 차이점은 무엇인가요?
### 클러스터드 인덱스
- 리프 노드에서 인덱스는 항상 정렬을 유지하고, 실제 데이터를 함께 저장(실제 데이터를 인덱스 기준으로 항상 정렬)
- 인덱스로 가장 적합한 컬럼 하나를 클러스터 인덱스로 지정 (주로 PK)
- 항상 정렬된 상태이기 때문에 검색 속도가 빠르지만 삽입, 삭제, 수정이 일어날 때 마다 정렬이 필요하여 속도 저하
- 테이블당 하나만 생성 가능(PK 또는 유니크하고 null이 아닌 컬럼)

### 넌클러스터드 인덱스
- 인덱스 페이지를 별도로 관리, 실제 데이터와는 분리되어 있음(실제 데이터는 정렬 x)
- 리프 노드에서 인덱스는 데이터의 주소값을 저장하고 있고 주소값을 통해 실제 데이터 호출
- 삽입, 삭제, 수정 연산이 빠르지만 검색 속도는 클러스터드 인덱스보다 느림
- 여러개의 인덱스 생성 가능

## 인덱스를 언제 사용하는 것이 적합한가요?
- 삽입, 수정, 삭제가 자주 일어나지 않는 컬럼
- where, join 등 조건문에 자주 사용되는 컬럼

## 인덱스 사용이 성능에 미치는 영향은 무엇인가요?
- 인덱스 테이블: 하나의 테이블을 생성하여 값을 지정 후 사용(인덱스 생성을 위해 추가 공간 필요) → 다른 테이블에 의존적인 새로운 테이블이 하나 생성되기 때문에 인덱스를 많이 생성하면 성능 저하 초래 가능
- 정렬: 이진트리 검색을 사용하기 때문에 기본적으로 정렬 되어 있는데 생성, 수정, 삭제가 자주 발생하게 되면 전체적인 성능 저하 초래 가능

## 인덱스의 구조는 무엇인가요? (예: B-Tree)
1. 해시 테이블
   - key-value 형태로 데이터 저장
   - key를 통해 값에 바로 접근하기 때문에 검색 시 O(1) 시간 복잡도
   - key를 해시 함수를 사용하여 해시 값으로 변환한 후, 해당 해시 값에 해당하는 값을 찾아 검색
   - 등호 연산에는 빠르지만 부등호 연산에는 적합하지 않음(정렬 되어 있지 않기 때문에)
2. B-tree
   - 한 노드에 여러 개의 값 가능, 자식 노드 2개 이상 가능
   - 노드 내 데이터는 정렬된 상태 유지
   - 속도가 빠르고 어떤 값이든 동일한 시간으로 결과 얻기 가능 (균일성), O(logn) 시간 복잡도
   - 균형트리
      - 루트로부터 리프까지의 거리가 일정한 구조(트리 중 성능 안정화)
      - 첫 생성 시에는 균형 트리이지만 삽입, 수정, 삭제가 반복되면서 균형이 무너지고 성능에 영향을 줌
   - 노드에 저장된 값 사이의 포인터를 통해 탐색
3. B+tree
   - B-tree의 확장 개념
   - 실제 데이터는 리프 노드에만 저장(인터널 노드는 key만 가지고 있음)
   - 리프 노드끼리 링크드 리스트로 연결
   - 중복키를 가짐
      - 리프 노드 외에는 data를 저장하지 않기 때문에 메모리 확보 가능 (트리의 높이가 낮아지기 때문에 검색 속도 향상)
      - B-tree 처럼 모든 노드를 확인하지 않고 한번의 선형 탐색을 통해 리프 노드만 확인하면 되기 때문에 검색 속도 빠름
        
## 인덱스를 너무 많이 만들면 성능에 어떤 영향이 있나요?
1. 저장 공간과 성능 비용
    - 추가적인 공간이 필요하기 때문에 데이터베이스 용량 증가
    - 데이터 삽입, 수정, 삭제 시 인덱스 갱신 필요
2. 인덱스를 관리 및 유지 비용

## Composite Index(복합 인덱스)란 무엇인가요?
- 두 개 이상의 컬럼을 포함하는 인덱스
- 여러 컬럼을 동시에 필터링하거나 정렬할 때 유용, 쿼리 성능 향상
- 인덱스 컬럼을 순차적으로 검색하기 때문에 컬럼의 순서가 중요함(가장 자주 사용되는 컬럼을 인덱스 첫번째 컬럼으로 지정하는 것이 좋음)
- B-tree 구조를 사용하여 데이터 저장 - 첫번째 컬럼을 기준으로 정렬된 후 그 다음 컬럼으로 정렬
- 인덱스 생성, 관리 시에는 비용이 많이 발생하기 때문에 필요한 경우에만 생성하여 성능 최적화하는 것이 중요
- 쿼리를 최적화하고 검색 속도 개선 가능
- where, join, order by 에서 자주 사용되는 컬럼을 인덱스로 사용하는 것이 좋음

## 인덱스 설계 시 주의해야 할 점은 무엇인가요?
- 자주 조회하는 유니크한 컬럼 위주로 설계 (중복 개수가 적을수록 좋음)
- 많이 생성하지 않도록 주의 (일반적으로 한 테이블에 3-4개를 권장)
- when, join, order by 등 조건문에서 자주 사용되는 컬럼 사용
- 정수형 자료형이 인덱스 생성시 가장 효율적

## 데이터베이스에서 인덱스의 재구성(Rebuild)과 재구성하지 않음(Reorganize)은 무엇이 다른가요?
- 조각화: 데이터베이스에서 인덱스 내부의 데이터 페이지가 물리적으로 분산되어 저장되는 현상
    - 내부 조각화: 인덱스 페이지 내에서 데이터 추가나 삭제 등으로 인해 빈 공간 발생하는 경우 페이지 읽는 데에 많은 시간 소요
    - 외부 조각화: 인덱스 페이지 간의 물리적 공간이 분산되는 경우 → 인덱스 페이지들이 서로 떨어져서 저장되는 경우 해당 인덱스의 검색 작업은 여러 디스크를 참조하기 때문에 성능 저하 초래
### 인덱스 리빌드 Rebuild
   - 인덱스를 완전히 새롭게 재생성 (기존 인덱스를 제거하고 새로운 인덱스를 생성하여 데이터 정렬
   - 리소스 많이 사용하고 데이터베이스 성능에 영향을 준다.
   - 인덱스 조각화가 심한 경우에 사용하는 것이 좋음
### 인덱스 리오거나이즈 Reorganize
   - 인덱스의 논리적 조각화를 줄이기 위해 인덱스 페이지 재구성
   - 기존 인덱스를 유지하면서 페이지를 정렬하고 공간 재활용
   - 비교적 리소스 사용이 적고 데이터베이스 성능에 영향을 주지 않음
   - 조각화가 적은 경우 사용하는 것이 좋음

## 인덱스 힌트(Index Hint)란 무엇이며, 언제 사용하나요?
### 인덱스 힌트
- 오라클 옵티마이저에게 SQL문 실행을 위한 데이터를 스캔하는 경로, 조인 방법 등을 알려주기 위해 사용자가 SQL 구문에 작성 ⇒ 직접 최적의 실행 경로로 실행되도록 지시하는 구문
- 사용자가 특정 SQL문에서 어떤 인덱스가 선택도가 높은지 알 경우 훨씬 효율적으로 실행할 수 있기 때문에 사용
- 힌트 사용한 경우
    - 엑세스 경로
    - 조인 순서
    - 병렬 및 직렬 처리
    - 옵티마이저의 목표 변경 가능
    - 드라이빙 테이블이 원하는대로 선정

## 트랜잭션의 고립 수준(Isolation Level)에 대해 설명해주세요.
### 트랜잭션 고립 수준
- 여러 트랜잭션 수행 중 어떤 트랜잭션이 다른 트랜잭션에서 사용 중인 데이터를 조회할 수 있는 범위
- 고립수준이 높을수록 일관성은 보장되지만 동시성이 떨어져 성능이 하락할 수 있음

1. Read uncommitted
   - 각 트랜잭션에서의 변경 내용이 commit, rollback 여부에 상관없이 다른 트랙잭션에서 값을 읽을 수 있는 상태
   - 정합성이 떨어지기 때문에 사용하지 않는 것이 좋다
   - dirty read, non repeatable read, phantom read 모두 발생 가능
2. Read committed
   - 트랜잭션 수행이 완료되고 commit된 데이터만 다른 트랜잭션에서 읽을 수 있도록 허용한 상태
   - dirty read 문제는 발생하지 않지만 commit 되기 전 후 요청한 결과가 다르게 오기 때문에 부정합 문제 발생 → non repeatable read 문제, phantom read 문제 발생
3. Repeatable read
   - 어떤 트랜잭션에서 읽고 있는 데이터는 다른 트랜잭션에서 수정, 삭제 불가하지만 삽입은 가능한 수준
   - 자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서 변경된 것만 읽고 높은 트랙잭션에서 변경된 것은 언두 영역에 백업된 레코드를 읽음
   - 레코드 추가는 막지 않기 때문에 트랜잭션이 끝나기 전에 다른 트랜잭션에서 추가한 레코드를 발견할 수 도 있는데 이때 phantom read 문제 발생 가능
   - non repeatble read 문제는 발생하지 않지만 추가된 레코드로 인해 전체 데이터 개수에 변화 발생 → phantom read 문제 발생
4. Serializable
   - 가장 엄격한 수준
   - 모든 트랜잭션이 순차적으로 진행되기 때문에 부정합 문제가 발생하지는 않지만 동시성이 떨어져 성능에 문제가 생김
   - 어떤 트랜잭션에서 읽고 있는 데이터는 다른 트랜잭션에서 수정, 삭제, 삽입 불가

## Dirty Read, Non-repeatable Read, Phantom Read에 대해 설명해주세요.
### Dirty Read
   - 트랜잭션A에 의해 데이터가 수정되었고 commit 되기 전에 트랜잭션B에서 데이터 읽을 때 발생하는 현상
   - 읽은 데이터가 커밋되지 않고 롤백될 경우 문제 발생
   - Read uncommitted 에서 발생
### Non-Repeatable Read
   - 한 트랜잭션에서 같은 데이터를 읽었는데 다른 결과를 받는 현상(값이 달라짐)
   - 트랜잭션A가 데이터를 처음 읽을 때 1이 반환되었고 그 후 에 트랜잭션B에 의해 데이터가 2로 변경되고 트랜잭션A가 두번째로 데이터를 읽을 때에는 처음 읽을 때와 다른 데이터를 받게 됨
   - Read uncommitted, Read Committed 에서 발생
### Phantom Read
   - 한 트랜잭션에서 같은 조건으로 데이터를 읽었는데 결과가 다름(데이터가 추가됨)
   - 트랜잭션A가 처음 데이터를 읽을 때에는 조건에 부합하는 데이터가 1개 였는데 트랜잭션B가 데이터를 추가 → 그 후에 읽을 때에 데이터 2개 반환
   - Read uncommitted, Read Committed, Repeatable Read 에서 발생

## 트랜잭션의 전파(Propagation)에 대해 설명해주세요.
### 트랜잭션 전파
이미 트랜잭션이 진행 중일 때 다른 트랜잭션 진행을 어떻게 할지 결정하는 것

1. REQUIERED
   - 기존 트랜잭션이 존재할 경우 트랜잭션에 참여, 없으면 새로 생성
   - 내부 트랜잭션의 커밋과 롤백은 바로 반영되지 않고 외부 트랜잭션이 커밋, 롤백될 때 함께 반영
1. REQUIRES_NEW
   - 기존 트랜잭션 존재 여부와 상관없이 새로운 트랜잭션 생성
   - 새로운 트랜잭션이 종료될 때 까지 기존 트랜잭션은 대기
1. SUPPORTS
   - 기존 트랜잭션이 있으면 참여, 없으면 트랜잭션 적용 x
1. NOT_SUPPORTS
   - 기존 트랜잭션을 대기 시키고 트랜잭션 없이 실행
1. MANDATORY
   - 기존 트랜잭션이 있으면 참여하고 없으면 예외 발생
1. NEVER
   - 트랜잭션이 적용되면 안되는 경우
1. NESTED
   - 새로운 트랜잭션을 생성하지만 기존 트랜잭션의 커밋, 롤백에 영향을 받음 ↔ 반대로 영향을 주지는 않음

## 낙관적 잠금(Optimistic Locking)과 비관적 잠금(Pessimistic Locking)의 차이점은 무엇인가요?
동시성 문제를 해결하기 위한 잠금 모델

### 비관적 잠금
   - 한 트랜잭션이 데이터를 읽을동안 락을 걸어서 사용이 완료되기 전에 다른 트랜잭션이 접근할 수 없도록 설정
   - 트랜잭션의 동시 접근을 확실하게 방지할 수 있지만 동시성이 떨어져서 대기 시간이 길어질 경우 성능에 영향을 줌, 데드락 문제 발생 가능
### 낙관적 잠금
   - 따로 락을 걸지 않고, 데이터를 변경하려고 하는 시점에 변경 가능 여부를 확인하는 방식
   - 한 트랜잭션에서 데이터를 사용한 후 다른 트랜잭션에서 사용하려 할 때 알고 있던 데이터와 동일한 경우에만 접근 가능
   - 읽을 때 잠금을 설정하지 않기 때문에 성능은 좋지만 동시 작업이 발생하여 다른 트랜잭션의 작업이 거부되는 경우에 대해 오류 처리를 하거나 재시도를 해야 함

## 트랜잭션에서 발생할 수 있는 동시성 문제에는 어떤 것들이 있나요?
- Lost Update (갱신 손실)
   - 두개 이상의 트랜잭션이 동일한 데이터를 갱신할 때, 다른 트랜잭션에서 갱신할 내용을 다른 트랜잭션이 덮어써서 갱신이 무효화되는 것
- dirty read
   - 어떤 트랜잭션이 데이터를 갱신하고 있는 도중에 다른 트랜잭션이 데이터를 조회하며 발생하는 문제
   - 커밋되지 않고 롤백된다면 무효화된 데이터를 읽기 때문에 문제가 됨
- Incosistencty (모순성)
   - 다른 트랜잭션에서 갱신하고 있는 데이터를 읽어 트랙잭션 수행 완료 전후로 데이터가 달라 발생하는 문제
- Cascading Rollback
   - 어떤 트랜잭션이 데이터 갱신을 실패하여 롤백하는 도중에 다른 트랜잭션에서 데이터를 읽어 사용할 때 발생하는 문제

## Deadlock이란 무엇이며, 이를 방지하는 방법은 무엇인가요?
### 데드락(교착상태)
  - 두 개 이상의 프로세스가 서로의 작업이 끝날 때까지 무한정 대기하는 현상
  - 트랜잭션의 동시성을 제어하기 위해 잠금을 사용하면 데드락 문제 발생 가능
  - 데드락 발생 조건
      - 상호 배제: 한 리소스를 한 프로세스만 사용 가능, 동시에 사용 불가
      - 점유와 대기: 자원을 최소 하나 보유하고 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스 존재
      - 비선점: 이미 할당된 자원을 뺏을 수 없음, 다른 프로세스의 작업이 끝난 후 자발적으로 반환하기 전까지 대기해야 함
      - 순환 대기: 대기 프로세스의 집합이 순환 형태로 자원 대기
### 해결방법
  - 예방
     - 트랜잭션 실행 전 데이터를 모두 잠금 → 데이터가 많을 경우 병행성이 떨어짐
  - 회피
     - 자원 할당시에 타임 스탬프를 적용하여 데드락 회피
     - Wait-Die 방식: 다른 트랜잭션이 데이터를 사용할 때 기다리거나 포기하는 방식으로 오래된 프로세스에게는 대기할 기회를 주고 최신 프로세스는 포기하도록 함 → 복귀 횟수가 많아지기 때문에 오버헤드 발생 가능
     - Wound-Wait 방식: 다른 트랜잭션이 데이터를 사용할 때 뺏거나 기다리는 방식으로 오래된 프로세스에게는 선점의 기회를 주고 최신 프로세스는 대기하여 복귀 최소화
  - 탐지하여 회복
     - 데드락이 발생했는지 점검하고 데드락 상태에 있는 자원 발견 → 프로세스를 종료하거나 프로세스에 할당된 자원을 선점하여 회복
  - 낙관적 병행 제어
     - 트랜잭션이 수행되는 동안 검사를 하지 않고 트랜잭션 커밋 후에 데이터에 문제가 있다면 롤백
  - 빈도 줄이기
     - 트랙잭션을 자주 커밋
     - 읽기 잠금의 사용을 줄임
     - 정해진 순서로 테이블에 접근

## 트랜잭션 로그(Transaction Log)란 무엇인가요?
### 트랜잭션 로그
- 데이터베이스에 수행되는 모든 변경 작업에 대한 기록을 갖는 파일 또는 메모리
- 로그를 통해 장애 복구, 롤백, 데이터베이스 복원 등의 기능 수행
- 데이터의 무결성, 내구성을 보장하고 시스템을 안정적으로 운영할 수 있는 핵심적인 역할
- 기능
    - 장애 복구: 시스템 장애 발생시 데이터베이스를 이전 상태로 되돌림
    - 롤백: 트랙잭션을 취소하거나 오류 발생시 이전 상태로 롤백
    - 복제: 데이터베이스 변경사항을 다른 데이터베이스로 복제
    - 복원: 데이터베이스 손상되거나 삭제된 경우 이전 상태로 복원
    - 성능 향상: 변경사항을 일시적으로 기록하고 일전 시점에 도달하면 한번에 데이터를 반영하여 데이터베이스 성능 향상

## 데이터베이스 커밋과 롤백의 차이점은 무엇인가요?
### 커밋
   - 작업을 정상적으로 처리하겠다는 명령어
   - 트랜잭션의 처리 과정을 데이터베이스에 반영하기 위해 변경된 내용을 모두 영구 저장
   - 커밋 수행하면 하나의 트랜잭션 과정이 종료
   - 트랜잭션 내용을 실제 db에 저장하고 이전 데이터가 업데이트됨
   - 모든 사용자가 변경된 데이터 결과 확인 가능
### 롤백
   - 작업 중 문제 발생시 트랜잭션의 처리 과정에서 발생한 변경사항을 취소하고 트랜잭션 종료
   - 트랜잭션 실행 이전의 상태로 되돌림

## 트랜잭션 타임아웃이란 무엇인가요?
트랜잭션이 timeout에 설정한 시간 내에 완료되어야 하고 그렇지 않으면 트랜잭션 롤백 되고 트랜잭션 예외 발생

> Spring에서는 @Transactional(timeout = 10) 과 같이 정의할 수 있고 ms 단위

## 분산 트랜잭션이란 무엇이며, 이를 관리하는 방법은 무엇인가요?
### 분산 트랜잭션
- 독립된 여러 데이터베이스에 동시에 접근하는 트랜잭션, 분리된 데이터베이스에서 동작하지만 하나의 작업인 것처럼 동작해야 함
- ACID를 만족해야 함

### 관리방법
1. Two-Phase Commit (2PC)
   - 코디네이터(트랜잭션 매니저)라는 컴포넌트를 사용하여 트랜잭션을 요청하는 같은 어플리케이션 프로세스 내 라이브러리에 구현되어 있거나 분리된 서비스일 수 있음
   - 투표 단계: 애플리케이션이 커밋할 준비가 되면 코디네이터는 phase 1을 시작하여 각 노드에 커밋할 수 있는지 확인하고 응답을 추적
   - 커밋 단계: 모든 노드가 yes라고 하면 phase2로 넘어가서 커밋을 수행 ↔ 하나라도 no라고 한다면 phase2로 넘어가 abort 요청 보냄
   - 모든 서비스에 커밋 요청을 보내더라고 도착시간이 달라 완벽하게 동시에 처리된다고 보장할 수 는 없음
   - 문제점
      1. 시스템의 대기 시간이 길어지고 응답시간의 증가를 초래
      2. 코디네이터를 기반으로 강력한 결합을 유도 -> msa 에 완벽 적용하기 힘듬
2. Saga pattern
   - 마이크로 서비스에서 데이터의 일관성 관리
   - 각 서비스는 각각의 데이터베이스로 로컬 트랜잭션을 가지고 있고 해당 서비스의 데이터를 업데이트하면 그와 관련된 이벤트가 발생되어 다음 단계의 서비스에서 트랜잭션 수행 ↔ 만약 특정 서비스에서 수행 실패한다면 데이터의 정합성을 보장하기 위해 이전 트랜잭션에 대한 보상 트랜잭션(역으로 실행해서 취소 처리하는 트랜잭션) 수행
   - 종류 2가지
      1. Choreography based SAGA pattern
          - 보유한 서비스 내의 로컬 트랜잭션을 관리하고 트랜잭션이 종료되면 완료 이벤트 발생
          - 서비스끼리 직접 통신하지 않고 이벤트 발행, 구독을 통해 통신
          - 구성하기는 편하지만 트랜잭션의 현재 상태 확인 어려움
      1. Orchestration based SAGA pattern
          - 트랜잭션 처리를 위한 saga 인스턴스(매니저) 별도로 존재
          - 트랜잭션에 관련된 내용을 매니저에 전달하고 마지막 트랜잭션이 끝나면 매니저를 종료해서 전체적인 트랜잭션 종료 → 중간에 실패가 발생하면 매니저에서 보상 트랜잭션을 발동하여 일관성 유지
          - 중앙에서 컨트롤하고 복잡성을 줄지만 오케스트레이터 서비스가 추가되어 과도하게 많은 비즈니스 로직이 오케스트레이터 안에 들어갈 위험이 있음 -> 오케스트레이터가 오퍼레이션의 순서에 대해서만 책임지고 비즈니스 로직을 포함하지 않도록 설계 해야 함
