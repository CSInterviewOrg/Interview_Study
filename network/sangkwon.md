## 네트워크

### 네트워크에서 서버와 클라이언트는 각각 어떤 역할을 하나요?
- 클라이언트
    - 서버에게 어떠한 작업을 요청하고 작업 결과를 반환 받는 역할
- 서버
    - 클라이언트에게 요청 받은 작업을 완료하고 작업 결과를 반환하는 역할
- 클라이언트-서버 모델의 특징
    - 요청-응답 구조, 해당 모델에서 통신 구조는 항상 요청-응답 구조인 형태
    - 다중 요청에 대해서 동시적으로 처리할 수 있는 모델 구조

### HTTP와 HTTPS의 차이점은 무엇인가요?
- HTTP(HyperText Transfer Protocol)
    - 웹 브라우저와 웹 서버간의 자원을 주고 받는 프로토콜
    - 암호화 되지 않은 평문으로 데이터가 주고받을 수 있기에 보안 측면에서 취약한 프로토콜
    - Port Number: 80
- HTTPS (HyperText Transfer Protocol Secure)
    - HTTP에 **SSL/TLS 암호화** 기술을 추가하여 보안성을 높인 프로토콜
    - 클라이언트(웹 브라우저)와 서버 간의 모든 통신이 암호화 되어 통신이 진행
    - Port Number: 443
- SSL과 TLS
    - SSL(Secure Sockets Layer)은 웹 브라우저와 웹 서버 간의 통신 시 데이터를 암호화하는 프로토콜
    - TLS(Transport Layer Security)은 SSL에서의 보안 취약점과 암호화 알고리즘이 강화된 프로토콜
- HTTPS에서의 SSL, TLS 동작 과정
    1. Client Hello 진행(클라이언트에서 자신이 사용하는 암호화 방식, 정보 제공)
    2. Server Hello 진행(클라이언트가 보내준 정보를 참고하여 서버 측에서 사용하는 암호화 방식 및 CA 인증서 응답)
    3. 서버 인증서 확인(클라이언트 측에서 서버가 보내준 CA 인증서 리스트 확인)
    4. 클라이언트 측에서 서버 CA 인증서를 기반으로 대칭 키 교환
    5. 대칭 키를 통해 암호화된 데이터 송수신

### TCP와 UDP의 차이점은 무엇인가요?
- TCP
    - 신뢰성 기반 프로토콜
    - 데이터를 송수신 하기 전에 미리 연결을 하고 진행하기에 연결 지향적
    - 데이터가 손실 되지 않고 데이터 수신의 순서성을 보장
    - 이처럼 신뢰성 기반을 보장하기에 UDP에 비해 오버헤드가 높고 속도가 느림
- UDP
    - 비 신뢰성 기반 프로토콜
    - 통신 전 클라이언트와 서버간의 연결 과정 없이 데이터를 보냄
    - 데이터의 오류 검사나 재전송을 진행하지 않음
    - 패킷의 수신 순서성 보장하지 않음
    - 이처럼 신뢰성을 보장하는 작업이 없기에 데이터 송수신 속도가 빠름

### IP 주소란 무엇이며, 어떻게 분류되나요?
- IP
    - Internet Protocol Address는 인터넷에 존재하는 컴퓨터의 고유 번호를 나타내는 것
    - IPv4: 32 비트의 IP 주소 체계, ex) 192.0.0.1
    - IPv4: 128 비트의 IP 주소 체계, ex) 2001:0db8:85a3:0000:0000:8a2e:0370:7334
- IP 주소 Class
    - Class A: 최상위 비트가 0인 IP 주소 목록을 Class A로 지칭, 가장 많은 호스트 수를 차지함
    - Class B: 최상위 비트가 1인 IP 주소 목록을 Class B로 지칭
    - Class C: 최상위 비트가 11인 IP 주소 목록을 Class C로 지칭
    - Class D: 최상위 비트가 111인 IP 주소 목록을 Class D로 지칭
    - Class E: 최상위 비트가 1111인 IP 주소 목록을 Class E로 지칭

### OSI 7계층 모델을 설명해주세요.
7. Application Layer(응용 계층)
- 역할: 사용자와 직접적으로 상호작용 하는 계층이며 응용 프로그램을 운영체제에 종속 시킴(OSI 7 Layer에서는 네트워크 송수신을 진행할 때 운영 체제의 네트워크 스택을 이용하기에 응용 프로그램을 OS에 종속 시켜야 함)
- 프로토콜: HTTP, FTP, SMTP, SSH …

6. Presentation Layer(표현 계층)
- 역할: 응용 계층으로부터 전달 받은 데이터를 수신 측에서 받을 수 있는 데이터 형식으로 변환하거나 데이터를 압축하고 암호화 함
- 프로토콜: JPEG, MPEG, SSL, TLS

5. Session Layer(세션 계층)
- 역할: 통신을 위한 세션에 대해서 연결하거나 해제하는 등의 세션 관리를 진행
- 프로토콜: NetBIOS, RPC, NFS

4. Transport Layer(전송 계층)
- 역할: 데이터를 세그먼트 형식으로 나눈 후에, 송신 순서나 오류 검사 등의 처리를 진행하며 TCP/UDP에 대한 프로토콜 결정
- 프로토콜: TCP, UDP

3. Network Layer(네트워크 계층)
- 역할: 패킷이 생성되며, IP 주소를 사용하여 데이터를 목적지까지 전달하는 경로를 설정
- 프로토콜: IP, ICMP, ARP, RARP

2. Data Link Layer(데이터 링크 계층)
- 역할: 패킷을 프레임 형식으로 변환하며 MAC 주소를 통해 데이터 링크를 설정합니다. 이 단계에서는 오류 검출과 수정 또한 진행
    - MAC 주소란 네트워크 장치(컴퓨터, 스마트폰 ..)에 존재하는 네트워크 인터페이스 카드(NIC)에 존재하는 고유 번호로 IP에서 존재하는 특정 장치에 라우팅 하기 위한 주소를 의미
- 프로토콜: Ethernet, Token Ring, FDDI, HDLC

1. Physical Layer(물리 계층)
- 역할: 데이터는 실제 전기적 신호로 변환되어 네트워크 매체를 통해 전송하는 역할, 실질적으로 네트워크의 물리적인 통신은 물리 계층에서 진행
- 프로토콜: RS-232C, V.35, Ethernet, FDDI

### TCP/IP 모델을 OSI 모델과 비교하여 설명해주세요.
- TCP/IP 모델
    - 4 Layer 형식으로 구성 됨(Presentation Layer와 Session Layer의 기능을 Application Layer에 통합, Data Link Layer와 Physical Layer를 Network Access Layer에 통합시킨 구조)
    - Application Layer / Transport Layer / Internet Layer / Network Access Layer(네트워크 인터페이스 계층)
    - OSI는 네트워크 통신에 대한 계층을 이론적으로 표현하기에 적합한 모델이고 실질적인 네트워크 통신 시 사용되는 모델은 TCP/IP 4 Layer Model을 주로 사용

### DNS의 역할은 무엇이며, 작동 방식은 어떻게 되나요?
- DNS는 도메인 이름을 IP 주소로 변환해주는 시스템을 말함, IP 주소는 사람이 기억하기 어렵기에 도메인 네임을 사용하는데 실제로 네트워크 통신 시 사용 되는 것은 IP 주소이기에 이를 변환해야 함, 또한 하나의 도메인 이름에 여러 IP 주소가 매핑 되어 있는 경우 로드 밸런싱을 지원하기도 함
- 작동 방식
    1. 사용자가 입력한 도메인 이름에 대해서 DNS 리졸버가 캐시에서 IP 주소가 있는지 확인
    2. 없는 경우 **Root DNS 서버** → **TLD DNS 서버** → **Authoritative DNS 서버**를 차례로 조회
    3. 조회한 IP 주소를 도메인 리졸버가 사용자에게 반환
    - Root DNS 서버: 최상위의 DNS 서버로, 전체 DNS 계층 구조의 시작점, www.naver.com인 경우 .com과 같은 TLD에 대한 정보만을 가지고 있는 서버
    - TLD(Top-Level Domain) DNS 서버: 풀 도메인 네임(naver.com)에 대한 정보에 대한 권한을 가지고 있는 Authenctication DNS 서버의 위치 주소를 가지고 있는 서버
    - Authoritative DNS 서버: 실제로 www.naver.com의 IP 주소를 가지고 있는 서버로써 이 IP 주소를 DNS 리졸버에게 반환하는 서버

### ARP(주소 결정 프로토콜)란 무엇이며, 어떻게 작동하나요?
- ARP(주소 결정 프로토콜)
    - 네트워크에서 IP 주소를 물리적 주소(MAC 주소)로 변환해주는 프로토콜
    - IP 주소를 통하여 네트워크 라우팅 → 로컬 네트워크에서 MAC 주소 확인 → IP와 MAC 주소를 통하여 실제 네트워크 장치의 위치 확인
- 작동 방식(Host A → Host B로 데이터 전송 하는 것을 전제로 함)
    
    1. ARP 요청
    - Host A가 Host B의 IP에 있는 모든 Host에게 Broad Cast 방식으로 MAC 주소 요청
      
    2. ARP 응답
    - 자신의 IP에 해당하는 Host가 MAC 주소를 Unicast 방식으로 반환
    
    3. ARP 캐시 저장
    - 호스트 A는 ARP 응답 값을 캐시에 일정 시간 저장한 후 동일한 IP 요청이 오면 ARP 요청을 진행하지 않고 ARP 캐시에서 조회

### NAT(Network Address Translation)란 무엇인가요?
- **사설 IP 주소**와 **공용 IP 주소** 간의 변환하는 기술
- 여러 개의 사설 IP가 하나의 공용 IP로 매핑 될 때 아웃바운드 또는 인바운드 통신이 진행될 때 적절하게 IP 주소를 변경해줌 → 사설 IP를 외부에 노출시키지 않아서 외부로부터의 직접적인 통신을 막아줘 보안적인 측면에서 이점이 있음

### 네트워크에서 CORS(Cross-Origin Resource Sharing)는 무엇인가요?
- **CORS**란 Cross-Origin Resource Sharing의 약자이며 **교차 출처 자원 공유**를 뜻합니다.
- 이는 어떠한 출처에서 Application을 실행할 때 다른 출처의 리소스에 **접근할 수 있는 권한을 
부여**하는 체제(기법)을 의미합니다.
- 여기서 다른 출처라는 기준은 기존의 출처와 프로토콜, 도메인, 포트번호 등등이 다를 경우 다른 출처(Cross-Origin)가 됩니다.
    - 반대로 같은 출처는 Same-Origin으로 불립니다.
- 일반적으로 브라우저에서는 다른 출처간의 통신(요청)을 제한하기에 CORS를 통해 이러한 
제한을 풀고 통신을 진행합니다.
    - 하지만 다른 출처간의 통신이 어떠한 조건 없이 진행된다면 사용자 공격에 매우 취약합니다.
    - 그렇기에 CORS를 통한 통신은 추가 HTTP Header를 이용하여 진행합니다.
- 이러한 CORS를 통한 **요청 정책**은 크게 3가지가 존재합니다.
    
    1) **Simple Request(단순요청)**
    - 브라우저는 자신의 주소를 origin이라는 헤더에 담아서 요청을 보냅니다.
    - 서버는 해당 요청을 확인하고 브라우저의 주소에 접근이 가능하다는 access-control-allow-origin 헤더에 브라우저의 주소를 반환합니다.
    - 결과적으로 access-control-allow-origin 헤더에 포함된 값으로 통신이 진행될지 결정합니다.
        - 예를 들어 서버가 헤더에 값을 넣지 않거나 헤더의 값이 브라우저의 주소가 아닌 경우 
        통신은 진행되지 않습니다.
    
    2) **Preflight Request(프리 플라이트)**
    - 이 정책은 HTTP 요청을 미리 보내 실제 요청이 안전한지 확인하는 정책입니다.
    - HTTP 메서드 중 하나인 **OPTIONS** 메서드를 이용하며 origin 헤더에 자신의 주소를 미리 요청(Pre-flight Request)합니다.
        - OPTIONS 메서드를 사용하는 이유는 Pre-flight Request임을 알려주기 위함입니다.
    - 이에 대한 Pre-flight Response를 반환하는데 access-control-allow-origin에 브라우저의 
    주소 값을 가지며 access-control-max-age라는 캐싱 시간(CORS 요청에 대한 유효기간)을 반환합니다.
    - 그 후 실제 요청(Request-origin)과 응답(Response-access-control-allow-origin)을 진행하여 
    CORS 통신을 진행합니다.
    
    3) **Credential Request(신용 요청)**
    - 신용 요청은 쿠키, 인증 헤더, TLS 클라이언트 등의 신용 정보를 함께 요청하며 이러한 정보들을 기반으로 통신을 진행할지 결정합니다.
    - 일반적으로 CORS 정책은 다른 출처 요청에 인증정보를 포함하는 것을 허용하지 않지만 
    access-contol-allow-credentials가 true로 설정 되어 있다면 인증정보를 포함할 수 있습니다.
- 3가지 방법 중 가장 권장되는 정책은 Pre-flight Request로 미리 요청을 보내 검증 할 수 있어 
가장 권장되는 방법입니다.

### TCP 3-way 핸드셰이크 과정은 무엇인가요?
- TCP로 네트워크 데이터 송수신이 진행될 때 클라이언트와 서버 간의 연결이 먼저 진행 되어야 하는데 이 때 진행되는 방법이 TCP 3-way 핸드셰이크
- 동작 과정
    1. 클라이언트가 서버에 연결 요청(SYN)을 보냄.
        - 클라이언트 state: CLOSED → SYN_SENT
    2. 서버가 클라이언트의 요청을 수락하고 응답(SYN-ACK)을 보냄.
        - 서버 state: LISTEN → SYN_RCVD
    3. 클라이언트가 서버의 응답을 확인(ACK)하여 연결이 완료됨.
        - 클라이언트 state: SYN_SENT → ESTABLISHED
        - 서버 state: SYN_RCVD → ESTABLISHED
    - SYN: Synchronize
    - SYN-ACK: Synchronize-Acknowledge
    - ACK: Acknowledge

### 4-way 종료 과정(TCP 연결 종료)은 어떻게 이루어지나요?
- 동작 과정
    1. 클라이언트가 서버로 FIN (Finish)을 보냄
    - **클라이언트 상태**: `ESTABLISHED` → `FIN_WAIT_1`
    - 클라이언트는 데이터를 전송 완료 후, 서버에 연결 종료 요청을 하기 위해 `ESTABLISHED` 상태에서 `FIN_WAIT_1` 상태로 변경합니다.
    
    2. 서버가 클라이언트로 요청을 수락하고 ACK (Acknowledge)를 보냄
    - **서버 상태**: `ESTABLISHED` → `CLOSE_WAIT`
    
    3. 서버가 ACK를 보낸 것을 알려주기 위해 클라이언트로 FIN (Finish)을 보냄
    - **서버 상태**: `CLOSE_WAIT` → `LAST_ACK`
    
    4.  클라이언트가 서버의 FIN 패킷을 확인한 후 연결 종료 요청을 위해 **ACK (Acknowledge)를 보냄**
    - **클라이언트 상태**: `FIN_WAIT_1` → `FIN_WAIT_2`
    - **서버 상태**: `LAST_ACK` → `CLOSED`
    - 서버는 클라이언트의 ACK 패킷을 수신한 후, 연결을 완전히 종료하고 `CLOSED` 상태로 전환
- TCP 연결을 종료할 때 3 way 방식이 아닌 4 way 방식인 이유는 안정적인 연결 종료를 위해서 양방향 통신을 이용하여 클라이언트와 서버 각각이 요청과 응답을 확인하여 종료하기 위함

### 데이터 전송 중 손실이 발생할 때 TCP는 어떻게 처리하나요?
- 송신사 측에서 TCP에서 데이터 스트림을 여러 개의 패킷으로 Sementation을 진행 → 파편화 된 Segmentation을 하나 씩 수신자 측으로 보내게 되는데 이 때 수신자 측에서는 패킷을 정상적으로 수신하면 ACK을 송신자 측에서 전달 함 → 만약에 네트워크 통신 시 패킷이 유실되면 ACK를 받지 못하게 되고 손실이 발생한 것을 송신자 측에서 인지 함 → 즉 손실 된 해당 패킷을 재전송 하여 데이터 손실을 처리(데이터 스트림을 Segmentation한 전체 패킷을 다시 다 보내는 것이 아닌 손실된 패킷만 재전송 함)

### TCP에서 슬라이딩 윈도우 프로토콜의 역할은 무엇인가요?
- 슬라이딩 윈도우 프로토콜이란 송신자 측에서 수신자 측으로 데이터 프레임을 전송할 때 흐름 제어를 하기 위한 프로토콜을 말함.
- 송신자는 수신자에게 윈도우 사이즈 만큼의 패킷을 보내고 수신자 측은 정상정으로 패킷을 수신 받으면 ACK을 비정상적으로 수신을 받으면 NAK을 송신자에게 반환함 → 송신자 측에서 ACK 수신을 받으면 그 다음 패킷을 윈도우 사이즈 만큼 송신하며 NAK을 수신 받으면 기존에 보냈던 패킷에 대해서 재전송을 진행함

### HTTP 상태 코드 200, 301, 404, 500의 차이점을 설명해주세요.
- 200: 클라이언트의 요청에 대해서 서버가 성공적으로 처리했음을 의미
- 301: 클라이언트가 요청한 리소스가 해당 URL에 존재하지 않고 다른 URL에 존재함을 의미
- 404: 클라이언트의 요청에 해당하는 리소스가 존재하지 않음을 의미
- 500: 클라이언트의 요청에 대해서 서버가 처리할 수 없음을 의미

### HTTP/1.1과 HTTP/2의 주요 차이점은 무엇인가요?
- HTTP 1.1 특징
    - 기본적으로 연결 하나당 하나의 요청과 응답을 처리
    - 추가적인 요청을 하려면 새로운 Connection(연결)을 생성하고 처리해야 함
    - 매 요청마다 헤더에 값을 보내야 하는데 이때 매 요청마다 중복된 값들을 헤더에 포함시켜서 보내야 함
    - 요청 시 본문이 text(Message) 방식으로 전송 됨
- HTTP 2 특징
    - 하나의 Connection으로 여러 개, 동시의 요청 및 응답이 가능하게 됨
    - 요청 시 binary frame 방식으로 전송하여 헤더 또한 압축하여 전송이 가능하게 됨
    - 클라이언트가 요청하지 않은 리소스에 대해서도 미리 전송이 가능해짐
- 결과적으로 속도적인 측면에서 향상 됨

### REST API와 SOAP의 차이점은 무엇인가요?
- REST API 특징
    - HTTP 프로토콜을 기반으로 HTTP Method를 이용하여 통신 진행
    - XML, JSON, HTML 등등 다양한 데이터 형식으로 통신 진행
    - 서버가 클라이언트의 요청에 대한 상태 정보를 저장하지 않음
    - URL과 HTTP Method를 이용하여 통신을 진행하여 직관적인 통신 진행
- SOAP(Simple Object Access Protocol) 특징
    - HTTP 말고도 SMTP나 TCP와 같은 다양한 프로토콜을 이용하여 통신 진행
    - XML 데이터 형식만으로 통신 진행
    - 상태를 유지하는 Stateful 통신을 진행하여 요청 간의 상태를 유지 가능
    - 통신 시 트랜잭션 처리가 가능함

### 웹소켓(WebSocket)이란 무엇이며, HTTP와의 차이점은 무엇인가요?
- HTTP 특징
    - 클라이언트가 요청을 보내고 서버가 응답을 하여 연결이 종료되는 형식 → 단방향 통신
    - 요청 및 응답에 헤더가 포함되어 있어서 통신 시 오버헤드가 발생할 수 있음
    - Stateless 프로토콜로 각 요청은 독립적이며 서버는 클라이언트의 요청 상태를 저장하지 않음
- 웹 소켓
    - 연결이 된 후 클라이언트와 서버 둘 다 양쪽으로 요청을 보내며 응답을 할 수 있는 방식 → 양방향 통신
    - HTTP Handshake 이후에는 요청과 응답 시 헤더 없이 데이터만을 주고 받기에 오버헤가드 적음
    - Stateful 프로토콜로 서버는 클라이언트의 상태를 저장하여 지속적으로 데이터 전송 가능
- 결과적으로 HTTP는 주기적인 데이터 통신에는 적합하나 실시간 업데이트는 및 양방향 통신에는 비효율적이며 웹 소켓은 실시간 데이터 전송과 빠른 요청 및 응답에 적합한 통신

### MQTT 프로토콜은 무엇이며, 어떤 상황에서 사용되나요?
- MQTT 프로토콜이란
    - 발행-구독 기반의 메세지 송수신 프로토콜
    - 통신 시 데이터의 단위가 매우 작기에 네트워크 대역폭이 작은 환경에서 적합하며 데이터 전송 시 오버헤드가 매우 적음
    - 데이터 단위가 적기에 저전력 및 소규모 데이터 통신에 최적화
    - 지속적인 연결을 지원하여 한번 연결되면 발행자와 구독자는 지속적으로 데이터를 주고받을 수 있음
- MQTT 프로토콜이 사용되는 상황
    - 사물 인터넷
    - 실시간 데이터 스트리밍
    - 스마트 시티
    - 모바일 메시징 앱

### FTP와 SFTP의 차이점을 설명해주세요.
- FTP는 파일을 송수신하는 프로토콜을 의미
- FTP는 암호화 되어 있지 않는데 SFTP는 SSH를 통해 암호화된 통신 제공
- FTP는 20, 21번(디폴트) 포트를 사용하지만 SFTP는 22 포트 사용
- FTP는 암호화가 되지 않기에 전송 속도가 더 빠르며 SFTP는 암호화로 인해 FTP 보다 좀 더 느림
- FTP는 접속 시 비밀번호 인증 방식을 사용하며 SFTP는 비밀번호 및 공개 키를 이용

### CDN(Content Delivery Network)이란 무엇이며, 왜 사용되나요?
- CDN이란
    - CDN(콘텐츠 전송 네트워크)는 콘텐츠 전송 네트워크 또는 콘텐츠 배포 네트워크를 의미
    - CDN는 데이터 사용량이 많은 어플리케이션의 웹 페이지 로드 속도를 높이는 상호 연결된 서버 네트워크
    - CDN을 사용하는 이유는 클라이언트(사용자)와 웹 서버에서 컨텐츠(이미지, 동영상 등등의 리소스)에 대해서 전달을 해야 하는데 이 때 클라이언트와 서버간의 거리가 멀 경우 시간이 오래 걸림 → 웹 사이트 컨텐츠는 클라이언트와 지리적으로 가까운 CDN 서버에 저장하여 클라이언트에게 더 빨리 컨텐츠를 전송해줄 수 있게 함
- CDN의 이점
    - 클라이언트와 서버간의 통신 지연을 줄임
    - 페이지 로드 시간 단축
    - 클라이언트와 서버간의 대역폭 비용 절감 → 클라이언트와 서버간의 리소스를 직접적으로 전달하지 않아서 대역폭을 줄일 수 있음
    - 콘텐츠 가용성 제고 → 클라이언트의 대용량 요청으로 웹 서버에서 대용량 컨텐츠를 로드할 때 웹 서버거 다운될 수 있는데 이러한 역할을 CDN 서버가 진행하여 가용성을 지원함

### 로드 밸런싱이란 무엇이며, 어떤 방식으로 구현되나요?
- 로드 밸런싱이란 사용자에게 리소스를 제공해주는 서버에 대해서 네트워크 트래픽을 균등하게 배포하는 방법
- 로드 밸런싱의 이점
    - 특정 서버가 장애가 발생했을 때 다른 서버로 트래픽을 전달하여 가용성 측면에서 이점 존재
    - 로드 밸런서를 사용하여 대량의 트래픽을 여러 서버로 분산시켜 확정성 측면에서 이점 존재
    - 응답 시간과 네트워크 지연 시간을 줄여 어플리케이션의 서버 성능 향상
    - 로드 밸런서 자체에서 보안적인 기능을 지원해서 보안 측면에서 이점 존재
- 로드 밸런싱 동작 방식
    - 사용자 요청 → 로드 밸런서 → 서버 팜에 있는 단일 서버로 트래픽 전달
    - 서버 팜이란 Application 서버의 묶음, 배열, 집합을 의미
- 로드 밸런싱 유형
    - ALB(Application Load Balancing): 트래픽을 여러 EC2 인스턴스에 분산하는데 리스너에 정해져 있는 규칙에 따라 분산을 진행, 각 규칙은 Application의 특징(검색, 결제 ..)에 따라서 정해져 있음. 결과적으로 Application 특징에 따라서 분산 처리를 진행하는 것이 ALB. 또한 OSI 7 계층에서 작동하며 Application 수준에서의 로드 밸런싱을 진행
    - NLB(Network Load Balancing): 네트워크 상태에 따라 트래픽을 분산하는 방법, 미리 정해진 서버 IP 또는 서버 가용성에 따라 트래픽을 라우팅 함. OSI 4 계층에서 진행되며 IP 및 포트를 기준으로 로드 밸런싱을 진행
    - GLB(Gateway Load Balancing): 라우팅 테이블을 이용하여 규칙을 설정한 후 설정한 규칙에 따라 트래픽을 전달, OSI 3계층과 7계층에서 작동하며 게이트웨이 기능과 네트워크 수준에서의 로드 밸런싱 진행

### 캐싱이란 무엇이며, 서버 성능에 어떤 영향을 미치나요?
- 캐싱이란 일반저긍로 일시적인 특징이 있는 데이터 하위 집합을 저장하는 고속 데이터 스토리지 계층, 일반적으로 컴퓨팅에서 (캐시 - 기본 스토리지) 형태의 구조를 지님
- 캐싱에 따른 서버 성능 영향
    - 기본적으로는 캐싱을 통해서 데이터 검색 성능 속도를 향상시키는 것이 주요 목적
    - 어플리케이션 성능 개선: 메모리보다 디스크가 훨씬 접근 속도가 빠르기에 데이터를 읽는 속도가 빨라짐
    - 데이터베이스 비용 절감: 캐시에 있는 데이터를 조회할 경우 데이터베이스에 접근하여 데이터를 조회할 필요가 없기에 데이터베이스 비용 절감이 될 수 있음
    - 백엔드의 로드 감소: 캐시에 있는 데이터를 조회함으로써 데이터베이스에 접근할 필요가 없으며 대용량 트래픽 처리 시 이점이 있음

### 레이턴시(latency)란 무엇이며, 이를 줄이기 위한 방법은 무엇인가요?
- Latancy란 대기 시간을 의미하며 하나의 데이터 패킷이 출발지에서 목적지까지 걸리는 시간을 의, 웹 프로그래밍 기준으로 사용자가 요청하여 응답을 받을 때까지의 걸리는 시간을 의미
- 대기 시간을 줄일 수 있는 방법
    - 네트워크 인프라 업그레이드
    - 그룹 네트워크 엔드포인트: 서로 자주 통신하는 네트워크 엔드포인트를 재그룹화 하는 서브넷팅을 이용, 실질적으로 불필요한 라우터 홉을 최소화 하여 네트워크 지연 시간을 축소
    - 트래픽 쉐이핑: 유형에 따라 데이터 페킷의 우선순위를 지정하여 지연 시간이 작은 패킷을 먼저 처리하고 추후에 지연 시간이 긴 패킷을 처리하여 네트워크 지연 시간 축소
    - 네트워크 거리 줄이기: 클라이언트와 서버간의 실질적인 거리를 줄임, 중간에 캐시 서버나 서버를 지역적으로 여러 개 두개 하여 네트워크 지연 시간 축소
    - 네트워크 홉 감소: 라우터와 라우터 사이에 존재하는 홉을 제거하는 방법

### 서버에서 패킷 손실이 발생했을 때 어떻게 해결하나요?
1. 패킷 손실 모니터링
2. 라우터 재시작
3. 네트워크 내 모든 연결 확인
4. 네트워크 성능 확인
5. 소프트웨어 장치 최신화 업데이트
6. 무선 연결에서 유선 연결로 전환
7. 오래된 하드웨어 교체
8. 대역폭 확인

### 지연 발생의 원인은 무엇이며, 이를 해결하기 위한 방법은 무엇인가요?
- 클라이언트와 서버 간의 라우터, 스위치, 방화벽 등등의 다양한 네트워크 요소가 있는데 패킷을 처리할 때 이러한 다양한 네트워크 요소간의 복합적인 과정이 일어나면서 네트워크 지연이 발생
- 지연 발생 원인 유형
    - 전송 미디어: 네트워크 미디어가 다른 유형의 네트워크 미디어로 전환될 때마다 전송시간이 지연 됨, 예를 들어 광섬유 네트워크에서 무선 네트워크 미디어로 변경되는 경우 전송 시간이 추가 됨
    - 네트워크 트래픽 이동 거리: 네트워크 엔드 포인트가 너무 길 경우 전송 시간이 지연 됨
    - 네트워크 홉 수: 중간 라우터가 여러 개인 경우 이에 따른 네트워크 홉 수가 많아져서 자연스럽게 전송 시간이 지연 됨
    - 데이터 볼륨: 동시 데이터 볼륨이 많을 경우 이에 따른 네트워크 디바이스에서 처리하는 시간이 길어지기에 자연스럽게 전송 시간이 지연 됨
    - 서버 성능: 서버에서 처리하는 시간 자체가 늘어나면 결과적으로 클라이언트가 응답 받는 시간이 길어지기에 지연 발생

### 대역폭(bandwidth)란 무엇인가요?
- 네트워크 대역폭이란 일정 시간 동안 출발지에서 목적지로 전송 가능한 최대 데이터의 양을 의미
- 네트워크 출력(Throughtput)은 일정 시간동안 실제로 목적지에 전송된 데이터 양을 의미
- 통신 중 여러 요소에 따라 실질적으로 전송 된 데이터의 양은 bandwidth ≤ throughtput

### 네트워크 혼잡이 발생할 경우, TCP는 이를 어떻게 처리하나요?
- 네트워크 혼잡에 따른 TCP 처리 유형
    - Slow Start(느린 시작): 송신자 측은 수신 받은 ACK를 통해 점진적으로 혼잡 윈도우 사이즈를 줄이거나 늘림으로써 전송량을 조절하는 방식
    - Congestion Avoidance(혼잡 회피): 특정 임계치의 혼잡 윈도우 사이즈부터는 지수적으로 윈도우 사이즈를 늘리는 것이 아닌 선형적으로 늘리는 방식
    - Fast Retransmit(빠른 재전송): 중복된 ACK를 받은 패킷에 대해서 재전송 하는 방식
    - Fast Recovery(빠른 복구): 혼잡 윈도우 사이즈를 임계치만큼 줄인 후 다시 선형적으로 증가시키는 방식

### 클라이언트와 서버 간 데이터 전송 속도를 최적화하기 위한 방법은 무엇인가요?
1. 윈도우 크기 조절
2. TCP를 사용할 필요가 없는 기능에 대하여 UDP 전환
3. 데이터를 압축하여 데이터 전송
4. 캐싱 처리 적용
5. CDN 사용
6. HTTP 프로토콜 업그레이드
7. 네트워크 장비 성능 향상

### QoS(Quality of Service)란 무엇이며, 왜 중요하나요?
- QOS란 네트워크에서 특정 유형의 트래픽에 대해 우선순위를 부여하고 네트워크 성능을 보장하기 위한 다양한 기술 또는 메커니즘을 말함
- QOS의 구성 요소는 대역폭, 지연, 지터, 패킷 손실이 있음
- QOS가 중요한 이유는 Application의 네트워크 통신을 모니터링하여 서비스의 품질이 일관적으로 유지됨을 보장하기 위함

### HTTPS는 어떻게 데이터를 보호하나요?
- SSL/TLS를 이용하여 데이터를 암호화
    - SSL과 TLS를 이용하여 데이터를 암호화 하는 과정은 3단계 과정을 거쳐서 진행 됨
- SSL/TLS를 이용하여 데이터의 무결성을 검증
- SSL/TLS 인증서를 통하여 클라이언트가 서버의 신뢰성을 확인하여 데이터를 보호
- 데이터 보호 동작 과정
    - SSL과 TLS를 이용하여 데이터를 암호화 하는 과정은 3단계 과정을 거쳐서 진행 됨
    1. HandShake 과정: 클라리언트가 서버에 연결을 시도할 때 서버는 자신의 공개 키가 포함된 SSL 또는 TLS 인증서를 클라이언트에게 전달 → 클라이언트는 인증서에 존재하는 공개 키를 이용하여 암호화 한 세션 키를 서버에 전송 → 서버는 데이터를 복호화 하여 세션 키를 조회
    2. 데이터 전송 과정: 클라이언트는 세션 키를 통하여 데이터를 암호화 한 후 서버에 전송 → 서버는 해당 세션 키를 이용하여 전달 받은 암호화 데이터에 대하여 복호화 
    3. 무결성 보장 과정: 클라이언트에서 서버로 암호화 된 데이터를 전송할 때 위변조가 되었는지 확인하기 위해 메세지 인증 코드를 같이 전송하여 서버에서는 해당 메세지 인증 코드를 통해 데이터가 위변조 되었는지 확인

### TLS/SSL 핸드셰이크 과정은 어떻게 이루어지나요?
1. 클라이언트 헬로: 클라이언트가 서버로 요청을 보내는데 이 요청 안에는 TLS 버전, 암호화 알고리즘 목록, 새션 키 생성을 위한 데이터 등등이 포함되어 있음
2. 서버 헬로: 클라이언트에게 요청 받은 데이터 중 서버가 선택한 데이터를 클라이언트에게 전송, 서버가 택한 TLS 버전, 암호화 알고리즘, 랜덤 데이터 등등..
3. 서버 인증: 서버는 자신을 인증하기 위해 클라이언트로 SSL 또는 TLS 인증서를 전송, TLS 인증서에는 서버 공개 키, 서버 신원을 확인하기 위한 인증 기관 서명(CA)가 존재
4. 서버 완료: 서버에서 추가적으로 정보를 보내지 않음을 클라이언트에게 전송하여 클라이언트는 서버와 통신을 진행할 수 있음을 확인
5. 클라이언트 키 교환: 클라이언트에서 서버의 공개 키를 이용하여 생성한 세션 키를 서버에 전송
6. 암호화 시작 및 완료 메세지: 클라이언트에서 Change Cipher Spec 메세지를 전송하여 암호화를 진행하겠다는 알림을 서버로 전송하고 Finished 메세지를 전송하여 Handshake가 완료됨을 전송
7. 서버 완료: 클라이언트에게 완료 메세지를 받은 후 서버 또한 CCS 메세지와 Finished 메세지를 클라이언트에게 전송

### MITM(중간자 공격)이란 무엇이며, 이를 방어하는 방법은 무엇인가요?**
- 중간자 공격이란 공격자가 클라이언트와 서버간의 통신 과정 중 데이터를 가로채거나 변조하는 것을 말함
- 방어 방법
    - HTTPS 이용
    - CA에서 발급된 인증서인지 확인 → 중간자 공격을 할 경우 인증서를 변경해서 클라이언트와 서버간의 네트워크 통신을 해독하기 때문
    - 강력한 암호화 알고리즘 이용
    
### DDoS 공격이란 무엇이며, 서버에서 이를 방어하는 방법은 무엇인가요?**
- 디도스 공격이란 공격자가 서버나 네트워크에 과도한 트래픽을 전송하여 서버를 마비시키는 공격을 말함
- AWS WAF(AWS Web Application Firewall)를 이용한 방어 방법
    - AWS Shield Standard를 이용
    - AWS WAF에서 비정상적인 IP에 대해서 요청을 차단하는 Rule 설정
    - AWS WAF에서 특정 시간동안 허용 된 요청 수를 설정하여 이를 넘어서면 해당 IP를 차단하는 Rule 설정
    - AWS WAF에서 특정 API를 제외한 나머지 API에 대한 요청이 들어 오는 경우 해당 IP를 차단 또는 특정 API만을 요청할 수 있도록 룰 설정

### CORS는 어떻게 웹 보안에 기여하나요?
- CORS(교차 출처 리소스 공유)는 웹 브라우저가 다른 출처로 요청하거나 응답 받은 데이터를 검증하는 정책을 의미
- 예를 들어서 사용자의 웹 브라우저가 [https://example.com](https://example.com/)로 로드 될 때 다른 출처인 [https://example2.com](https://example.com/)에 존재하는 데이터의 사용 여부를 판단하는 것을 의미함
- 일반적으로는 다른 출처의 데이터에 대해서 사용할 수 없도록 정책이 잡혀있는데 이는 신뢰할 수 없는 악성 사이트의 데이터를 사용할 경우 문제가 발생할 수 있기 때문임
- 그렇기에 허용 되는 다른 출처의 범위를 설정하고 서로 다른 출처간의 데이터 통신이 안전하게 이뤄지도록 해주는 것이 CORS임

### 네트워크 방화벽의 역할은 무엇인가요?

- 트래픽 필터링: 네트워크로 들어오는 패킷을 분석하여 특정 패킷에 대해서는 필터링 처리를 함
- 접근 제어: 네트워크로 인바운드 되거나 아웃바운드 되는 규칙을 걸어서 특정 IP를 차단하거나 허용함
- VPN 지원: 사용자가 인터넷 망으로부터 사설 네트워크로 안전하게 접근할 수 있도록 지원

### SSH는 어떻게 데이터를 암호화하나요?
- SSH란 네트워크 상에서 다른 컴퓨터에 안전하게 접속하기 위한 프로토콜, 예를 들어서 AWS EC의 원격 서버로 접속할 때 SSH 프로토콜을 통하여 사용자 인증 처리 후 접속할 수 있음
- SSH는 원격 접속, 사용자 인증, 데이터 암호화 등을 할 수 있음
- 암호화 과정
    1. Handshake 과정: 클라이언트와 서버간의 연결을 진행하는데 이 때 서로 사용하는 암호화 알고리즘과 SSH 프로토콜 버전을 맞춤
    2. 키 교환: 클라이언트와 서버 간의 비밀 키를 교환, 이 비밀 키는 세션키를 사용하기 위해서 생성함
    3. 세션 키 생성: 위 두 과정이 완료되면 클라이언트와 서버의 세션 키를 생성하여 해당 키를 이용하여 데이터 암/복호화 진행
    4. 데이터 암호화: 클라이언트에서 서버로 데이터를 전송할 때 위 과정에서 협의된 암호화 알고리즘으로 데이터를 암호화 하는데 이 때 키 값이 세션 키

### API 호출 시 OAuth 인증 방식을 설명해주세요.
1. Authorization Request (인증 요청): 클라이언트 ID, 요청 범위, Redirection URL을 폼하여 서버에 요청
2. Authorization Request (인증 요청): 인증 요청에 대해서 서버에서 확인 후 인증 허가 또는 거부를 응답
3. Authorization Code (인증 코드): 클라이언트는 Redirection URL에서 인증 코드 발급
4. **Access Token Request (엑세스 토큰 요청)**: 클라이언트에서 인증 코드와 함께 Access Token을 서버에 요청
5. **Access Token (엑세스 토큰)**: 서버에서 Access Token 값 클라이언트로 전달
6. API 호출: 클라이언트에서 Authorization 헤더에 Access Token 값을 넣어 서버의 API 호출

### SQL 인젝션 공격이란 무엇이며, 이를 방어하는 방법은 무엇인가요?
- SQL 인젝션 공격이란 사용자가 어떠한 액션을 진행할 때 악의적인 SQL 구문을 삽입하여 Application에 영향을 주는 것을 말함
- 예를 들어서 사용자가 로그인을 하는 액션이 직접 SQL 쿼리에 삽입될 때 로그인 시 SQL 쿼리 문이나 특정 값을 로그인하게 되면 SQL Injection이 발생할 수 있음
- 방어 기법
    1. SQL Injection은 일반적으로 SQL 구문이 하드 코딩 되어 있는 상태에서 발생할 확률이 높기에 이러한 하드 코딩을 동적으로 처리할 수 있도록 변경함, 예를 들어서 사용자의 입력 값에 대해서 변수로 바인딩 한 후 SQL을 실행하거나 ORM을 이용
    2. 아파치 웹 서버를 사용하는 경우 modeSecurity를 적용 → modeSecurity에서 SQL Injection rule을 설정하는데 요청 API URL에 특수 문자가 있거나 특정 쿼리를 실행하는 경우를 룰에 설정하여 방어

### XSS(Cross-Site Scripting)란 무엇이며, 이를 방어하기 위한 방법은 무엇인가요?
- 공격자가 악성 스크립트를 웹 페이지에 삽입하여 사용자가 웹 브라우저에서 악성 스크립츠를 호출하도록 공격하는 방법
- 방어 기법
    - CSP(Content Security Policy)를 이용하여 외부 도메인에서 스크립트를 로드할 수 없게 하여 외부 도메인의 호출을 막음
    - 출력 인코딩: 사용자의 액션에 대한 데이터를 HTML로 출력할 때 인코딩 처리 후 출력하게 하여 악성 스크립트의 호출을 제한하게 함
    - XSS 필터링 라이브러리를 사용하여 사용자 입력 값에 대하여 검증 처리 진행

