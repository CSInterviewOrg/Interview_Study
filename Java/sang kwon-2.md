## 정적(static)이란 무엇인가요?
- `static`은 객체의 인스턴스와 관계없이 클래스 차원에서 공유되기 위해 사용하는 키워드입니다.
- `static`으로 선언될 경우 클래스 단위로 공유되기 때문에 모든 인스턴스에서 공유하며, 프로그램이 시작될 때 JVM에 로딩된 후 프로그램이 종료될 때까지의 라이프 사이클을 가집니다.
#### static 클래스는 무엇인가요?
- static 클래스는 인스턴스화 할 수 없는 클래스를 의미합니다.
- static 클래스는 static 멤버 변수와 메서드만 존재하며 외부 클래스의 static 변수 및 메서드에만 접근이 가능합니다.
- static 클래스는 내부(이너) 클래스 및 중첩 클래스에만 사용하며 외부 클래스에만 사용되는 클래스를 중첩 클래스로 사용할 때, 즉 그룹화와 캡슐화를 할 때 사용됩니다.

## 자바의 원시타입들은 무엇이 있으며 각각 몇 바이트를 차지하나요?
- `byte`: 1-byte, 정수형
- `short`: 2-byte, 정수형
- `int`: 4-byte, 정수형
- `long`: 8-byte, 정수형
- `float`: 4-byte, 실수형
- `double`: 8-byte, 실수형
- `char`: 2-byte, 문자형
- `boolean`: 일반적으로 1-byte, 논리형
#### 타입의 byte 보다 큰 값 혹은 작은 값으로 초기화가 될 경우 어떤 일이 일어나나요?
- 컴파일 시점에는 컴파일 오류가 발생, 런타임 시점에 타입 캐스팅 시 발생하면 값이 누락되어 초기화, 런타인 시점에 값이 증가하여 발생할 경우 오버플로우 또는 언더플로우 발생
#### 정수형의 경우 그냥 제일 큰 long을 사용하면 되는데 왜 더 작은 타입들을 만들까요?
- 기본 데이터 타입은 동적인 메모리가 아닌 정적인 메모리를 사용하기에 불필요한 메모리 낭비를 줄이기 위해 값에 맞는 데이터 타입을 사용합니다.

## 접근 제어자의 종류와 이에 대해 설명해주세요.
- `private`: 같은 클래스 내에서만 접근 가능
- `default`: 같은 패키지 내에서만 접근 가능
- `protected`: 같은 패키지와 하위 클래스에서 접근 가능
- `public`: 모든 곳에서 접근 가능
#### 상위 클래스로부터 상속 받은 하위 클래스가 상위 클래스에 정의된 private 메서드를 오버라이딩 한다면 어떻게 될까요?
- 상속 받았다 하더라도 하위 클래스는 상위 클래스의 private 메서드에 접근할 수 없기에 새로운 메서드로 정의됩니다.

## 객체지향에 대해서 설명해주세요.
- 객체 지향은 프로그래밍 방법론 중 하나로, 현실 세계를 객체로 표현하여 객체들이 메시지를 주고받는 형태의 프로그램 설계 방식입니다.
#### 객체지향 4대 원칙
- `추상화`란 불필요한 부분을 숨기고 필요한 부분만 노출시키는 것입니다. ex) 인터페이스 
- `캡슐화`란 데이터를 외부로부터 보호하기 위해 감추는 것을 말합니다. ex) 접근제어자
- `상속`이란 하위 클래스가 상위 클래스의 값과 행위를 재사용하는 것을 말합니다. ex) extends
- `다형성`이란 하나의 메서드나 객체가 여러가지 형태를 가지는 것을 의미합니다. ex) 오버라이딩
#### 객체지향의 디미터 법칙에 대해서 설명해주세요
- 디미터 법칙은 최소한의 지식 원칙을 준수하는 것으로 자신과 관계없는 객체와 너무 많은 상호작용을 하지 말라는 법칙입니다.
#### 객체지향의 Tell, Don`t ask 법칙에 대해서 설명해주세요.
- 해당 법칙은 타 클래스로부터 질의를 하고 질의된 값에 대해서 비즈니스 로직을 처리하는 것이 아닌 명령형으로 비즈니스 로직을 처리하는 것입니다.

## SOLID(객체지향 5대 원칙)에 대해서 설명해주세요.
- **단일 책임 원칙 (Single Responsibility Principle, SRP)**: 클래스는 단 하나의 책임을 가져야 합니다.
- **개방-폐쇄 원칙 (Open/Closed Principle, OCP)**: 소프트웨어 구성 요소는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 합니다.
- **리스코프 치환 원칙 (Liskov Substitution Principle, LSP)**: 자식 클래스는 언제나 자신의 부모 클래스가 할 수 있는 행위를 수행할 수 있어야 합니다.
- **인터페이스 분리 원칙 (Interface Segregation Principle, ISP)**: 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
- **의존성 역전 원칙 (Dependency Inversion Principle, DIP)**: 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 합니다.
#### 의존성 역전 원칙의 실제 예를 알려주세요
- Service 클래스가 있고 Service 클래스가 DAO라는 구현체에 의존할 때 DAO 구현체가 MyBatis에서 JPA로 변경될 경우 이에 대한 수정 사항이 큽니다. 그런데 Service 클래스에서
의존하는 DAO가 인터페이스일 경우 변경 사항이 적어지면서 Database 구현체를 쉽게 변경할 수 있습니다.

## 동일성(identity)와 동등성(equality)에 대해 설명해주세요. (`equals()`, `==`)
- **동일성**: 비교하는 두 객체가 동일한 메모리 주소인지 비교하는 것입니다. 기본 데이터 타입의 값 비교나 같은 객체를 참조하는지 비교할 때 사용하며 `==` 연산자를 사용합니다.
- **동등성**: 비교하는 두 객체가 논리적으로 같은 값을 가지는지 확인하는 것입니다. 실제 값을 비교할 때 사용하며 `equals()` 메서드를 사용합니다.

## 원시 타입과 참조 타입의 차이에 대해 설명해주세요.
- **원시 타입**: 변수에 실제 값이 저장되는 타입을 의미합니다. 자바의 기본 데이터 타입을 의미하며, JVM의 스택 영역에 저장됩니다. 객체를 생성하지 않기에 메모리 측면에서 보다 효율적이며, 고정된 크기를 가지고 있습니다. 원시 타입은 `null`을 허용하지 않으며, 초기화되지 않은 경우 각 타입의 기본 값으로 초기화됩니다.
- **참조 타입**: 변수에 객체의 주소 값을 저장하며 실제 값은 힙 영역에 저장되는 데이터 타입을 의미합니다. 힙 영역에 저장되기에 크기가 고정되지 않고 동적입니다. 참조 타입은 `null`이 포함될 수 있으며, 값을 할당하지 않을 경우 `null`로 초기화됩니다.

class TempClass {
    String a = "zero";  // 참조 타입 변수
    Integer b = 0;      // 참조 타입 변수
    int c = 0;          // 원시 타입 변수
}
TempClass tempInstance = new TempClass();
- tempInstance는 new TempClass()의 메모리 주소를 힙 영역에 저장
- tempInstance.a, tempInstance.b 또한 힙 영역의 메모리 주소를 가지고 있으며 힙 영역의 메모리 주소에 실제 값이 존재
- tempInstance.c는 실제 값을 가지고 있음


## String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.

### String
- `new` 연산자로 생성된 `String`의 인스턴스는 불변합니다. 생성된 `String` 인스턴스에 문자를 더하거나 기존의 문자를 제거하면 이는 다른 `String` 객체입니다.
- `String` 객체는 값이 수정될 때마다 새로 객체를 생성하기에 객체 생성 비용이 계속됩니다.
- 값이 변경될 때마다 `String` 객체가 새로 생성되므로 값은 불변이므로 `Thread-Safe`합니다.

### StringBuffer
- `StringBuffer` 클래스는 문자열을 조작하기 위한 클래스입니다.
- `StringBuffer` 클래스에서 문자열을 변경 시 `String`과 달리 객체가 새로 생성되지 않고 값이 변경됩니다. 즉, `StringBuffer` 클래스의 값이 변경되더라도 `StringBuffer` 인스턴스의 주소 값은 동일합니다.
- `StringBuffer` 클래스는 `Thread-safe`합니다.

### StringBuilder
- `StringBuffer`와 동일한 기능을 하지만, `Thread-safe`하지 않습니다.
