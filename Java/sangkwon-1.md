# Java Concepts

## JVM의 구조와 Java의 실행방식

- **JVM 구조**
  - JVM은 다음과 같은 구성 요소로 이루어져 있습니다:
    - **클래스 로더 (Class Loader)**: Java 클래스 파일을 로드하여 JVM으로 전달합니다.
    - **런타임 데이터 영역 (Runtime Data Area)**: JVM이 프로그램을 실행하는 동안 필요한 메모리 영역을 관리합니다.
    - **실행 엔진 (Execution Engine)**: 바이트코드를 실제 기계어로 변환하여 실행합니다.
    - **네이티브 메소드 인터페이스 (Native Method Interface)**: JVM에서 네이티브 코드를 호출할 수 있게 해줍니다.
    - **네이티브 메소드 라이브러리 (Native Method Library)**: 네이티브 코드가 포함된 라이브러리입니다.

- **Java의 실행 방식**
  - `.java` 파일이 `javac` 컴파일러에 의해 `.class` 파일로 컴파일됩니다.
  - 클래스 로더가 `.class` 파일을 JVM에 전달합니다.
  - JVM의 실행 엔진이 `.class` 파일을 실행하여 Java 프로그램이 실행됩니다.

## GC(Garbage Collection)

- **GC란 무엇인가?**
  - GC는 자바와 같은 프로그래밍 언어에서 자동으로 메모리를 관리하는 시스템입니다.
  - 개발자가 직접 메모리를 관리해야 하는 C/C++와 달리, GC는 메모리 누수와 잘못된 메모리 접근을 방지해줍니다.

- **GC가 필요한 이유**
  - 메모리 관리 실수를 줄이고, 개발자가 메모리 관리에 신경 쓰지 않아도 되게 합니다.

- **GC의 동작 방식**
  - GC는 더 이상 참조되지 않는 객체를 메모리에서 제거합니다.
  - **마크 앤 스윕(Mark and Sweep) 알고리즘**:
    - GC가 루트 객체부터 참조 가능한 모든 객체를 마킹합니다.
    - 마킹되지 않은 객체는 메모리에서 제거됩니다.
    - 제거된 공간은 새로운 객체를 위한 메모리로 재사용됩니다.
  - **Generational Garbage Collection**:
    - 객체의 생존 시간에 따라 Young Generation, Old Generation, Permanent Generation(Metaspace)으로 나누어 GC를 진행합니다.
    - Young Generation: 새로운 객체가 생성되는 영역이며, 짧은 주기의 GC가 진행됩니다.
    - Old Generation: Young Generation에서 살아남은 객체들이 존재하는 영역입니다.
    - Permanent Generation(Metaspace): 클래스 메타데이터와 상수 정보가 존재하는 영역으로, Full GC 시에 정리됩니다.

## 컬렉션 프레임워크

- **컬렉션 프레임워크란?**
  - 데이터를 다루는 자료구조와 알고리즘을 표준화된 방식으로 제공하는 API입니다.

- **컬렉션 인터페이스**
  - **Collection**이라는 루트 인터페이스 하위에 `List`, `Queue`, `Set` 인터페이스가 존재하며 이에 대한 구현체들이 존재합니다.
    - **List 인터페이스**: 순서가 보장되며 중복 요소가 가능한 자료구조 인터페이스입니다.
    - **Queue 인터페이스**: FIFO 구조이며 중복 요소가 가능한 자료구조 인터페이스입니다.
      - 우선순위 큐를 사용할 경우 `PriorityQueue` 구현체를 사용하면 됩니다.
    - **Set 인터페이스**: 중복을 허용하지 않으며 순서를 보장하지 않는 자료구조 인터페이스입니다.
  - **Map 인터페이스**: Collection 인터페이스의 하위 인터페이스는 아니지만 일반적으로 Collection의 한 종류로 판단합니다.
    - `Map 인터페이스`는 key와 value 구조의 인터페이스이며 순서가 보장되지 않습니다.
    - 순서가 보장된 `Map` 인터페이스를 사용할 경우 `LinkedHashMap` 구현체를 사용하면 됩니다.
  - 컬렉션 인터페이스는 모두 제네릭으로 정의되어 있으며 표준화된 API를 제공합니다.

## 제네릭(Generic)

- **제네릭이란?**
  - 제네릭은 일반화된 데이터 타입을 의미하며, 외부에서 데이터 타입을 지정하여 유연하게 사용할 수 있습니다.
  - 제네릭은 컴파일 시점에 타입 안정성을 보장합니다.

## 어노테이션(Annotation)

- **어노테이션이란?**
  - 자바의 어노테이션은 코드의 메타데이터를 추가하는 특수한 인터페이스입니다.
  - 정의된 어노테이션에 따라 컴파일 시점 또는 런타임 시점에 특정한 기능이 동작합니다.

## 오버라이딩(Overriding)과 오버로딩(Overloading)

- **오버로딩(Overloading)**
  - 같은 클래스 내부에서 메서드를 재정의하는 것을 말합니다.
  - 메서드 이름이 동일해야 하며, 매개 변수의 개수, 타입, 순서가 달라져야 구분됩니다.
  - 리턴 타입은 오버로딩에 고려되지 않습니다.

- **오버라이딩(Overriding)**
  - 상위 클래스의 메서드를 하위 클래스에서 재정의하는 것을 말합니다.
  - 메서드의 반환 타입, 메서드 이름, 매개 변수가 모두 동일해야 합니다.
  - 재정의된 메서드는 상위 클래스의 메서드보다 더 제한적인 접근 제어자를 가질 수 없습니다.
  - `@Override` 어노테이션을 사용하면, 컴파일러가 오버라이딩이 제대로 되었는지 확인할 수 있습니다.

- **정적(static) 메서드는 왜 오버라이딩이 불가능한가?**
  - 오버라이딩은 런타임 시점에 실행되지만, 정적 메서드는 컴파일 시점에 이미 정의되어 있어 오버라이딩이 불가능합니다. 대신 하위 클래스에서 재정의할 경우 하위 메서드가 호출되는 Hidding(숨김)이 적용됩니다.

- **생성자는 왜 오버라이딩이 불가능한가?**
  - 생성자는 자기 자신의 클래스를 인스턴스로 초기화하는 메서드이므로 오버라이딩이 불가능합니다.

## 인터페이스와 추상 클래스의 차이점

- **추상 클래스**
  - 다중 상속이 불가능하여 하나의 클래스만 상속받을 수 있습니다.
  - 일반 구현 메서드와 추상 메서드가 존재하며, 추상 메서드는 하위 클래스에서 구현해야 합니다.
  - 추상 클래스는 생성자를 가질 수 있습니다.

- **인터페이스**
  - 다중 상속이 가능하며, 구현체에서 여러 인터페이스를 상속받을 수 있습니다.
  - 인터페이스는 메서드의 시그니처만 정의하고, 구현체에서 메서드를 구현해야 합니다.
  - 자바 8 이후에는 `default` 메서드와 `static` 메서드에서 구현이 가능하게 되었습니다.
  - 인터페이스 메서드의 기본 접근 제어자는 `public`입니다.
  - 인터페이스는 생성자를 가질 수 없습니다.

## 클래스와 객체

- **클래스**는 요리의 레시피와 같고, **객체**는 레시피로 만든 음식입니다.

## 정적(static)이란 무엇인가요?
- `static`은 객체의 인스턴스와 관계없이 클래스 차원에서 공유되기 위해 사용하는 키워드입니다.
- `static`으로 선언될 경우 클래스 단위로 공유되기 때문에 모든 인스턴스에서 공유하며, 프로그램이 시작될 때 JVM에 로딩된 후 프로그램이 종료될 때까지의 라이프 사이클을 가집니다.
#### static 클래스는 무엇인가요?
- static 클래스는 인스턴스화 할 수 없는 클래스를 의미합니다.
- static 클래스는 static 멤버 변수와 메서드만 존재하며 외부 클래스의 static 변수 및 메서드에만 접근이 가능합니다.
- static 클래스는 내부(이너) 클래스 및 중첩 클래스에만 사용하며 외부 클래스에만 사용되는 클래스를 중첩 클래스로 사용할 때, 즉 그룹화와 캡슐화를 할 때 사용됩니다.

## 자바의 원시타입들은 무엇이 있으며 각각 몇 바이트를 차지하나요?
- `byte`: 1-byte, 정수형
- `short`: 2-byte, 정수형
- `int`: 4-byte, 정수형
- `long`: 8-byte, 정수형
- `float`: 4-byte, 실수형
- `double`: 8-byte, 실수형
- `char`: 2-byte, 문자형
- `boolean`: 일반적으로 1-byte, 논리형
#### 타입의 byte 보다 큰 값 혹은 작은 값으로 초기화가 될 경우 어떤 일이 일어나나요?
- 컴파일 시점에는 컴파일 오류가 발생, 런타임 시점에 타입 캐스팅 시 발생하면 값이 누락되어 초기화, 런타인 시점에 값이 증가하여 발생할 경우 오버플로우 또는 언더플로우 발생
#### 정수형의 경우 그냥 제일 큰 long을 사용하면 되는데 왜 더 작은 타입들을 만들까요?
- 기본 데이터 타입은 동적인 메모리가 아닌 정적인 메모리를 사용하기에 불필요한 메모리 낭비를 줄이기 위해 값에 맞는 데이터 타입을 사용합니다.

## 접근 제어자의 종류와 이에 대해 설명해주세요.
- `private`: 같은 클래스 내에서만 접근 가능
- `default`: 같은 패키지 내에서만 접근 가능
- `protected`: 같은 패키지와 하위 클래스에서 접근 가능
- `public`: 모든 곳에서 접근 가능
#### 상위 클래스로부터 상속 받은 하위 클래스가 상위 클래스에 정의된 private 메서드를 오버라이딩 한다면 어떻게 될까요?
- 상속 받았다 하더라도 하위 클래스는 상위 클래스의 private 메서드에 접근할 수 없기에 새로운 메서드로 정의됩니다.

## 객체지향에 대해서 설명해주세요.
- 객체 지향은 프로그래밍 방법론 중 하나로, 현실 세계를 객체로 표현하여 객체들이 메시지를 주고받는 형태의 프로그램 설계 방식입니다.
#### 객체지향 4대 원칙
- `추상화`란 불필요한 부분을 숨기고 필요한 부분만 노출시키는 것입니다. ex) 인터페이스 
- `캡슐화`란 데이터를 외부로부터 보호하기 위해 감추는 것을 말합니다. ex) 접근제어자
- `상속`이란 하위 클래스가 상위 클래스의 값과 행위를 재사용하는 것을 말합니다. ex) extends
- `다형성`이란 하나의 메서드나 객체가 여러가지 형태를 가지는 것을 의미합니다. ex) 오버라이딩
#### 객체지향의 디미터 법칙에 대해서 설명해주세요
- 디미터 법칙은 최소한의 지식 원칙을 준수하는 것으로 자신과 관계없는 객체와 너무 많은 상호작용을 하지 말라는 법칙입니다.
#### 객체지향의 Tell, Don`t ask 법칙에 대해서 설명해주세요.
- 해당 법칙은 타 클래스로부터 질의를 하고 질의된 값에 대해서 비즈니스 로직을 처리하는 것이 아닌 명령형으로 비즈니스 로직을 처리하는 것입니다.

## SOLID(객체지향 5대 원칙)에 대해서 설명해주세요.
- **단일 책임 원칙 (Single Responsibility Principle, SRP)**: 클래스는 단 하나의 책임을 가져야 합니다.
- **개방-폐쇄 원칙 (Open/Closed Principle, OCP)**: 소프트웨어 구성 요소는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 합니다.
- **리스코프 치환 원칙 (Liskov Substitution Principle, LSP)**: 자식 클래스는 언제나 자신의 부모 클래스가 할 수 있는 행위를 수행할 수 있어야 합니다.
- **인터페이스 분리 원칙 (Interface Segregation Principle, ISP)**: 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
- **의존성 역전 원칙 (Dependency Inversion Principle, DIP)**: 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 합니다.
#### 의존성 역전 원칙의 실제 예를 알려주세요
- Service 클래스가 있고 Service 클래스가 DAO라는 구현체에 의존할 때 DAO 구현체가 MyBatis에서 JPA로 변경될 경우 이에 대한 수정 사항이 큽니다. 그런데 Service 클래스에서
의존하는 DAO가 인터페이스일 경우 변경 사항이 적어지면서 Database 구현체를 쉽게 변경할 수 있습니다.

## 동일성(identity)와 동등성(equality)에 대해 설명해주세요. (`equals()`, `==`)
- **동일성**: 비교하는 두 객체가 동일한 메모리 주소인지 비교하는 것입니다. 기본 데이터 타입의 값 비교나 같은 객체를 참조하는지 비교할 때 사용하며 `==` 연산자를 사용합니다.
- **동등성**: 비교하는 두 객체가 논리적으로 같은 값을 가지는지 확인하는 것입니다. 실제 값을 비교할 때 사용하며 `equals()` 메서드를 사용합니다.

## 원시 타입과 참조 타입의 차이에 대해 설명해주세요.
- **원시 타입**: 변수에 실제 값이 저장되는 타입을 의미합니다. 자바의 기본 데이터 타입을 의미하며, JVM의 스택 영역에 저장됩니다. 객체를 생성하지 않기에 메모리 측면에서 보다 효율적이며, 고정된 크기를 가지고 있습니다. 원시 타입은 `null`을 허용하지 않으며, 초기화되지 않은 경우 각 타입의 기본 값으로 초기화됩니다.
- **참조 타입**: 변수에 객체의 주소 값을 저장하며 실제 값은 힙 영역에 저장되는 데이터 타입을 의미합니다. 힙 영역에 저장되기에 크기가 고정되지 않고 동적입니다. 참조 타입은 `null`이 포함될 수 있으며, 값을 할당하지 않을 경우 `null`로 초기화됩니다.

class TempClass {
    String a = "zero";  // 참조 타입 변수
    Integer b = 0;      // 참조 타입 변수
    int c = 0;          // 원시 타입 변수
}
TempClass tempInstance = new TempClass();
- tempInstance는 new TempClass()의 메모리 주소를 힙 영역에 저장
- tempInstance.a, tempInstance.b 또한 힙 영역의 메모리 주소를 가지고 있으며 힙 영역의 메모리 주소에 실제 값이 존재
- tempInstance.c는 실제 값을 가지고 있음


## String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.

### String
- `new` 연산자로 생성된 `String`의 인스턴스는 불변합니다. 생성된 `String` 인스턴스에 문자를 더하거나 기존의 문자를 제거하면 이는 다른 `String` 객체입니다.
- `String` 객체는 값이 수정될 때마다 새로 객체를 생성하기에 객체 생성 비용이 계속됩니다.
- 값이 변경될 때마다 `String` 객체가 새로 생성되므로 값은 불변이므로 `Thread-Safe`합니다.

### StringBuffer
- `StringBuffer` 클래스는 문자열을 조작하기 위한 클래스입니다.
- `StringBuffer` 클래스에서 문자열을 변경 시 `String`과 달리 객체가 새로 생성되지 않고 값이 변경됩니다. 즉, `StringBuffer` 클래스의 값이 변경되더라도 `StringBuffer` 인스턴스의 주소 값은 동일합니다.
- `StringBuffer` 클래스는 `Thread-safe`합니다.

### StringBuilder
- `StringBuffer`와 동일한 기능을 하지만, `Thread-safe`하지 않습니다.

## Checked Exception과 Unchecked Exception에 대해 설명해주세요. 스프링 트랜잭션 추상화에서 rollback 대상은 무엇일까요?
- Checked Exception: 컴파일러가 예외 처리를 강제하는 예외로 컴파일 시점에 예외가 발생하는 Exception입니다.
- Unchecked Exception: 컴파일러가 예외 처리를 강제하지 않는 예외로 런타임 시점에 발생하는 Exception입니다.
- 기본적으로는 Checked Exception이 발생할 시 스프링에서 트랜잭션 롤백이 진행됩니다. 하지만 특정 Exception에 대해서 롤백을 원하는 경우 옵션 값에 원하는 Exception을 지정하면 해당 예외가 발생할 때 롤백이 진행됩니다.

#### 자바의 예외 클래스 계층 구조에 대해서 설명해주실 수 있나요?
```jsx
Throwable
├── Error
│   ├── OutOfMemoryError
│   ├── StackOverflowError
│   └── ...
└── Exception
    ├── IOException (Checked Exception)
    ├── SQLException (Checked Exception)
    ├── ClassNotFoundException (Checked Exception)
    └── RuntimeException (Unchecked Exception)
        ├── NullPointerException
        ├── ArrayIndexOutOfBoundsException
        ├── IllegalArgumentException
        └── ...
```

- Throwable: 에러와 예외 클래스의 최상위 클래스입니다.
- Error: Throwable로부터 상속 받은 하위 클래스이며 개발자가 처리할 수 없는 에러 클래스입니다.
- Exception: Throwable로부터 상속 받은 하위 클래스이며 개발자가 처리할 수 있는 클래스입니다. Exception은 Checked Exception과 RuntimeException(Unchecked Exception)으로 나뉘어집니다.

## Java8에서 추가된 기능에 대해서 설명해주세요.
- 람다 표현식: 익명 함수를 간단하게 표현하는 방법입니다.
- 함수형 인터페이스: 하나의 추상 메서드만을 가지는 인터페이스입니다.
- 메서드 참조: 메서드를 람다 표현식처럼 사용하는 방식으로 메서드를 간단하게 참조할 수 있는 방법입니다.
- 스트림 API: 컬렉션 데이터를 보다 쉽게 처리할 수 있는 API입니다.
- 인터페이스 Default Method: 인터페이스에 구현을 할 수 있는 메서드입니다.
- Optional 클래스: 자바의 NPE를 처리할 때 도와주는 클래스입니다.
- java.time 패키지: `java.util.Date`와 `java.util.Calendar` 의 단점을 보완한 클래스입니다.

#### 익명 함수란 무엇인가요?
    - 익명 함수란 이름이 없는 함수를 말합니다. 일반적으로 함수는 재사용을 하기 위해 사용되는데 익명 함수는 재사용을 하지 않고 일회성으로 사용하는 함수이며 함수를 사용하는 시점에 함수를 구현하여 사용합니다.
- 함수형 인터페이스를 사용하는 이유가 무엇인가요?
    - 자바에서 함수형 프로그래밍 방식을 사용하기 위해 사용합니다. 람다 표현식과 메서드 레퍼런스를 이용합니다.
- java.util.Date와 java.util.Calendar의 단점이 무엇인가요?
    - Date와 Calendar 클래스의 객체는 Non-Thread Safe 하기 때문에 여러 쓰레드가 동시에 객체의 값을 수정할 수 있기에 멀티 쓰레딩 환경에서 안전하지 않습니다.

## try-with-resource에 대해서 설명해주세요.
- resource를 명시적으로 해제 것이 아닌 자동으로 resource를 해제하는 방식으로 예기치 못한 자원 누수를 방지하는 방법입니다.
- try-with-resources에서 try 구문에 여러 resource가 선언 되었을 때 resource가 해제되는 순서는 어떻게 되나요?

```jsx
try (ResourceType1 resource1 = new ResourceType1();
     ResourceType2 resource2 = new ResourceType2()) {
} catch (Exception e) {}
```
- 선언 순서의 역순으로 해제가 됩니다. 위 예에서 resource2가 해제되고 resource1이 해제됩니다.

## 강한 결합과 느슨한 결합이 무엇인지 설명해주세요.
- 강한 결합: 의존하고 있는 클래스가 구현체일 때 강한 결합을 의미합니다. A 클래스가 B 구현체를 의존하고 있을 때 구현체인 B 클래스가 변경되면 이에 따라 A 클래스의 변경 사항도 많은 수준의 결합 정도를 의미합니다.
- 느슨한 결합: 구현 클래스를 의존하는 것이 아닌 인터페이스를 의존하는 방식을 느슨한 결합이라고 합니다. A 클래스가 B 인터페이스를 의존하고 B 인터페이스를 구현한 C 클래스가 변경되거나 다른 클래스에 교체 됨에도 A 클래스의 영향이 적은 결합 정도를 의미합니다.
#### 느슨한 결합을 진행할 때 인터페이스 말고 다른 방식은 무엇이 있을까요?
- 이벤트 기반 프로그래밍 방식이 있습니다. 결제가 성공하고 결제 성공에 따른 알람을 전송할 때 알람에 대한 구현체 혹은 인터페이스를 호출하는 것이 아닌 결제 성공이라는 이벤트를 통해 알람이 전송되는 방식을 진행할 수 있습니다.

## 직렬화와 역직렬화에 대해서 설명해주세요.
- 직렬화: 객체를 바이트 형식으로 바꾸는 것을 말합니다.
- 역직렬화: 바이트를 객체 형식으로 바꾸는 것을 말합니다.
#### 네트워크 통신을 진행할 때 객체를 직렬화해서 바이트 형식으로 송수신을 진행합니다. 왜 굳이 바이트 형식으로 전송할까요?
- 네트워크의 표준 단위는 바이트이며 네트워크에서 각 프로토콜마다 다른 규칙이 적용되는 것이 아닌 바이트라는 범용적인 단위를 사용하기 위해 직렬화 한 후 네트워크 송수신을 진행합니다.

## 자바의 동시성 이슈(공유자원 접근)에 대해 설명해주세요.
- 여러 쓰레드가 동일한 변수에 접근하여 값을 수정하는 경우 아래와 같은 동시성 이슈가 발생할 수 있습니다.
- 경쟁 상태 (Race Condition): 두 개 이상의 쓰레드가 공유 변수에 접근하여 예기치 못한 결과 값으로 변경되는 경우
- 교착 상태 (Deadlock): 두 개 이상의 쓰레드 각각이 자신이 자원을 가지고 있는 상태에서 다른 자원에 접근하여 모든 쓰레드들이 대기하는 경우
- 기아 상태 (Starvation): 쓰레드들이 우선 순위를 가진 상태여서 가장 낮은 우선순위를 가진 쓰레드는 접근하지 못하는 경우
- 빈번한 대기 (Livelock): 각 쓰레드가 동시에 락을 해제하고 락을 진행하여 결과적으로 아무런 진행이 없는 경우
#### 자바에서 동시성 이슈를 해결하기 위한 방법을 알려주세요.
- synchronized: 메서드에 선언되며 메서드 전체 영역에 대해서 동기화를 처리하는 방법입니다.
- voltile: 변수에 대해서 동기화를 처리하는 방식으로 각 스레드가 자신의 CPU Cache에 값을 쓰고 읽는 것이 아닌 메인 메모리에 값을 쓰고 읽는 것을 보장하는 방식입니다. 하지만 연산에 대해서는 원자성을 보장하지 않기에 복잡한 연산에는 적합하지 않은 키워드입니다.
- atomic: 원자성 연산을 보장하는 키워드로 현재의 값이 예상한 값과 일치하는지를 비교한 후 CPU Cache와 메인 메모리를 동기화하는 방식의 키워드입니다.

## Mutable 객체와 Immutable 객체의 차이점에 대해 설명해주세요.
- Mutable 객체: 객체가 생성된 이후에 자신의 상태 값을 수정할 수 있는 객체를 말합니다. StringBuilder, StringBuffer, ArrayList .. 등등이 있습니다.
- Immutable 객체: 객체가 생성된 이후 자신의 상태 값을 수정할 수 없는 객체를 말합니다. String, Integer 등등의 객체가 존재합니다.
#### Immutable 객체의 필드 값을 조회한 후에 해당 값을 수정하거나 사용하는 경우 얕은 복사와 깊은 복사중 어떤 방식을 사용해야 하나요?
- 얕은 복사가 아닌 깊은 복사를 사용해야합니다. Immutable 객체는 변경 불가능한 객체이기에 얕은 복사를 진행하는 경우 메모리 주소가 동일하기에 값을 수정하면 Immutable 객체의 필드가 수정될 수 있기에 깊은 복사를 이용해야 합니다.

## 자바에서 null을 안전하게 다루는 방법에 대해 설명해주세요.
- Optional이나 null check 로직을 이용한 방어 코드를 사용합니다.

## JDK와 JRE의 차이점을 설명하세요.
- JDK: JDK는 자바 애플리케이션을 개발하기 위한 전체 도구 모음입니다. JDK 안에 JRE가 포함되어 있으며 JDK 말고도 컴파일러나 디버거 등등이 존재합니다.
- JRE: JRE는 자바 애플리케이션을 실행하기 위한 환경으로 JVM과 자바 라이브러리를 포함하여 자바 프로그램이 실행될 수 있도록 지원합니다.
