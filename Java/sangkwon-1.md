# Java Concepts

## JVM의 구조와 Java의 실행방식

- **JVM 구조**
  - JVM은 다음과 같은 구성 요소로 이루어져 있습니다:
    - **클래스 로더 (Class Loader)**: Java 클래스 파일을 로드하여 JVM으로 전달합니다.
    - **런타임 데이터 영역 (Runtime Data Area)**: JVM이 프로그램을 실행하는 동안 필요한 메모리 영역을 관리합니다.
    - **실행 엔진 (Execution Engine)**: 바이트코드를 실제 기계어로 변환하여 실행합니다.
    - **네이티브 메소드 인터페이스 (Native Method Interface)**: JVM에서 네이티브 코드를 호출할 수 있게 해줍니다.
    - **네이티브 메소드 라이브러리 (Native Method Library)**: 네이티브 코드가 포함된 라이브러리입니다.

- **Java의 실행 방식**
  - `.java` 파일이 `javac` 컴파일러에 의해 `.class` 파일로 컴파일됩니다.
  - 클래스 로더가 `.class` 파일을 JVM에 전달합니다.
  - JVM의 실행 엔진이 `.class` 파일을 실행하여 Java 프로그램이 실행됩니다.

## GC(Garbage Collection)

- **GC란 무엇인가?**
  - GC는 자바와 같은 프로그래밍 언어에서 자동으로 메모리를 관리하는 시스템입니다.
  - 개발자가 직접 메모리를 관리해야 하는 C/C++와 달리, GC는 메모리 누수와 잘못된 메모리 접근을 방지해줍니다.

- **GC가 필요한 이유**
  - 메모리 관리 실수를 줄이고, 개발자가 메모리 관리에 신경 쓰지 않아도 되게 합니다.

- **GC의 동작 방식**
  - GC는 더 이상 참조되지 않는 객체를 메모리에서 제거합니다.
  - **마크 앤 스윕(Mark and Sweep) 알고리즘**:
    - GC가 루트 객체부터 참조 가능한 모든 객체를 마킹합니다.
    - 마킹되지 않은 객체는 메모리에서 제거됩니다.
    - 제거된 공간은 새로운 객체를 위한 메모리로 재사용됩니다.
  - **Generational Garbage Collection**:
    - 객체의 생존 시간에 따라 Young Generation, Old Generation, Permanent Generation(Metaspace)으로 나누어 GC를 진행합니다.
    - Young Generation: 새로운 객체가 생성되는 영역이며, 짧은 주기의 GC가 진행됩니다.
    - Old Generation: Young Generation에서 살아남은 객체들이 존재하는 영역입니다.
    - Permanent Generation(Metaspace): 클래스 메타데이터와 상수 정보가 존재하는 영역으로, Full GC 시에 정리됩니다.

## 컬렉션 프레임워크

- **컬렉션 프레임워크란?**
  - 데이터를 다루는 자료구조와 알고리즘을 표준화된 방식으로 제공하는 API입니다.

- **컬렉션 인터페이스**
  - **Collection**이라는 루트 인터페이스 하위에 `List`, `Queue`, `Set` 인터페이스가 존재하며 이에 대한 구현체들이 존재합니다.
    - **List 인터페이스**: 순서가 보장되며 중복 요소가 가능한 자료구조 인터페이스입니다.
    - **Queue 인터페이스**: FIFO 구조이며 중복 요소가 가능한 자료구조 인터페이스입니다.
      - 우선순위 큐를 사용할 경우 `PriorityQueue` 구현체를 사용하면 됩니다.
    - **Set 인터페이스**: 중복을 허용하지 않으며 순서를 보장하지 않는 자료구조 인터페이스입니다.
  - **Map 인터페이스**: Collection 인터페이스의 하위 인터페이스는 아니지만 일반적으로 Collection의 한 종류로 판단합니다.
    - `Map 인터페이스`는 key와 value 구조의 인터페이스이며 순서가 보장되지 않습니다.
    - 순서가 보장된 `Map` 인터페이스를 사용할 경우 `LinkedHashMap` 구현체를 사용하면 됩니다.
  - 컬렉션 인터페이스는 모두 제네릭으로 정의되어 있으며 표준화된 API를 제공합니다.

## 제네릭(Generic)

- **제네릭이란?**
  - 제네릭은 일반화된 데이터 타입을 의미하며, 외부에서 데이터 타입을 지정하여 유연하게 사용할 수 있습니다.
  - 제네릭은 컴파일 시점에 타입 안정성을 보장합니다.

## 어노테이션(Annotation)

- **어노테이션이란?**
  - 자바의 어노테이션은 코드의 메타데이터를 추가하는 특수한 인터페이스입니다.
  - 정의된 어노테이션에 따라 컴파일 시점 또는 런타임 시점에 특정한 기능이 동작합니다.

## 오버라이딩(Overriding)과 오버로딩(Overloading)

- **오버로딩(Overloading)**
  - 같은 클래스 내부에서 메서드를 재정의하는 것을 말합니다.
  - 메서드 이름이 동일해야 하며, 매개 변수의 개수, 타입, 순서가 달라져야 구분됩니다.
  - 리턴 타입은 오버로딩에 고려되지 않습니다.

- **오버라이딩(Overriding)**
  - 상위 클래스의 메서드를 하위 클래스에서 재정의하는 것을 말합니다.
  - 메서드의 반환 타입, 메서드 이름, 매개 변수가 모두 동일해야 합니다.
  - 재정의된 메서드는 상위 클래스의 메서드보다 더 제한적인 접근 제어자를 가질 수 없습니다.
  - `@Override` 어노테이션을 사용하면, 컴파일러가 오버라이딩이 제대로 되었는지 확인할 수 있습니다.

- **정적(static) 메서드는 왜 오버라이딩이 불가능한가?**
  - 오버라이딩은 런타임 시점에 실행되지만, 정적 메서드는 컴파일 시점에 이미 정의되어 있어 오버라이딩이 불가능합니다. 대신 하위 클래스에서 재정의할 경우 하위 메서드가 호출되는 Hidding(숨김)이 적용됩니다.

- **생성자는 왜 오버라이딩이 불가능한가?**
  - 생성자는 자기 자신의 클래스를 인스턴스로 초기화하는 메서드이므로 오버라이딩이 불가능합니다.

## 인터페이스와 추상 클래스의 차이점

- **추상 클래스**
  - 다중 상속이 불가능하여 하나의 클래스만 상속받을 수 있습니다.
  - 일반 구현 메서드와 추상 메서드가 존재하며, 추상 메서드는 하위 클래스에서 구현해야 합니다.
  - 추상 클래스는 생성자를 가질 수 있습니다.

- **인터페이스**
  - 다중 상속이 가능하며, 구현체에서 여러 인터페이스를 상속받을 수 있습니다.
  - 인터페이스는 메서드의 시그니처만 정의하고, 구현체에서 메서드를 구현해야 합니다.
  - 자바 8 이후에는 `default` 메서드와 `static` 메서드에서 구현이 가능하게 되었습니다.
  - 인터페이스 메서드의 기본 접근 제어자는 `public`입니다.
  - 인터페이스는 생성자를 가질 수 없습니다.

## 클래스와 객체

- **클래스**는 요리의 레시피와 같고, **객체**는 레시피로 만든 음식입니다.

## 정적(static)이란 무엇인가요?
- `static`은 객체의 인스턴스와 관계없이 클래스 차원에서 공유되기 위해 사용하는 키워드입니다.
- `static`으로 선언될 경우 클래스 단위로 공유되기 때문에 모든 인스턴스에서 공유하며, 프로그램이 시작될 때 JVM에 로딩된 후 프로그램이 종료될 때까지의 라이프 사이클을 가집니다.
#### static 클래스는 무엇인가요?
- static 클래스는 인스턴스화 할 수 없는 클래스를 의미합니다.
- static 클래스는 static 멤버 변수와 메서드만 존재하며 외부 클래스의 static 변수 및 메서드에만 접근이 가능합니다.
- static 클래스는 내부(이너) 클래스 및 중첩 클래스에만 사용하며 외부 클래스에만 사용되는 클래스를 중첩 클래스로 사용할 때, 즉 그룹화와 캡슐화를 할 때 사용됩니다.

## 자바의 원시타입들은 무엇이 있으며 각각 몇 바이트를 차지하나요?
- `byte`: 1-byte, 정수형
- `short`: 2-byte, 정수형
- `int`: 4-byte, 정수형
- `long`: 8-byte, 정수형
- `float`: 4-byte, 실수형
- `double`: 8-byte, 실수형
- `char`: 2-byte, 문자형
- `boolean`: 일반적으로 1-byte, 논리형
#### 타입의 byte 보다 큰 값 혹은 작은 값으로 초기화가 될 경우 어떤 일이 일어나나요?
- 컴파일 시점에는 컴파일 오류가 발생, 런타임 시점에 타입 캐스팅 시 발생하면 값이 누락되어 초기화, 런타인 시점에 값이 증가하여 발생할 경우 오버플로우 또는 언더플로우 발생
#### 정수형의 경우 그냥 제일 큰 long을 사용하면 되는데 왜 더 작은 타입들을 만들까요?
- 기본 데이터 타입은 동적인 메모리가 아닌 정적인 메모리를 사용하기에 불필요한 메모리 낭비를 줄이기 위해 값에 맞는 데이터 타입을 사용합니다.

## 접근 제어자의 종류와 이에 대해 설명해주세요.
- `private`: 같은 클래스 내에서만 접근 가능
- `default`: 같은 패키지 내에서만 접근 가능
- `protected`: 같은 패키지와 하위 클래스에서 접근 가능
- `public`: 모든 곳에서 접근 가능
#### 상위 클래스로부터 상속 받은 하위 클래스가 상위 클래스에 정의된 private 메서드를 오버라이딩 한다면 어떻게 될까요?
- 상속 받았다 하더라도 하위 클래스는 상위 클래스의 private 메서드에 접근할 수 없기에 새로운 메서드로 정의됩니다.

## 객체지향에 대해서 설명해주세요.
- 객체 지향은 프로그래밍 방법론 중 하나로, 현실 세계를 객체로 표현하여 객체들이 메시지를 주고받는 형태의 프로그램 설계 방식입니다.
#### 객체지향 4대 원칙
- `추상화`란 불필요한 부분을 숨기고 필요한 부분만 노출시키는 것입니다. ex) 인터페이스 
- `캡슐화`란 데이터를 외부로부터 보호하기 위해 감추는 것을 말합니다. ex) 접근제어자
- `상속`이란 하위 클래스가 상위 클래스의 값과 행위를 재사용하는 것을 말합니다. ex) extends
- `다형성`이란 하나의 메서드나 객체가 여러가지 형태를 가지는 것을 의미합니다. ex) 오버라이딩
#### 객체지향의 디미터 법칙에 대해서 설명해주세요
- 디미터 법칙은 최소한의 지식 원칙을 준수하는 것으로 자신과 관계없는 객체와 너무 많은 상호작용을 하지 말라는 법칙입니다.
#### 객체지향의 Tell, Don`t ask 법칙에 대해서 설명해주세요.
- 해당 법칙은 타 클래스로부터 질의를 하고 질의된 값에 대해서 비즈니스 로직을 처리하는 것이 아닌 명령형으로 비즈니스 로직을 처리하는 것입니다.

## SOLID(객체지향 5대 원칙)에 대해서 설명해주세요.
- **단일 책임 원칙 (Single Responsibility Principle, SRP)**: 클래스는 단 하나의 책임을 가져야 합니다.
- **개방-폐쇄 원칙 (Open/Closed Principle, OCP)**: 소프트웨어 구성 요소는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 합니다.
- **리스코프 치환 원칙 (Liskov Substitution Principle, LSP)**: 자식 클래스는 언제나 자신의 부모 클래스가 할 수 있는 행위를 수행할 수 있어야 합니다.
- **인터페이스 분리 원칙 (Interface Segregation Principle, ISP)**: 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
- **의존성 역전 원칙 (Dependency Inversion Principle, DIP)**: 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 합니다.
#### 의존성 역전 원칙의 실제 예를 알려주세요
- Service 클래스가 있고 Service 클래스가 DAO라는 구현체에 의존할 때 DAO 구현체가 MyBatis에서 JPA로 변경될 경우 이에 대한 수정 사항이 큽니다. 그런데 Service 클래스에서
의존하는 DAO가 인터페이스일 경우 변경 사항이 적어지면서 Database 구현체를 쉽게 변경할 수 있습니다.

## 동일성(identity)와 동등성(equality)에 대해 설명해주세요. (`equals()`, `==`)
- **동일성**: 비교하는 두 객체가 동일한 메모리 주소인지 비교하는 것입니다. 기본 데이터 타입의 값 비교나 같은 객체를 참조하는지 비교할 때 사용하며 `==` 연산자를 사용합니다.
- **동등성**: 비교하는 두 객체가 논리적으로 같은 값을 가지는지 확인하는 것입니다. 실제 값을 비교할 때 사용하며 `equals()` 메서드를 사용합니다.

## 원시 타입과 참조 타입의 차이에 대해 설명해주세요.
- **원시 타입**: 변수에 실제 값이 저장되는 타입을 의미합니다. 자바의 기본 데이터 타입을 의미하며, JVM의 스택 영역에 저장됩니다. 객체를 생성하지 않기에 메모리 측면에서 보다 효율적이며, 고정된 크기를 가지고 있습니다. 원시 타입은 `null`을 허용하지 않으며, 초기화되지 않은 경우 각 타입의 기본 값으로 초기화됩니다.
- **참조 타입**: 변수에 객체의 주소 값을 저장하며 실제 값은 힙 영역에 저장되는 데이터 타입을 의미합니다. 힙 영역에 저장되기에 크기가 고정되지 않고 동적입니다. 참조 타입은 `null`이 포함될 수 있으며, 값을 할당하지 않을 경우 `null`로 초기화됩니다.

class TempClass {
    String a = "zero";  // 참조 타입 변수
    Integer b = 0;      // 참조 타입 변수
    int c = 0;          // 원시 타입 변수
}
TempClass tempInstance = new TempClass();
- tempInstance는 new TempClass()의 메모리 주소를 힙 영역에 저장
- tempInstance.a, tempInstance.b 또한 힙 영역의 메모리 주소를 가지고 있으며 힙 영역의 메모리 주소에 실제 값이 존재
- tempInstance.c는 실제 값을 가지고 있음


## String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.

### String
- `new` 연산자로 생성된 `String`의 인스턴스는 불변합니다. 생성된 `String` 인스턴스에 문자를 더하거나 기존의 문자를 제거하면 이는 다른 `String` 객체입니다.
- `String` 객체는 값이 수정될 때마다 새로 객체를 생성하기에 객체 생성 비용이 계속됩니다.
- 값이 변경될 때마다 `String` 객체가 새로 생성되므로 값은 불변이므로 `Thread-Safe`합니다.

### StringBuffer
- `StringBuffer` 클래스는 문자열을 조작하기 위한 클래스입니다.
- `StringBuffer` 클래스에서 문자열을 변경 시 `String`과 달리 객체가 새로 생성되지 않고 값이 변경됩니다. 즉, `StringBuffer` 클래스의 값이 변경되더라도 `StringBuffer` 인스턴스의 주소 값은 동일합니다.
- `StringBuffer` 클래스는 `Thread-safe`합니다.

### StringBuilder
- `StringBuffer`와 동일한 기능을 하지만, `Thread-safe`하지 않습니다.

## Checked Exception과 Unchecked Exception에 대해 설명해주세요. 스프링 트랜잭션 추상화에서 rollback 대상은 무엇일까요?
- Checked Exception: 컴파일러가 예외 처리를 강제하는 예외로 컴파일 시점에 예외가 발생하는 Exception입니다.
- Unchecked Exception: 컴파일러가 예외 처리를 강제하지 않는 예외로 런타임 시점에 발생하는 Exception입니다.
- 기본적으로는 UnChecked Exception이 발생할 시 스프링에서 트랜잭션 롤백이 진행됩니다. 하지만 특정 Exception에 대해서 롤백을 원하는 경우 옵션 값에 원하는 Exception을 지정하면 해당 예외가 발생할 때 롤백이 진행됩니다.

#### 자바의 예외 클래스 계층 구조에 대해서 설명해주실 수 있나요?
```jsx
Throwable
├── Error
│   ├── OutOfMemoryError
│   ├── StackOverflowError
│   └── ...
└── Exception
    ├── IOException (Checked Exception)
    ├── SQLException (Checked Exception)
    ├── ClassNotFoundException (Checked Exception)
    └── RuntimeException (Unchecked Exception)
        ├── NullPointerException
        ├── ArrayIndexOutOfBoundsException
        ├── IllegalArgumentException
        └── ...
```

- Throwable: 에러와 예외 클래스의 최상위 클래스입니다.
- Error: Throwable로부터 상속 받은 하위 클래스이며 개발자가 처리할 수 없는 에러 클래스입니다.
- Exception: Throwable로부터 상속 받은 하위 클래스이며 개발자가 처리할 수 있는 클래스입니다. Exception은 Checked Exception과 RuntimeException(Unchecked Exception)으로 나뉘어집니다.

## Java8에서 추가된 기능에 대해서 설명해주세요.
- 람다 표현식: 익명 함수를 간단하게 표현하는 방법입니다.
- 함수형 인터페이스: 하나의 추상 메서드만을 가지는 인터페이스입니다.
- 메서드 참조: 메서드를 람다 표현식처럼 사용하는 방식으로 메서드를 간단하게 참조할 수 있는 방법입니다.
- 스트림 API: 컬렉션 데이터를 보다 쉽게 처리할 수 있는 API입니다.
- 인터페이스 Default Method: 인터페이스에 구현을 할 수 있는 메서드입니다.
- Optional 클래스: 자바의 NPE를 처리할 때 도와주는 클래스입니다.
- java.time 패키지: `java.util.Date`와 `java.util.Calendar` 의 단점을 보완한 클래스입니다.

#### 익명 함수란 무엇인가요?
    - 익명 함수란 이름이 없는 함수를 말합니다. 일반적으로 함수는 재사용을 하기 위해 사용되는데 익명 함수는 재사용을 하지 않고 일회성으로 사용하는 함수이며 함수를 사용하는 시점에 함수를 구현하여 사용합니다.
- 함수형 인터페이스를 사용하는 이유가 무엇인가요?
    - 자바에서 함수형 프로그래밍 방식을 사용하기 위해 사용합니다. 람다 표현식과 메서드 레퍼런스를 이용합니다.
- java.util.Date와 java.util.Calendar의 단점이 무엇인가요?
    - Date와 Calendar 클래스의 객체는 Non-Thread Safe 하기 때문에 여러 쓰레드가 동시에 객체의 값을 수정할 수 있기에 멀티 쓰레딩 환경에서 안전하지 않습니다.

## try-with-resource에 대해서 설명해주세요.
- resource를 명시적으로 해제 것이 아닌 자동으로 resource를 해제하는 방식으로 예기치 못한 자원 누수를 방지하는 방법입니다.
- try-with-resources에서 try 구문에 여러 resource가 선언 되었을 때 resource가 해제되는 순서는 어떻게 되나요?

```jsx
try (ResourceType1 resource1 = new ResourceType1();
     ResourceType2 resource2 = new ResourceType2()) {
} catch (Exception e) {}
```
- 선언 순서의 역순으로 해제가 됩니다. 위 예에서 resource2가 해제되고 resource1이 해제됩니다.

## 강한 결합과 느슨한 결합이 무엇인지 설명해주세요.
- 강한 결합: 의존하고 있는 클래스가 구현체일 때 강한 결합을 의미합니다. A 클래스가 B 구현체를 의존하고 있을 때 구현체인 B 클래스가 변경되면 이에 따라 A 클래스의 변경 사항도 많은 수준의 결합 정도를 의미합니다.
- 느슨한 결합: 구현 클래스를 의존하는 것이 아닌 인터페이스를 의존하는 방식을 느슨한 결합이라고 합니다. A 클래스가 B 인터페이스를 의존하고 B 인터페이스를 구현한 C 클래스가 변경되거나 다른 클래스에 교체 됨에도 A 클래스의 영향이 적은 결합 정도를 의미합니다.
#### 느슨한 결합을 진행할 때 인터페이스 말고 다른 방식은 무엇이 있을까요?
- 이벤트 기반 프로그래밍 방식이 있습니다. 결제가 성공하고 결제 성공에 따른 알람을 전송할 때 알람에 대한 구현체 혹은 인터페이스를 호출하는 것이 아닌 결제 성공이라는 이벤트를 통해 알람이 전송되는 방식을 진행할 수 있습니다.

## 직렬화와 역직렬화에 대해서 설명해주세요.
- 직렬화: 객체를 바이트 형식으로 바꾸는 것을 말합니다.
- 역직렬화: 바이트를 객체 형식으로 바꾸는 것을 말합니다.
#### 네트워크 통신을 진행할 때 객체를 직렬화해서 바이트 형식으로 송수신을 진행합니다. 왜 굳이 바이트 형식으로 전송할까요?
- 네트워크의 표준 단위는 바이트이며 네트워크에서 각 프로토콜마다 다른 규칙이 적용되는 것이 아닌 바이트라는 범용적인 단위를 사용하기 위해 직렬화 한 후 네트워크 송수신을 진행합니다.

## 자바의 동시성 이슈(공유자원 접근)에 대해 설명해주세요.
- 여러 쓰레드가 동일한 변수에 접근하여 값을 수정하는 경우 아래와 같은 동시성 이슈가 발생할 수 있습니다.
- 경쟁 상태 (Race Condition): 두 개 이상의 쓰레드가 공유 변수에 접근하여 예기치 못한 결과 값으로 변경되는 경우
- 교착 상태 (Deadlock): 두 개 이상의 쓰레드 각각이 자신이 자원을 가지고 있는 상태에서 다른 자원에 접근하여 모든 쓰레드들이 대기하는 경우
- 기아 상태 (Starvation): 쓰레드들이 우선 순위를 가진 상태여서 가장 낮은 우선순위를 가진 쓰레드는 접근하지 못하는 경우
- 빈번한 대기 (Livelock): 각 쓰레드가 동시에 락을 해제하고 락을 진행하여 결과적으로 아무런 진행이 없는 경우
#### 자바에서 동시성 이슈를 해결하기 위한 방법을 알려주세요.
- synchronized: 메서드에 선언되며 메서드 전체 영역에 대해서 동기화를 처리하는 방법입니다.
- volatile: 변수에 대해서 동기화를 처리하는 방식으로 각 스레드가 자신의 CPU Cache에 값을 쓰고 읽는 것이 아닌 메인 메모리에 값을 쓰고 읽는 것을 보장하는 방식입니다. 하지만 연산에 대해서는 원자성을 보장하지 않기에 복잡한 연산에는 적합하지 않은 키워드입니다.
- atomic: 원자성 연산을 보장하는 키워드로 현재의 값이 예상한 값과 일치하는지를 비교한 후 CPU Cache와 메인 메모리를 동기화하는 방식의 키워드입니다.

## Mutable 객체와 Immutable 객체의 차이점에 대해 설명해주세요.
- Mutable 객체: 객체가 생성된 이후에 자신의 상태 값을 수정할 수 있는 객체를 말합니다. StringBuilder, StringBuffer, ArrayList .. 등등이 있습니다.
- Immutable 객체: 객체가 생성된 이후 자신의 상태 값을 수정할 수 없는 객체를 말합니다. String, Integer 등등의 객체가 존재합니다.
#### Immutable 객체의 필드 값을 조회한 후에 해당 값을 수정하거나 사용하는 경우 얕은 복사와 깊은 복사, 방어적 복사 중 어떤 방식을 사용해야 하나요?
- 방어적 복사를 사용해야 합니다. 얕은 복사의 경우 메모리 주소를 복사하기에 복사본 객체가 값이 변경될 경우 원복 객체가 변경될 수 있으며 깊은 복사를 사용할 경우 불변 객체가 참조하고 있는, 가지고 있는 모든 객체를 복사해야 하는데 불변 객체는 이미 값이 수정되지 않음이 보장되기에 불필요한 메모리가 사용될 수 있습니다. 불변 객체는 이미 불변임을 보장했기에 방어적 복사를 하는 것이 효율적입니다.
#### 방어적 복사와 깊은 복사의 차이점이 무엇인가요?
- 방어적 복사: 객체가 외부에 의해 수정되지 않음을 보장하기 위해 사용하며 인자로 받는 객체 혹은 반환하는 객체에 대해서 생성자를 통해서 사본 객체로 대체하는 것을 말합니다.
- 깊은 복사: 기존 객체와 완전히 독립적인 객체를 생성하기 위해 사용하며 자바의 clone 메서드를 오버라이딩 하여 사용합니다.

## 자바에서 null을 안전하게 다루는 방법에 대해 설명해주세요.
- Optional이나 null check 로직을 이용한 방어 코드를 사용합니다.

## JDK와 JRE의 차이점을 설명하세요.
- JDK: JDK는 자바 애플리케이션을 개발하기 위한 전체 도구 모음입니다. JDK 안에 JRE가 포함되어 있으며 JDK 말고도 컴파일러나 디버거 등등이 존재합니다.
- JRE: JRE는 자바 애플리케이션을 실행하기 위한 환경으로 JVM과 자바 라이브러리를 포함하여 자바 프로그램이 실행될 수 있도록 지원합니다.

## Spring IOC/DI는 어떻게 동작하나요?
- 먼저 IOC는 Inversion Of Control의 약자로 제어의 역전이라는 의미를 가지며 프로그램 제어의 흐름을 개발자가 아닌 프레임워크로 넘기는 것을 말합니다.  스프링에서의 IOC란 빈을 생성하고 관리하며 빈들간의 의존성을 주입해주는 것을 개발자가 아닌 스프링 컨테이너가 진행하는 것을 말합니다. 결과적으로는 스프링에서 IOC를 구현한 것이 스프링 컨테이너입니다.
- 스프링 컨테이너의 동작 방식: 스프링 컨테이너 초기화 → 빈 스캔 → 빈 등록 → 빈 생성 → 의존성 주입 → 빈초기화 → 빈 사용 → 빈 소멸
- 스프링 컨테이너 초기화 과정: 톰캣 서버 실행 → SpringApplication.run 메서드 호출 → ApplicationContext 인터페이스의 구현체 클래스의 인스턴스 생성 → 인스턴스가 생성 되면서 스프링 컨테이너가 초기화
- BeanFactory와 ApplicationContext의 차이점: BeanFactory는 가장 기본적인 스프링 컨테이너의 인터페이스로써 빈을 생성하고, 의존성을 주입하며, 기본적인 라이프사이클 관리를 제공합니다. 또한 Lazy Initialization(지연 로딩) 형식이라 빈을 사용할 때 빈을 로딩합니다. ApplicationContext는 BeanFactory를 확장한 인터페이스로써 국제화 처리, 이벤트 프로그래밍, AOP, 선언적 트랜잭션 등등을 추가적으로 지원하며 Eager Initialization(즉시 로딩) 방식이여서 런타임 시 미리 모든 빈을 로딩시킵니다.
- 여기서 로딩이란 초기화를 말하는 것이 아닌 메모리로 불러오는 것을 말합니다.
- 빈 스캔 과정: @Bean 붙은 클래스에 대해서 컴포넌트 스캔을 진행하는 것입니다.
- 빈 등록: 스프링 컨테이너 내부적으로 스프링 빈 이름을 key 값으로, 빈의 등록된 클래스의 인스턴스가 value 값으로 저장됩니다.
- 빈 생성: 등록된 빈을 인스턴스화 하는 것을 말합니다.
- 빈 초기화: 빈이 생성되고 의존성 주입이 끝난 후 빈의 상태를 설정하거나 추가 작업을 하는 것으로 @PostConstruct 하는 것을 말합니다.
- Spring DI 동작 방식: 스프링에서 의존성 주입의 동작 방식은 리플렉션 기반으로 진행됩니다.
  1) 빈 등록 시 수집된 빈의 의존성 주입 방법에 대한 메타 데이터를 BeanDefinition 객체에서 확인
  2) BeanPostProcessor(빈 후처리기)에서 각 빈의 의존성 주입 방법 확인
  3) DependencyResolver 클래스를 통해서 의존 주입을 진행하는 객체를 찾고 리플렉션을 이용해서 주입

## Spring Bean이란 무엇인가요?
- 스프링 컨테이너에 의해 관리되는 객체를 말합니다. 즉 스프링 빈은 클래스가 아닌 인스턴스입니다.
## Spring Bean에 직접 접근하는 방법은 무엇인가요?
- ApplicationContext의 getBean 메서드를 통해서 가능합니다.

## 스프링 Bean의 생성 과정을 설명해주세요.
- 빈 스캔 → 빈 등록 → 빈 생성 → 의존성 주입 → 빈 초기화

## 스프링 Bean의 Scope에 대해서 설명해주세요.
- 먼저 빈 스코프의 정의는 빈의 생명주기와 범위이며 이 기준은 스프링 컨테이너입니다.
- 싱글톤 타입: 스프링 컨테이너에서 하나의 인스턴스만 생성되며 스프링 컨테이너가 초기화되고 소멸될때까지의 생명 주기를 가지고 있습니다.
- 프로토 타입: 빈이 요청될때마다 생성되며 이에 따라 각 빈 인스턴스는 별개의 빈 인스턴스입니다. 스프링 컨테이너에서 빈이 생성되고 의존관계를 주입할때까지의 생명 주기를 갖습니다.
- 리퀘스트 타입: 각 HTTP 요청마다 새로운 빈 인스턴스가 생성되고, 요청이 완료되면 빈이 소멸됩니다.
- 세션 타입: 각 HTTP 세션마다 새로운 빈 인스턴스가 생성되고, 세션이 종료되면 빈이 소멸됩니다.
- 애플리케이션 타입: 프링 애플리케이션이 시작될 때 빈이 생성되고, 애플리케이션이 종료될 때 소멸됩니다.

## IoC 컨테이너의 역할은 무엇이 있을까요?
- 빈의 라이프 사이클을 관리하고 빈간의 의존성 주입을 진행합니다.

## DI 종류는 어떤것이 있고, 이들의 차이는 무엇인가요?
- 생성자 주입: 생성자를 통해서 의존하는 객체를 주입하는 방식으로 객체가 생성될 때 주입을 진행하기에 의존성에 대하여 불변성을 보장합니다. 또한 테스트에 용이합니다.
- 세터 주입 (Setter Injection): set method에 @Autowired를 사용하여 의존하는 객체를 주입하는 방식으로 선택적으로 의존성을 가질 수 있습니다.
- 필드 주입 (Field Injection): **`Autowired`** 어노테이션을 필드에 붙여서 의존하는 객체를 주입하는 방식으로 간편하다는 장점이 있습니다.

## Autowiring 과정에 대해서 설명해주세요.
1) 빈의 생성 및 등록: 스프링 IoC 컨테이너는 설정 파일이나 어노테이션을 기반으로 빈을 생성하고, BeanDefinition 객체에 빈에 대한 메타 데이터를 저장합니다.
2) 빈의 초기화 전 처리 (BeanPostProcessor)
- 스프링 IoC 컨테이너는 설정 파일이나 어노테이션을 기반으로 빈을 생성하고, BeanDefinition 객체에 빈에 대한 메타 데이터를 저장합니다.
- 스프링 IoC 컨테이너는 모든 빈이 생성된 후, 등록된 BeanPostProcessor들을 적용합니다. AutowiredAnnotationBeanPostProcessor는 이러한 BeanPostProcessor의 일종으로, 빈의 초기화 전에 @Autowired 어노테이션이 붙은 필드나 메서드를 찾아 해당 필드에 적절한 빈을 주입합니다.
3) AutowiredAnnotationBeanPostProcessor에 의한 의존성 주입
- AutowiredAnnotationBeanPostProcessor는 리플렉션을 사용하여 @Autowired가 붙어 있는 필드나 메서드에 접근합니다. 그리고 스프링 IoC 컨테이너에서 해당 타입의 빈을 검색하여 주입합니다.

## Spring Web MVC의 Dispatcher Servlet의 동작 원리에 대해서 간단히 설명해주세요.
1) 요청 수신**: 모든 HTTP 요청을 수신합니다.
2) 핸들러 매핑**: 요청에 맞는 핸들러(컨트롤러)를 찾습니다.
3) 핸들러 호출**: 핸들러가 요청을 처리하고, 모델과 뷰 이름을 반환합니다.
4) 뷰 리졸버**: 뷰 이름을 실제 뷰 객체로 변환합니다.
5) 뷰 렌더링**: 뷰가 모델 데이터를 사용하여 최종 응답을 생성합니다.
6) 응답 전송**: 생성된 응답을 클라이언트에게 전송합니다.

## 프론트 컨트롤러 패턴이란 무엇인가요?
- 요청에 대해서 적합한 컨트롤러로 위임하는 것을 말합니다.
- JSP와 스프링에서는 DispatcherServlet이 모든 요청을 수신한 후 적합한 컨트롤로 전달합니다.
## Servlet은 무엇인가요?
- 서블릿은 HTTP 요청을 받아 처리하고, 그 결과를 웹 브라우저에게 돌려주는 역할을 하는 자바 API입니다.

## Servlet Filter와 Spring Interceptor의 차이는 무엇인가요?
- 필터: 서블릿 컨테이너에 존재하며 클라이언트와 디스패처 서블릿간의 요청과 응답에 대해서 처리
- 인터셉터: 스프링 컨테이너에 존재하며 디스패처 서블릿과 컨트롤러 사이의 요청과 응답에 대해서 처리
## Filter에 대해서 스프링 빈으로 등록할 수 있나요?
- @Component와 @WebFilter와 @ServletComponentScan를 이용해서 가능합니다.

## Spring에서 CORS 에러를 해결하기 위한 방법을 설명해주세요.
1. WebMvcConfigurer를 이용하여 CORS 설정
2. 컨트롤러에서 @CrossOrigin를 이용

## Bean/Component 어노테이션에 대해서 설명해주시고, 둘의 차이점에 대해 설명해주세요.
- @Bean과 @Componant의 차이점: @Bean은 메서드 레벨에서 사용하며 외부 라이브러리를 스프링 환경에 호환되도록 처리할 때 사용합니다. @Componant는 클래스 레벨에서 사용하며 컴포넌트 스캔에 따라 자동으로 빈에 등록되도록 할 때 사용합니다.
