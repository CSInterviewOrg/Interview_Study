# Java Concepts

## JVM의 구조와 Java의 실행방식

- **JVM 구조**
  - JVM은 다음과 같은 구성 요소로 이루어져 있습니다:
    - **클래스 로더 (Class Loader)**: Java 클래스 파일을 로드하여 JVM으로 전달합니다.
    - **런타임 데이터 영역 (Runtime Data Area)**: JVM이 프로그램을 실행하는 동안 필요한 메모리 영역을 관리합니다.
    - **실행 엔진 (Execution Engine)**: 바이트코드를 실제 기계어로 변환하여 실행합니다.
    - **네이티브 메소드 인터페이스 (Native Method Interface)**: JVM에서 네이티브 코드를 호출할 수 있게 해줍니다.
    - **네이티브 메소드 라이브러리 (Native Method Library)**: 네이티브 코드가 포함된 라이브러리입니다.

- **Java의 실행 방식**
  - `.java` 파일이 `javac` 컴파일러에 의해 `.class` 파일로 컴파일됩니다.
  - 클래스 로더가 `.class` 파일을 JVM에 전달합니다.
  - JVM의 실행 엔진이 `.class` 파일을 실행하여 Java 프로그램이 실행됩니다.

## GC(Garbage Collection)

- **GC란 무엇인가?**
  - GC는 자바와 같은 프로그래밍 언어에서 자동으로 메모리를 관리하는 시스템입니다.
  - 개발자가 직접 메모리를 관리해야 하는 C/C++와 달리, GC는 메모리 누수와 잘못된 메모리 접근을 방지해줍니다.

- **GC가 필요한 이유**
  - 메모리 관리 실수를 줄이고, 개발자가 메모리 관리에 신경 쓰지 않아도 되게 합니다.

- **GC의 동작 방식**
  - GC는 더 이상 참조되지 않는 객체를 메모리에서 제거합니다.
  - **마크 앤 스윕(Mark and Sweep) 알고리즘**:
    - GC가 루트 객체부터 참조 가능한 모든 객체를 마킹합니다.
    - 마킹되지 않은 객체는 메모리에서 제거됩니다.
    - 제거된 공간은 새로운 객체를 위한 메모리로 재사용됩니다.
  - **Generational Garbage Collection**:
    - 객체의 생존 시간에 따라 Young Generation, Old Generation, Permanent Generation(Metaspace)으로 나누어 GC를 진행합니다.
    - Young Generation: 새로운 객체가 생성되는 영역이며, 짧은 주기의 GC가 진행됩니다.
    - Old Generation: Young Generation에서 살아남은 객체들이 존재하는 영역입니다.
    - Permanent Generation(Metaspace): 클래스 메타데이터와 상수 정보가 존재하는 영역으로, Full GC 시에 정리됩니다.

## 컬렉션 프레임워크

- **컬렉션 프레임워크란?**
  - 데이터를 다루는 자료구조와 알고리즘을 표준화된 방식으로 제공하는 API입니다.

- **컬렉션 인터페이스**
  - **Collection**이라는 루트 인터페이스 하위에 `List`, `Queue`, `Set` 인터페이스가 존재하며 이에 대한 구현체들이 존재합니다.
    - **List 인터페이스**: 순서가 보장되며 중복 요소가 가능한 자료구조 인터페이스입니다.
    - **Queue 인터페이스**: FIFO 구조이며 중복 요소가 가능한 자료구조 인터페이스입니다.
      - 우선순위 큐를 사용할 경우 `PriorityQueue` 구현체를 사용하면 됩니다.
    - **Set 인터페이스**: 중복을 허용하지 않으며 순서를 보장하지 않는 자료구조 인터페이스입니다.
  - **Map 인터페이스**: Collection 인터페이스의 하위 인터페이스는 아니지만 일반적으로 Collection의 한 종류로 판단합니다.
    - `Map 인터페이스`는 key와 value 구조의 인터페이스이며 순서가 보장되지 않습니다.
    - 순서가 보장된 `Map` 인터페이스를 사용할 경우 `LinkedHashMap` 구현체를 사용하면 됩니다.
  - 컬렉션 인터페이스는 모두 제네릭으로 정의되어 있으며 표준화된 API를 제공합니다.

## 제네릭(Generic)

- **제네릭이란?**
  - 제네릭은 일반화된 데이터 타입을 의미하며, 외부에서 데이터 타입을 지정하여 유연하게 사용할 수 있습니다.
  - 제네릭은 컴파일 시점에 타입 안정성을 보장합니다.

## 어노테이션(Annotation)

- **어노테이션이란?**
  - 자바의 어노테이션은 코드의 메타데이터를 추가하는 특수한 인터페이스입니다.
  - 정의된 어노테이션에 따라 컴파일 시점 또는 런타임 시점에 특정한 기능이 동작합니다.

## 오버라이딩(Overriding)과 오버로딩(Overloading)

- **오버로딩(Overloading)**
  - 같은 클래스 내부에서 메서드를 재정의하는 것을 말합니다.
  - 메서드 이름이 동일해야 하며, 매개 변수의 개수, 타입, 순서가 달라져야 구분됩니다.
  - 리턴 타입은 오버로딩에 고려되지 않습니다.

- **오버라이딩(Overriding)**
  - 상위 클래스의 메서드를 하위 클래스에서 재정의하는 것을 말합니다.
  - 메서드의 반환 타입, 메서드 이름, 매개 변수가 모두 동일해야 합니다.
  - 재정의된 메서드는 상위 클래스의 메서드보다 더 제한적인 접근 제어자를 가질 수 없습니다.
  - `@Override` 어노테이션을 사용하면, 컴파일러가 오버라이딩이 제대로 되었는지 확인할 수 있습니다.

- **정적(static) 메서드는 왜 오버라이딩이 불가능한가?**
  - 오버라이딩은 런타임 시점에 실행되지만, 정적 메서드는 컴파일 시점에 이미 정의되어 있어 오버라이딩이 불가능합니다. 대신 하위 클래스에서 재정의할 경우 하위 메서드가 호출되는 Hidding(숨김)이 적용됩니다.

- **생성자는 왜 오버라이딩이 불가능한가?**
  - 생성자는 자기 자신의 클래스를 인스턴스로 초기화하는 메서드이므로 오버라이딩이 불가능합니다.

## 인터페이스와 추상 클래스의 차이점

- **추상 클래스**
  - 다중 상속이 불가능하여 하나의 클래스만 상속받을 수 있습니다.
  - 일반 구현 메서드와 추상 메서드가 존재하며, 추상 메서드는 하위 클래스에서 구현해야 합니다.
  - 추상 클래스는 생성자를 가질 수 있습니다.

- **인터페이스**
  - 다중 상속이 가능하며, 구현체에서 여러 인터페이스를 상속받을 수 있습니다.
  - 인터페이스는 메서드의 시그니처만 정의하고, 구현체에서 메서드를 구현해야 합니다.
  - 자바 8 이후에는 `default` 메서드와 `static` 메서드에서 구현이 가능하게 되었습니다.
  - 인터페이스 메서드의 기본 접근 제어자는 `public`입니다.
  - 인터페이스는 생성자를 가질 수 없습니다.

## 클래스와 객체

- **클래스**는 요리의 레시피와 같고, **객체**는 레시피로 만든 음식입니다.
