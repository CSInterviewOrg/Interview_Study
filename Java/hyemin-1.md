# JAVA

## JVM의 구조와 Java의 실행방식을 설명해주세요. 

> java의 실행방식 <br>
- java 코드는 javac 컴파일러에 의해 java 바이트 코드(.class)로 변환
- java 바이트 코드는 jvm에 의해 메모리로 로드되고, 검증된 후 실행
- jvm의 Execution Engine은 인터프리터와 JIT 컴파일러를 사용해 바이트코드를 해석하거나 기계어로 
변환해 실행
- jvm은 메모리를 자동으로 관리하며, 필요시 JNI를 통해 네이티브 메서드(c, c++ 등)도 호출
- 프로그램 실행이 완료되면 jvm은 gc과 리소스 해제를 통해 메모리를 정리하고 종료

> jvm 역할 <br>

자바 애플리케이션을 클래스 로더를 통해 읽어 자바 api와 함께 실행하는 것

- Class Loader는 동적 로딩을 통해 필요한 클래스들을 로딩 및 링크하여 Runtime Data Area에 올림
- Runtine Data Area에 로딩된 바이트 코드는 Execution Engine을 통해 해석 
- 이 과정에서 Execution Engine에 의해 gc의 작동과 스레드 동기화가 이루어짐.

> jvm 구조 <br>

클래스 로더 <br>
 - jvm 내로 .class 파일을 엮어서 JVM의 메모리 영역인 Runtime Data Areas에 배치 
 
실행엔진 ( Execution Engine ) 
 - 클래스 로더를 통해 런타임 데이터 영역에 배치된 바이트 코드를 명령어 단위로 읽어서 실행 <br>
   ( 인터프리터와 JIT 컴파일러 방식을 혼합하여 바이트 코드 실행) 
 * 인터프리터 <br>
   : 바이트 코드 명령어를 하나씩 읽어서 해석하고 바로 실행 ( 전체적인 속도는 느림 ) 
 * JIT 컴파일러 (Just in time) <br>
   : 인터프리터의 단점을 보완하기 위해 도입. 반복되는 코드를 발견하여 바이트 코드 전체를 컴파일하여 native code로 변경하고, 
   그 이후에는 인터프리팅 하지 않고 캐싱해 두었다가 네이티브 코드(c, c++) 로 직접 실행하는 방식
 * 가비지 콜렉터 (Garbage Collector) <br>
 : heap 메모리 영역에서 더는 사용하지 않는 메모리를 자동으로 회수. 개발자가 따로 메모리 관리를 하지않아도 됨.

런타임 데이터 영역 (Runtime Data Areas)
 - jvm의 메모리 영역. 자바 애플리케이션이 실행할 때 사용되는 데이터들을 적재하는 영역

 * 메소드 영역 (Method Area) <br>
 : jvm이 시작될때 생성되는 공간. 바이트 코드를 처음 메모리 공간에 올릴때 초기화되는 대상을 저장하기 위한 메모리 공간 <br>
 : 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보, 메소드 이름, 리턴 타입, 함수 매개변수, 클래스/인터페이스 여부 , 타입의 속성 
 * 힙 영역 (Heap Area) <br>
 : 데이터를 저장하기 위해 런타임 시 동적으로 할당하여 사용하는 영역. <br>
 : new 연산자로 생성되는 클래스, 인스턴스 변수, 배열 타입 등 <br>
 : GC 대상
 
 * 스택 영역 (Stack Area) <br>
 : 메소드가 호출될때마다 프레임이 만들어지며, 현재 실행중인 메소드 상태 정보를 저장 <br>
 : 임시적으로 사용되는 변수, 정보들이 저장되는 영역
 * PC Register ( Program Counter register ) <br>
 : 스레드가 시작될때 생성. 현재 수행중인 jvm 명령어 주소를 저장하는 공간. <br>
 * 네이티브 메소드 스택 (Native Method Stack) <br>
 : 기계어로 작성된 프로그램을 실행시키는 영역
 
자바 네이티브 인터페이스
- 자바 애플리케이션에서 C, C++, 어셈블리어로 작성된 함수를 사용할 수 있는 방법을 제공 <br>

네이티브 메소드 라이브러리 
- c, c++ 로 작성된 라이브러리를 칭함.

## GC가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.

> 정의 
 - 자바의 메모리 관리 방법중 하나로 jvm의 heap 영역에서 동적으로 할당했던 메모리 중 
필요없게 된 메모리 객체를 모아 주기적으로 제거하는 프로세스

> 필요이유 
 - 메모리 누수 방지 : 사용하지 않는 객체를 해제하지않으면, 메모리 누수 발생 
 - 안전성 향상 : 수동으로 메모리 관리시의 오류를 방지하여 프로그램의 안정성 증진
> 동작방식 

 : Mark and Sweep 알고리즘 기반으로 동작
 - Marking : 루트 객체에서 그래프 순회를 통해 참조되고 있는 모든 객체 추적
 - Sweeping : 마킹 단계에서 unreachable 상태로 표시된 객체들을 heap에서 제거
 - Compacting : 메모리 단편화를 방지하기 위해 남아있는 객체들을 한쪽으로 모아서 연속적인 메모리 블록을 만듬

## 컬렉션 프레임워크에 대해서 설명해주세요.
> 정의
-  객체들을 효율적으로 저장하고 관리하기 위한 클래스와 인터페이스들의 집합.( 자료구조의 종류를 자바 클래스로 구현한 모음집 ) <br>
- Collection 인터페이스와 Map 인터페이스로 나뉨 
> 종류 
- List : 순서가 있는 요소의 집합. 중복 요소 허용 (arraylist, linkedlist, vector) 
( 배열과 리스트의 차이점은 리스트는 자료형 크기가 고정이 아닌데, 배열은 고정) 
- Set : 순서 보장 없음. 중복되지않는 요소의 집합 (hashset, linkedhashset..), 순서가 없으므로 get 메서드 없음
- Queue : 선입선출 구조. 
- Map : key-value 쌍으로 데이터 저장. 키 중복 불가. value 중복 가능 (hashmap, linkedhashmap..) 


## 제네릭에 대해서 설명해주세요.
> 정의
- java에서 코드의 재사용성과 타입 안정성을 높이기 위해 도입된 기능.
> 특징
- 제네릭을 사용하면 클래스나 메서드에서 사용할 데이터 타입을 외부에서 지정할 수 있어, 다양한 타입에 대해 동일한 코드 작성 가능
- 제네릭을 사용하면 컴파일 시점에서 타입 검사가 이루어지기 때문에 런타임에서 발생할 수 있는 classCastException을 방지


## 애노테이션에 대해서 설명해주세요.
> 정의
- java에서 메타데이터를 제공하는 일종의 마커로, 코드에 추가적인 정보 제공 및 특정 동작을 수행하도록 하는데 사용
> 특징
- 주석처럼 코드에 부가적인 정보를 제공, 컴파일러나 런타임시에도 정보 활용 가능
> 예시
- 컴파일러 지시 : @Override, @deprecated 처럼 컴파일러에게 특정 동작을 지시
- 런타임 지시 : @Autowired 처럼 스프링 프레임워크에서 빈 주입 등 런타임 시 특정 기능을 자동으로 처리하는 동작 지시
- 빌드 및 배포 도구 : @Entity, @Table 등 JPA 어노테이션으로 ORM을 정의하며, 엔티티 클래스가 디비 데이블과 어떻게 매핑되는지 지정.
- 커스텀 어노테이션을 정의도 가능. @interface 어노테이션을 지정.


## 오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있을까요?
> 오버라이딩 
- 부모 클래스의 메소드의 동작만을 재정의하는것이므로, 메소드의 선언부(매개변수 갯수, 리턴타입)는 기존 메소드와 같아야함
- 부모 클래스의 메소드보다 좁은 접근 제어자로 변경할수 있음

> 오버로딩 (overloading) 
- 같은 이름의 메소드를 매개변수의 개수나 타입을 다르게 정의해서 다양한 상황에서 사용하는 것을 의미
- 반환 타입과는 관계가 없음
- 오버로딩의 개념없이 메서드명을 다르게하여 각기 다른 메서드로 정의해서 사용해도 상관은 없으나, 객체지향의 다형성을 추구하기 위해 사용

## 인터페이스와 추상클래스의 차이점에 대해 설명해주세요.
- 추상 클래스는 단일 상속이지만, 인터페이스는 다중 구현이 가능 
- 추상 클래스는 필드와 메서드를 모두 가질 수 있지만, 인터페이스는 기본적인 메서드만 정의 가능
- 추상 클래스는 관계를 명확히 하고, 부모의 기능을 확장시키는데 목적이 있지만, 인터페이스는 클래스가 특정 기능을 구현하도록 강제하는 목적



## 클래스는 무엇이고 객체는 무엇인가요?
> 클래스
- 객체를 생성하기 위한 설계도. 객체의 속성과 메서드를 정의. jvm에 메서드 영역에 저장.
> 객체
- 클래스를 기반으로 만들어진 실제 인스턴스. jvm의 힙 영역에 할당
> 정리
- 클래스는 객체 지향 프로그래밍의 기본 단위로 객체를 생성하기 위한 설계도이고, 객체는 이 클래스를 기반으로 생성된 실체. 
실제로 프로그램에서 사용되는 데이터와 기능을 포함한 인스턴스.

## Static이란 무엇인가요?
- 클래스 레벨에서 변수, 메서드, 초기화 블록을 정의할때 사용
- static 으로 선언된 변수나 메서드는 클래스에 속하며, 이는 클래스가 메모리에 로드될때 초기화되며, 
인스턴스화 없이 클래스 이름을 통해 직접 접근

## 자바의 원시타입(Primitive type)들은 무엇이 있으며 각각 몇 바이트를 차지하나요?
- 정수형: byte (1바이트), short (2바이트), int (4바이트), long (8바이트) <br> 
- 실수형: float (4바이트), double (8바이트) <br>
- 문자형: char (2바이트, 유니코드) <br>
- 논리형: boolean (크기 명시 없음, 보통 1비트 또는 1바이트) <br>

## 접근 제어자의 종류와 이에 대해 설명해주세요.
- 클래스, 변수, 메서드 등에 대한 접근 권한을 설정하여 코드의 캡슐화/정보 은닉에 사용
- private : 같은 클래스 내에서만 접근 가능 
- default : 같은 패키지 내에서만 접근 가능
- protected : 같은 패키지 내, 다른 패키지의 자손 클래스에서 접근 가능
- public : 접근 제한 없음

## 객체 지향에 대해서 설명해주세요.
- 객체(Objects)들이 모여서 상호 협력하면서 데이터를 처리하는 방식의 프로그래밍 설계 방법 (데이터와 그 데이터를 처리하는 메서드를 하나의 객체로 묶어, 이러한 객체들 간의 상호작용을 통해 프로그램을 설계하고 개발하는 프로그래밍 )
- 객체 지향 프로그래밍 : 객체를 중심으로 소프트웨어를 설계하고 개발하는 패러다임으로, 객체들이 서로 상호작용하여 프로그램이 동작하게됨. 코드의 재사용성, 확장성, 유지보수성을 높이는것
- 객체 지향 4가지 핵심 원칙 : 캡슐화, 상속, 다형성, 추상화
- 추상화 ( Abstraction ) : 클래스를 정의할 때 불필요한 부분들을 생략하고, 객체의 속성에서 중요한 것에 중점을 두어 개략화 하는 것 <br>
&rarr; 데이터 추상화 : 객체의 관련 속성만 표시 ( 대상을 간단한 개념으로 일반화 )  <br>
&rarr; 제어 추상화 : 불필요한 세부정보는 숨김 ( 사용자에게 해당 메서드의 작동방식과 같은 내부 로직은 숨김 )
- 상속 ( Inheritance ) : 상위 클래스의 속성과 기능을 재사용하여 하위 클래스가 전부 물려받는것
- 캡슐화 ( Encapsulation ) : 객체의 속성(Field)과 행위(Method)를 하나로 묶고, 외부로부터 내부를 감싸 숨겨 은닉.
ex) protected, default , private
- 다형성 ( Polymorphism ) : 같은 자료형에 여러가지 타입의 데이터를 대입하여 다양한 결과를 얻어낼 수 있는 성질
ex) 오버로딩, 오버라이딩, 업캐스팅, 다운캐스팅, 인터페이스, 추상메소드, 추상클래스 .. 

## SOLID 에 대해서 설명해주세요 ( 객체 지향 5대 원칙 ) 
- SRP( Single Responsibility Principle ) : 단일 책임 원칙
- OCP ( Open Closed Principle ) : 개방 폐쇄 원칙
- LSP ( Listov Substution Principle ) : 리스코프 치환 원칙
- ISP ( Interface Segregation Principle ) : 인터페이스 분리 원칙
- DIP ( Dependency Inversion Principle ) : 의존 역전 원칙

- SRP : 하나의 클래스는 하나의 책임만 가져야 함. 즉, 하나의 클래스는 하나의 기능 담당하여 하나의 책임을 수행하는데 집중되도록 클래스를 따로 여러개 설계하라는 원칙
- OCP : 확장에 열려있어야 하며, 수정에는 닫혀있어야한다. 즉, 기능 추가 요청이 오면 클래스는 확장을 통해 손쉽게 구현하면서, 확장에 따른 클래스 수정은 최소화 하도록 프로그램을 작성하는 설계 기법
        추상화 사용을 통한 관계 구축을 권장-> 다형성과 확장을 가능케 하는 객체지향의 장점을 극대화하는 기본적인 설계 원칙
- LSP : 자식 클래스는 부모 클래스의 기능을 확장하되, 부모 클래스의 기능을 깨지 않도록 일관성을 유지해야 한다는 원칙
- ISP : 클라이언트는 자신이 사용하지 않는 인터페이스에 의존하지 않아야 한다는 원칙
- DIP : 어떤 class 를 참조해서 사용해야하는 상황이 생긴다면, 그 class 를 직접 참조하는 것이 아니라 그 대상의 상위 요소(추상 클래스, 인터페이스) 로 참조하라는 원칙

## 동일성(identity)와 동등성(equality)에 대해 설명해주세요. (equals(), ==)
- 동일성 : 두 객체가 메모리상에서 같은 객체인지를 판단. 즉, 동일한 메모리 주소를 가리키는지 확인. "==" 연산자를 사용하여 비교
- 동등성 : 두 객체의 값이나 상태가 같은지를 판단. 즉, 객체가 다르더라도 내부 값이 동일하면 동등하다고 판단. "equals()" 메서드를 사용하여 비교

## 원시타입과 참조타입의 차이에 대해 설명해주세요.
- 기본형 ( primitive type ) : 계산을 위한 실제 값 . 모든 값 타입은 메모리 스택에 저장
- 참조형 ( reference type ) : 객체의 주소를 저장 . 배열 타입, 열거 타입, 클래스, 인터페이스 . 메모리의 힙에 실제 값을 저장하고, 그 참조값(주소값)을 갖는 변수는 스택에 저장
> 원시타입과 참조타입의 차이점

 원시타입은 값 자체를 저장하고, 스택 메모리에 저장. 참조타입은 객체의 주소를 저장하며, 스택에는 주소값이 실제 객체는 힙 메모리에 저장

## String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.
- 모두 문자열을 다루지만, 동작 방식, 성능, 스레드 안정성에 차이가 있음
> String
 - String 클래스는 불변 객체. 한번 생성된 문자열은 변경할 수 없고, 문자열을 수정하는 작업에는 항상 새로운 객체를 생성 
- 문자열을 변경할 때마다 새로운 객체를 생성하므로, 메모리 낭비 발생, 성능 저하, String 객체는 불변이므로 스레드 안전
> Stringbuilder 
- 가변 객체로, 문자열을 수정할 때 객체를 새로 생성하지 않고, 기존 객체를 수정 
- 문자열을 자주 변경하는 작업에서 사용되며, 스레드 안정성이 필요 없는 상황에서 성능 최적화 가능
> StringBuffer 
- Stringbuilder와 유사하지만, 동기화 되어 있어 스레드 안전. 다중 스레드 환경에서 문자열을 자주 수정해야 하는 경우에 사용


## Checked Exception과 Unchecked Exception에 대해 설명해주세요. 
스프링 트랜잭션 추상화에서 rollback 대상은 무엇일까요?
> Checked Exception
- 컴파일 시점에 체크되는 예외
- 개발자가 명시적으로 처리해야함 ( try-catch-throws )
- Exception 클래스를 직접 상속
- I/O, 파일, 네트워크, DB 작업 등 외부 자원과 관련된 작업에서 발생
- IOException, SQLException, ClassNotFoundException

> Unchecked Exception
- 런타임 시점에 발생하는 예외 
- 컴파일러가 강제하지 않으므로 명시적으로 처리 하지 않아도 됨. 개발자가 코드를 잘 작성하면 피할 수 있는 예외
- RuntimeException 클래스를 상속
- Null 참조, 배열 인덱스 초과, 잘못된 연산 등에서 발생 
- NullPointerException, ArrayIndexOutOfBoundsException, IllegalArgumentException.. 

> 예외( Exception )vs 오류 ( Error ) 
- 예외( Exception )
: 프로그램 실행 중 발생할 수 있는 예상 가능한 문제 

- 오류( Error )
: 시스템 레벨에서 발생하는 문제로, 일반적으로 개발자가 예측하거나 처리할 수 없는 문제. 주로 JVM에서 발생하며, 프로그램의 비정상 종료를 초래할 수 있음

> 스프링 트랜잭션 추상화에서 rollback 대상은 무엇일까요?
- Unchecked Exception(RuntimeException)과 Error가 발생할때 트랜잭션을 롤백

> Checked Exception이 발생해도 트랜잭션을 롤백하려면 어떻게 해야 하나요? 
- @Transactional 어노테이션의 rollbackfor 속성을 사용해 롤백 대상 지정 가능 
- @Transactional(rollbackFor = Exception.class) 로 설정하면 롤백 가능

> 스프링 트랜잭션에서 기본적으로 RuntimeException과 Error만 롤백하는 이유는? 
- RuntimeException과 Error는 예측 불가능한 비정상적인 상황을 나타내므로, 데이터의 일관성을 위해 자동으로 롤백. 
- Checked Exception은 비즈니스 로직의 일부로 발생할 수 있어 롤백 여부를 개발자가 선택할수 있음

> OutOfMemoryError에 대해서 발생시점, 예방 방법, 처리 방법에 대해서 알려주세요 
- JVM의 힙 메모리나 메타스페이스 영역에서 사용할 수 있는 메모리가 부족할 때 발생하는 런타임 오류 
- 발생 시점 
: 메모리 누수 , 메모리 과다 사용 ( 대량의 데이터를 힙 메모리에 적재하거나, 대규모 컬렉션을 무한 확장시 ), 잘못된 객체 관리 ( 무한 루프 ) 
- 예방 방법 
: 사용이 끝난 객체를 명시적으로 참조 해제 , 메모리 효율이 좋은 데이터 구조 사용하여 불필요한 메모리 사용 줄임 , JVM 옵션 ( -Xms, -Xmx ) 를 설정하여 힙 메모리 크기 조정 , 불필요한 객체 생성 피함
- 처리 방법 
: 발생 즉시 큰 객체나 불필요한 참조를 해제하여 메모리 확보 후 작업 재시도 , 메모리 부족이 근본적으로 자원의 한계에서 발생했다면, JVM 힙 메모리 설정을 늘리거나, 분산 처리로 재설계하여 시스템 부담 줄이기, 애플리케이션 재시작


## Java8에서 추가된 기능에 대해서 설명해주세요.
- 람다 표현식
: 함수를 간단하게 표현할 수 있는 방법. 주로 익명 내부 클래스를 대체하기 위해 사용. 

``` java 
List<String> names = Arrays.asList("a", "b", "c");
names.forEach(name -> System.out.println(name)); // 람다 표현식 사용
```

- 스트림 API ( Stream API ) 
: 데이터 처리를 함수형 스타일로 처리할 수 있음. 컬렉션 데이터를 필터링, 매핑, 정렬 등 작업을 수행할 때 유용, 병렬 처리 기능도 제공
``` java 
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream()
       .filter(n -> n % 2 == 0)
       .forEach(System.out::println); // 짝수만 출력
```

- 인터페이스 디폴트 메서드
: 인터페이스에 디폴트 메서드 정의 가능.

- 메서드 참조 
: 기존 메서드를 람다 표현식처럼 사용할 수 있도록 지원. 간결하고 가독성 높은 코드 작성 가능
``` java 
List<String> names = Arrays.asList("a", "b", "c");
names.forEach(System.out::println); // 메서드 참조 사용
```

- Optional class 
: 값이 있을 수도 있고, 없을 수도 있는 상황을 처리하는데 유용. NPE 방지 가능

``` java 
Optional<String> optionalName = Optional.ofNullable(null);
System.out.println(optionalName.isPresent()); // false 출력
optionalName.ifPresent(System.out::println); // 값이 없으면 아무것도 출력되지 않음
```

- 날짜와 시간 API ( java.time 패키지 ) 
: 기존의 java.util.Date와 Calendar의 단점을 보완한 새로운 API 도입 . 불변 객체를 기반으로 하며 직관적인 날짜와 시간 처리 가능
- 기존 API : 불변성이 없으며, 스레드 안전하지 않음. 월이 0부터 시작, 시간대와의 통합 불편
- 변경된 API : 불변 객체, 스레드 안전. 월이 1부터 시작, 시간대 관련(ZoneDateTime) 제공
``` java 
LocalDate today = LocalDate.now();
System.out.println(today);
``` 

> 스트림 API의 장점은 무엇이며, 실무에서 어떻게 활용해봤나요? 
- 스트림 API는 데이터 처리 로직을 간결하게 구현할 수 있고, 실무에서 스트림 API를 활용하여 컬렉션 데이터를 효율적으로 처리한 경험이 있습니다. 
예를 들어, SubscriptionList라는 리스트안에 각 리스트의 요소는 Subscription 객체였고, 각 Subscription 객체는 Subscriptiontool 객체를 포함한 또 다른 리스트를 가지고 있었습니다. 
즉, 리스트 안에 데이터가 리스트로 들어가 있는 중첩된 형태였습니다. 기존에는 중첩 반복문과 조건문을 사용해 데이터를 처리했지만, 스트림API의 flatMap() 를 활용해 리스트의 리스트를 평탄화하여( 하나의 리스트 형태로 ) 효율적으로 데이터를 처리할 수 있었습니다. 

> flatMap()의 동작원리 설명해주세요 
- 스트림의 각 요소를 함수로 매핑한 후, 반환된 여러 하위 스트림을 하나의 스트림으로 평탄화하여 단일 스트림을 생성하는 메서드. 주로 리스트 안의 리스트와 같은 중첩된 데이터를 처리할 때 사용

## try-with-resource에 대해서 설명해주세요.
- Java 7에서 도입된 기능으로 자동으로 자원을 해제(Close)해주는 구문
- 파일, DB 연결, 네트워크 소켓 등과 같이 자원을 명시적으로 해제해줘야 하는 경우 사용 
- try-catch-finally 구조에서 자원을 수동으로 해제해야 하는 번거로움과 자원 해제 누락으로 인한 문제를 해결하기 위해 도입
- 자원 해제를 자동으로 처리해 코드가 간결해지며, 예외가 발생해도 자원이 안젼하게 해제. 자원 누수 문제 방지
- try 블록에서 사용하는 자원이 AutoCloseable 인터페이스를 구현하고 있어야함 
- java의 자원 클래스들은 대부분 AutoCloseable을 이미 구현함 <br>
ex) InputStream, OutputStream, Reader, Writer, Connection, BufferReader, FileReader.. 
- AutoCloseable을 구현하면 try 블록이 끝날 때, 자원이 자동으로 해제되도록 close()메서드 호출

> try-with-resource에서 여러 자원을 다룰 때 자원 해제 순서는 어떻게 되나요? 
- 여러 자원을 선언하면, 선언된 순서의 역순으로 자원이 해제되며, 이는 자원들 간의 의존성 문제를 안전하게 처리하기 위함

## 강한 결합과 느슨한 결합이 무엇인지 설명해주세요.
> 강한 결합 ( Tight Coupling )
- 클래스가 서로의 구현에 의존하며, 하나의 클래스가 변경되면 그 클래스를 의존하는 다른 클래스들도 변경 해야함. 시스템 확장이나 유지보수가 어려워짐

> 느슨한 결합 (Loose Coupling ) 
- 클래스나 모듈간의 의존성을 최소화하며 (인터페이스나 추상화를 통해 의존성을 줄임), 변경에 유연하고 확장성이 뛰어남

> 결합도와 응집도는 어떤 관계가 있나요? 
- 결합도는 클래스나 모듈간의 의존성을 의미하고, 응집도는 클래스나 모듈 내부의 요소들이 얼마나 밀접하게 관련되어 있는지를 나타내는데, 좋은 소프트웨어 설계는 낮은 결합도와 높은 응집도를 목표로 함 
- ex) 하나의 클래스가 단일 책임 원칙 ( SRP )을 따르면서 다른 클래스와의 의존성을 최소화한다면, 이 클래스는 높은 응집도와 낮은 결합도를 가지고 있다고 볼수 있음


## 직렬화와 역직렬화에 대해서 설명해주세요.
> 직렬화(Serialization)
- 객체를 바이트 스트림으로 변환하여, 파일, 데이터베이스, 네트워크를 통해 저장하거나 전송할 수 있도록 하는 과정
- 직렬화된 객체는 프로그램이 종료되더라도 데이터 유지 가능
- java : Serializable 인터페이스를 구현함으로써 객체 직렬화 가능
- 직렬화된 객체는 클래스 버전이 변경되면 역직렬화가 실패할 수도 있으므로 serialVersionUID 정의하는것이 좋음

> 역직렬화 (Deserialization)
- 바이트 스트림으로 저장된 데이터를 다시 객체로 변환하는 과정. 직렬화 데이터를 읽어 원래의 객체 상태로 복원

> serialVersionUID의 역할은 무엇이며, 왜 명시적으로 정의하는 것이 중요한가요?
- serialVersionUID는 클래스의 버전 관리를 위한 고유 식별자. 역직렬화 과정에서 버전 불일치로 인한 오류 방지를 위해 정의하는것이 중요 

> Serializable 인터페이스를 구현하지 않은 객체를 직렬화하려고 할 때 어떤 문제가 발생하나요?
- Serializable 인터페이스를 구현하지 않은 객체는 직렬화할 수 없으며, 이를 직렬화하려고 시도하면 NotSerializableException이 발생

> java에서 직렬화가 필요한 이유는? 
- 직렬화는 객체의 상태를 저장하거나, 네트워크를 통해 객체를 전송하기 위해 필요. 이를 통해 프로그램이 종료되거나 다른 시스템 간의 객체를 주고받을 때도 객체의 상태 유지할수 있음

> 직렬화 시 객체가 참조하는 다른 객체는 어떻게 되는지? 
- 직렬화 과정에서 객체가 참조하는 다른 객체도 함께 직렬화됨. 이때 해당 객체들도 Serializable 인터페이스를 구현해야하며, 그렇지 않으면 NotSerializableException이 발생 

## 자바의 동시성 이슈(공유자원 접근)에 대해 설명해주세요.
- 동시성 이슈는 멀티 스레드 환경에서 여러 스레드가 공유 자원에 동시에 접근할 때 발생하는 문제

> 동시성 이슈 주요 원인 / 해결 방법
- 공유 자원 ( Shared Resource ) 이란? <br> 
 : 여러 스레드가 동시에 접근하는 자원. 공유 자원은 변수, 객체, 파일, 데이터베이스 등이 될수있음 <br>

- 경쟁 조건 ( Race Condition ) <br>
 : 여러 스레드가 동일한 자원에 접근하여 값을 변경할 때, 결과가 스레드의 실행 순서에 따라 달라지는 문제 <br>

- 경쟁 조건 해결 방법 <br> 
  : synchronized 키워드를 사용함으로써 한번에 하나의 스레드만 특정 코드 블록이나 메서드에 접근할 수 있도록 보장 <br>
  : java.util.concurrent.locks.Lock 인터페이스를 구현한 ReentrantLock 사용 <br>
  : AtomicInteger, AtomicBoolean 등 원자성을 보장하는 클래스 사용하면 내부적으로 CAS(Compare and swap) 알고리즘을 사용해 경쟁 조건 방지 <br>
  
- 원자성 문제 ( Atomicity Issue ) <br>
 : 원자성은 작업이 "분할 불가능"한 단위로 실행되어야 함. 하지만 원자성이 보장되지 않으면, 여러 단계의 작업이 수행되는 도중 다른 스레드가 개입하여 데이터의 일관성 깨질 수 있음 <br>

- 원자성 문제 해결 방법 <br>
 : synchronized 키워드를 사용함으로써 한번에 하나의 스레드만 특정 코드 블록이나 메서드에 접근할 수 있도록 보장 <br>
 : java.util.concurrent.locks.Lock 인터페이스를 구현한 ReentrantLock 사용 <br>
 : AtomicInteger, AtomicLong, AtomicReference 등 자바의 Atomic 클래스를 사용하면 원자성을 보장하는 연산을 수행할 수 있습니다. 이 클래스들은 내부적으로 원자성을 보장하여 데이터의 일관성을 유지 <br>

- 가시성 문제 ( Visibility ) <br>
 : 한 스레드에서 변경된 값이 다른 스레드에서 즉시 보이지 않는 경우 발생. CPU캐시나 메모리 구조로 인해 발생하는 문제. <br>
- 가시성 문제 해결 방법 <br>
 : volatile 키워드를 사용하면 변수의 가시성을 보장. volatile로 선언된 변수는 모든 스레드가 항상 최신 값을 읽게 해줌 <br>
 : 다만 volatile 키워드는 가시성 문제는 해결하지만, 원자성은 보장하지않으므로 복잡한 연산에는 적합하지 않음 <br>
 : synchronized는 연산의 원자성을 보장하면서도 메모리의 가시성을 확보. 즉, synchronized 블록 안에서 변경된 값은 다른 스레드에서도 즉시 반영 <br>
 : 객체의 불변성을 유지하기 위해 final 키워드를 사용, 객체 생성 후 값이 변경되지 않음을 보장할 수 있어 가시성 문제를 방지 <br>
 
- 교착 상태 ( Deadlock )
 : 두 개 이상의 스레드가 서로 상대방이 점유한 자원을 기다리면서 무한히 대기 상태에 빠지는 문제  <br>
- 교착 상태 문제 해결 방법 <br>
 : 자원 획득 순서를 고정 <br> 
 : ReentrantLock의 tryLock() 메서드를 사용해, 특정 시간 동안만 Lock을 시도하고, 실패하면 다른 작업을 수행하도록 설계 <br> 
 : 타임아웃 설정 <br>

## Mutable 객체와 Immutable 객체의 차이점에 대해 설명해주세요.
> Mutable
- 객체의 상태를 변경할 수 있는 개체
- 멀티 스레드 환경에서 상태가 변경될 수 있어 동기화 필요
- ArrayList, Hashmap, 사용자 정의 클래스

> Immutable
- 객체 생성 후 상태를 변경할 수 없으며, 모든 필드는 초기화 후 불변
- 멀티 스레드 환경에서 안전 
- String, Integer, 사용자 정의 불변 클래스
- 개체 생성 비용 증가 , 메모리 사용량 증가

> 차이점
- Mutable 객체는 상태를 변경할 수 있지만, Immutable 객체는 한번 설정된 상태를 변경할 수 없다. 또한 Immutable 객체는 동시성 안전성을 제공하지만, 빈번한 변경 작업이 있을 경우 성능이 저하될 수 있음

> Immutable 객체의 상태를 변경하고 싶은 때는 어떻게 해야하나요?
- Immutable 객체의 상태를 변경할 때는 기존객체를 수정하지 않고, 변경된 값을 반영한 새로운 객체를 생성
  
> Immutable 객체를 설계할 때 주의해야 할 점은 무엇인가요?
- Immutable 객체를 설계할 때 모든 필드는 final이어야 하고, 클래스 자체도 final로 선언하여 상속을 방지해야함. 컬렉션필드가 있을 경우 방어적 복사를 통해 외부에서 수정되지 않도록 해야함.
- 방어적 복사 : 객체의 내부 상태를 보호하기 위해 원본 객체의 복사본을 만들어 반환하거나 저장하는 기법

## 자바에서 null을 안전하게 다루는 방법에 대해 설명해주세요.
- null 체크를 통한 방어적 코드 작성, Optional 사용, Objects.requireNonNull()을 통한 파라미터 검증, 기본값 설정, Null Object 패턴 등을 사용할 수 있음

> Objects.requireNonNull 과 Optional의 차이점은?
- Objects.requireNonNull은 입력값이 null일 때 예외를 발생시켜 문제를 즉시 감지. Optional은 반환값이 null일 수 있는 경우 안전하게 처리하기 위해 다양한 API 제공

## JDK와 JRE의 차이점을 설명하세요.
> JDK ( Java Development Kit )
- 자바 애플리케이션을 개발하기 위한 도구 및 환경 제공
- JRE, javac, 디버거, 인터프리터 등 개발 도구

> JRE ( Java Runtime Environment )  
- 자바 애플리케이션을 실행하기 위한 런타임 환경
- jvm, 클래스 라이브러리 등 프로그램 실행에 필요한 요소 제공

> 차이점
- JDK는 자바 애플리케이션을 개발하기 위한 도구이며, JRE는 자바 애플리케이션을 실행하기 위한 런타임 환경. JDK는 JRE를 포함하고 있으며, 추가적으로 컴파일러, 디버거 등 개발 도구들이 포함
  
> JVM, JRE, JDK의 관계를 설명해보세요
- JVM은 자바 바이트 코드를 실행하는 가상 머신
- JRE는 JVM과 자바 애플리케이션을 실행하기 위한 라이브러리를 포함한 환경
- JDK는 JRE에 추가적으로 컴파일러와 개발 도구들을 포함한 개발 키트
  
> JDK와 JRE의 사용 시점을 구분해주세요
- 자바 애플리케이션을 개발할 때는 JDK가 필요, 단순히 자바 애플리케이션을 실행만 하고자 할때는 JRE만 설치

# Spring

## Spring DI/IoC는 어떻게 동작하나요?
>  DI ( Dependency Injection ) 
1. 객체 간의 결합도를 낮추기 위해 의존성을 외부에서 주입하는 방식으로 IoC의 구현 방식 중 하나입니다. 
2. 동작 원리 
- 객체 생성 및 의존성 관리 : Spring 컨테이너가 애플리케이션 실행 시 객체(Bean)을 생성하고 관리합니다
- 의존성 주입 : Spring 컨테이너는 생성된 객체들 간의 의존성을 설정 파일, 어노테이션, java config를 기반으로 자동으로 주입합니다
- 주입 방식 : DI는 생성자 주입, 필드 주입, 세터 주입 3가지 방식 <br>
-> 생성자 주입 : 객체 생성 시 필요한 의존성을 생성자를 통해 전달. 장점은 불변 객체를 만들수 있고, 테스트에서 Mock 주입이 용이하지만, 단점은 의존성이 많을 경우 생성자가 복잡해질수 있습니다.  <br>
-> 세터 주입 : 세터 메서드를 통해 의존성을 주입.  <br>
-> 필드 주입 : 어노테이션을 사용해 필드에 직접 의존성을 주입. 과거에 많이 사용한 방법 <br>


> IoC ( Inversion of Control )
1. 제어의 역전 개념으로 객체의 생성과 의존성 관리를 개발자가 아닌 프레임워크가 담당하는 구조로, 객체지향 설계의 핵심 원칙 중 하나로 객체간 결합도를 줄여 유지보수성을 높입니다.
2. 동작 원리 
- Bean 정의 및 등록 : 설정파일 (xml, config) 또는 어노테이션 ( @Component, @Service, @Repository, @Bean ) 을 통해 Bean을 정의 
- 컨테이너 초기화 : Spring 애플리케이션이 실행되면 IoC 컨테이너가 초기화되며, 필요한 Bean을 생성
- 의존성 주입 : IoC 컨테이너는 각 Bean 간의 의존성을 분석하고, 주입이 필요할 때 자동으로 의존성 주입 
- Bean 라이프사이클 관리 : IoC 컨테이너는 Bean의 생명주기를 관리

> IoC와 DI의 차이점은? 
- IoC는 큰 개념으로, 객체 생성과 의존성 주입의 제어권을 Spring으로 넘기는것을 의미하며, DI는 이러한 IoC를 실현하는 구체적인 방법으로, 외부에서 객체의 의존성을 주입하는 방식을 말합니다. 즉, DI는 IoC의 구현 방식 중 하나입니다. 

> Sping의 IoC 컨테이너는 Bean을 어떻게 관리하나요? 
- 설정파일, 어노테이션, Java config를 통해 Bean을 등록하고, 생성 시 의존성을 주입. 컨테이너는 이 Bean들을 싱글톤, 프로토타입 등의 다양한 스코프로 관리하며 , 애플리케이션 구동 시점에 필요한 Bean을 미리 준비


## DI 종류는 어떤것이 있고, 이들의 차이는 무엇인가요?
> 생성자 주입 (Constructor Injection) 
- 의존성을 생성자를 통해 주입하는 방식. 가장 권장되는 방법.
- 생성자에 @Autowired 어노테이션 추가 
- 필수적인 의존성을 명시적으로 제공하며, 불변성 보장
  
> 세터 주입 (Setter Injection)
- 클래스의 세터 메서드를 통해 의존성을 주입하는 방식.
- setter Property에 @Autowired 어노테이션 추가
- 선택적인 의존성에 대해 유연함을 제공하나, 객체가 완전히 초기화되기 전에 사용될 위험이 존재
  
> 필드 주입 (Field Injection)
- 클래스의 필드에 직접 의존성을 주입하는 방식.
- 필드에 대해서 @Autowired 어노테이션 추가
- 코드량이 적고 간결하지만, 테스트와 재사용성의 측면에서 단점이 존재 
- 현재는 좋은 방식이 아니라는 의견이 있어서 테스트 코드 이외에는 잘 사용하지 않고, 인텔리제이에서도 not recommend라고 뜸

> 왜 생성자 주입을 권장하나요?
- 객체를 생성할 때, 생성자에서 의존성이 필요한 파라미터가 주어진다면, 의존성이 주입되지 않는 객체를 생성할 수 없다는 것을 확신할 수 있습니다.
또한 스프링 컨테이너(IoC컨테이너)에서도 의존성을 주입할 Bean을 체크할 다른 로직이 필요 없어지므로 NPE를 방지할 수 있습니다.
- 의존성 주입이 필요한 객체를 final로 할 수 있어서 불변성을 가질수 있게 됩니다.  

출처 <br> 
https://github.com/Next-Squad/Interview-Question/issues/19

## Spring Bean이란 무엇인가요?
- Sping IoC 컨테이너에 의해 관리되는 객체를 말합니다. Spring 애플리케이션에서 생성되고 관리되는 모든 객체는 Spring Bean입니다. 
 Bean들은 Spring 컨테이너에 의해 생성, 주입, 관리, 소멸되며, 필요한 의존성을 자동으로 주입받아 사용됩니다. Spring 에서 모든 중요한 비즈니스 로직 객체들은 Bean으로 등록되어 IoC 컨테이너에서 관리됩니다. 

## 스프링 Bean의 생성 과정을 설명해주세요.
- Bean 등록 : 개발자가 XML 설정 파일, Java설정, 어노테이션(@Controller, @Service, @repository, @Component)을 통해 Bean을 정의하고 등록 
- Bean 인스턴스화 : IoC가 컨테이너가 애플리케이션 시작 시점에 등록된 Bean을 인스턴스화 합니다. 
- 의존성 주입 : 인스턴스화된 Bean에 필요한 의존성을 컨테이너가 주입합니다.(DI) 이 과정은 생성자 주입, 세터 주입, 필드 주입으로 이루어집니다. 
- 초기화 메서드 호출 : Bean이 초기화되며, 만약 설정된 초기화 메서드가 있다면 해당 메서드가 호출됩니다. 
- Bean 사용 : Bean은 애플리케이션 내에서 사용됩니다. 컨테이너는 애플리케이션 실행 동안 Bean을 관리합니다. 
- 소멸 메서드 호출 : 애플리케이션 종료 시점에 Bean이 소멸되며, 설정된 소멸 메서드가 호출됩니다. 

> 생성 주기 
- 객체 생성 -> 의존 설정 -> 초기화 -> 사용 -> 소멸
- 스프링 컨테이너가 초기화 될때 먼저 빈 객체를 설정 정보에 맞추어 생성하고, 의존관계를 설정한 뒤에 해당 프로세스가 완료되면 빈 객체가 지정한 메서드를 호출해서 초기화한다. 객체를 사용한 뒤 컨테이너가 종료될때 빈이 지정한 메서드를 호출해 소멸 과정을 진행한다

## 스프링 Bean의 Scope에 대해서 설명해주세요.
출처 <br> 
https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html
https://code-lab1.tistory.com/186

> 정의
- Bean Scope는 Spring IoC컨테이너에서 Bean이 생성되고 관리되는 범위

> 종류 
1. Singleton (싱글톤)
   - 기본 스코프이며, Spring IoC 컨테이너 당 하나의 인스턴스만 생성. 애플리케이션 전체에서 동일한 객체를 공유
2. Prototype (프로토타입)
  - 요청 시마다 새로운 Bean 인스턴스를 생성. 상태가 있는 객체나 매 요청마다 새 객체가 필요한 경우에 유용
3. Request (요청 스코프)
  -  웹 애플리케이션에서 HTTP 요청 당 하나의 Bean 인스턴스를 생성하며, 요청이 끝나면 소멸
4. Session (세션 스코프)
  - HTTP 세션 당 하나의 Bean 인스턴스를 생성하고, 세션이 종료되면 소멸. 사용자의 로근 세션 동안 상태를 유지하는데 사용 
5. Application (애플리케이션 스코프)
  - 서블릿 컨텍스트의 생명주기와 동일한 범위를 가짐. 애플리케이션 전역에서 공유되는 객체를 관리할 때 사용 
6. WebSocket
  - WebSocket 세션당 하나의 Bean 인스턴스를 생성. 실시간 통신을 처리할 때 사용

> 웹 애플리케이션에서 Request 스코프와 Session 스코프의 차이점은 무엇인가요?
- Request 스코프는 HTTP 요청 당 하나의 Bean을 생성하고, Session 스코프는 HTTP 세션당 하나의 Bean을 생성합니다.

## IoC 컨테이너의 역할은 무엇이 있을까요?
> 정의
- Spring의 핵심 요소로, 객체의 생성 및 관리, 의존성 주입, 생명주기 제어 등을 담당. IoC 컨테이너는 개발자가 객체의 생성과 관리를 직접 하지 않도록 해주며 객체간의 결합도를 낮추어 애플리케이션의 유연성과 테스트 용이성을 높이는 역할 

> 역할
1. 객체의 생성 및 관리
   - IoC 컨테이너는 애플리케이션에 필요한 객체(Bean)을 생성하고, 관리. 개발자가 객체를 직접 생성하는 대신 Spring 컨테이너가 대신 처리
2. 의존성 주입 (DI)
   -  IoC 컨테이너는 객체 간의 의존성을 설정 파일이나 어노테이션 기반으로 주입. 이를 통해 객체 간의 결합도를 낮추고, 유연한 설계 가능
3. Bean 등록 및 검색
   - 설정된 Bean들을 관리하며, 필요할 때 Bean을 검색하고 제공.
4. Bean의 생명주기 관리
   - Bean의 생성, 초기화, 소멸까지의 전 과정을 관리. 초기화 메서드(@PostConstruct)와 소멸 메서드(@PreDestroy)를 통해 Bean의 생명주기 중 특정 작업을 수행
5. Bean 스코프 관리
   - 각 Bean의 스코프를 관리
6. AOP(Aspect-Oriented Programming) 지원
   - AOP를 지원하며, 로깅, 트랜잭션 관리 등 횡단 관심사를 별도의 코드로 분리하여 관리

> IoC 컨테이너가 Bean을 어떻게 관리하나요?
- IoC 컨테이너는 설정 파일, 어노테이션 또는 Java Config를 기반으로 Bean을 생성하고, 의존성을 주입한 후 생명주기를 관리

 > Spring IoC 컨테이너의 두 가지 주요 구현체는 무엇인가요?
- 주요 구현체로는 BeanFactory와 ApplicationContext가 있습니다. ApplicationContext는 더 많은 기능을 제공하며, 대부분의 Spring 애플리케이션에서 사용

> BeanFactory와 ApplicationContext의 차이점은 무엇인가요?
-  BeanFactory는 기본적인 DI 기능만 제공하는 반면, ApplicationContext는 추가적으로 AOP, 이벤트 리스닝, 메시지 리소스 처리 등의 기능을 제공

> Spring에서 Bean의 생명주기를 관리하기 위한 어노테이션은 무엇인가요?
- @PostConstruct와 @PreDestroy 어노테이션을 사용하여 Bean의 초기화 및 소멸 시점을 제어

> IoC 컨테이너에서 Bean의 스코프를 설정하는 방법은 무엇인가요?
- @Scope 어노테이션을 사용하여 Bean의 스코프를 설정할 수 있습니다. 기본 스코프는 싱글톤(Singleton)

> Spring IoC 컨테이너에서 AOP를 어떻게 지원하나요?
- IoC 컨테이너는 AspectJ와 같은 AOP 프레임워크와 통합되어 횡단 관심사를 처리합니다. 이를 통해 트랜잭션, 로깅 등 공통 기능을 모듈화


## Autowiring 과정에 대해서 설명해주세요.
> 정의
- Spring에서 의존성 주입(DI)를 자동으로 처리하는 방법
- Spring 컨테이너가 @Autowired, @Inject, @Resource 등의 어노테이션을 사용해 필요한 의존성을 자동으로 주입

> 주입 방식 
- 타입(Type) 기준 주입: @Autowired를 통해 Bean을 타입 기준으로 주입. 동일한 타입의 Bean이 여러 개 있을 경우, @Qualifier를 사용해 특정 Bean을 지정할 수 있음
- 생성자 주입: 생성자에 @Autowired를 사용해 의존성을 주입. 최근에는 생성자 주입이 권장.
- 필드 주입: 필드에 직접 @Autowired를 사용해 주입
- 세터 주입: 세터 메서드에 @Autowired를 사용해 주입
  
> 과정
- Spring 컨테이너는 애플리케이션 구동 시, @Autowired가 지정된 필드, 생성자, 세터 메서드를 스캔
- 해당 필드나 메서드의 타입에 맞는 Bean을 검색하여 주입
- 만약 주입할 수 있는 Bean이 없다면 예외를 발생시키거나, required=false 설정으로 예외를 무시

> @Autowired를 사용할 때 타입 충돌이 발생하면 어떻게 해결하나요?
- 타입 충돌이 발생할 때는 @Qualifier 어노테이션을 사용해 특정 Bean을 명시적으로 지정해 주입할 수 있습니다. 예를 들어, 동일한 타입의 Bean이 여러 개 있을 경우, @Qualifier("beanName")을 사용하여 원하는 Bean을 선택합니다.

> 필드 주입과 생성자 주입의 장단점을 설명해 주세요.
- 생성자 주입은 불변성과 테스트의 용이성을 보장하며, 필수 의존성을 강제할 수 있습니다. 반면 필드 주입은 코드가 간결하지만, 테스트에서 Mock 주입이 어려워 유지보수가 어렵습니다. 일반적으로 생성자 주입이 권장됩니다.

> @Autowired와 @Inject의 차이점은 무엇인가요?
- @Autowired는 Spring의 고유 어노테이션이며, @Inject는 Java 표준 JSR-330 어노테이션입니다. 둘 다 유사한 기능을 하지만, @Autowired는 required=false 속성을 통해 주입이 선택적일 수 있습니다.



## Spring Web MVC의 Dispatcher Servlet의 동작 원리에 대해서 간단히 설명해주세요.
출처 <br> 
https://github.com/Next-Squad/Interview-Question/issues/48

> 정의
- Spring Web MVC에서 요청을 처리하는 핵심 구성 요소
- 프론트 컨트롤러 패턴을 따르며, 클라이언트로부터의 모든 요청을 받아 적절한 컨트롤러로 전달하고, 응답을 반환
- 
> 동작 과정
- 클라이언트 요청: 클라이언트가 웹 요청을 보냅니다.
- 요청 처리: DispatcherServlet이 요청을 받고, 이를 처리하기 위한 컨트롤러를 찾습니다.
- 핸들러 매핑: HandlerMapping을 통해 해당 요청에 매핑된 컨트롤러를 검색합니다.
- 핸들러 어댑터: 컨트롤러에 요청을 전달해 결과를 반환받습니다.
- 뷰 리졸버: 반환된 데이터를 바탕으로 어떤 뷰를 사용할지 결정합니다.
- 뷰 렌더링: 최종적으로 뷰를 렌더링하고 클라이언트에게 응답을 보냅니다.

> DispatcherServlet의 역할은 무엇인가요?
- DispatcherServlet은 Spring MVC에서 모든 HTTP 요청을 받아들이고, 이를 적절한 컨트롤러에 전달해 처리한 뒤 결과를 클라이언트에게 반환하는 프론트 컨트롤러입니다.

> HandlerMapping과 HandlerAdapter의 역할을 설명해 주세요.
- HandlerMapping은 요청 URI에 따라 적절한 컨트롤러를 찾는 역할을 하고, HandlerAdapter는 해당 컨트롤러를 호출해 요청을 처리하는 어댑터 역할을 합니다.

> DispatcherServlet이 없는 Spring 애플리케이션이 가능한가요?
- 네. Spring Web MVC가 아닌 순수한 Spring 애플리케이션에서는 DispatcherServlet이 필요하지 않으며, 대신 다른 방식으로 요청을 처리할 수 있습니다.


## 프론트 컨트롤러 패턴이란 무엇인가요?
> 정의
- 웹 애플리케이션의 진입 지점을 하나로 통합하는 디자인 패턴입니다. 모든 요청이 하나의 중앙 컨트롤러(프론트 컨트롤러)를 통해 처리되고, 이후 필요한 컨트롤러나 뷰로 요청이 전달됩니다. Spring의 DispatcherServlet이 이 패턴임

> 장점 
- 중앙 집중화된 요청 처리
- 공통 작업(인증, 로깅, 예외 처리 등)을 한 곳에서 처리 가능
- 애플리케이션 구조를 단순화

> 프론트 컨트롤러 패턴을 사용하는 이유는 무엇인가요?
- 프론트 컨트롤러 패턴을 사용하면 모든 요청을 하나의 중앙 컨트롤러에서 처리하므로, 공통 기능(예: 인증, 로깅)을 일관성 있게 관리할 수 있습니다.

> 프론트 컨트롤러 패턴과 관련된 Spring 구성 요소는 무엇인가요?
- Spring에서 프론트 컨트롤러 패턴을 구현한 대표적인 구성 요소는 DispatcherServlet입니다. 이 서블릿이 모든 HTTP 요청을 받아 컨트롤러에 전달합니다.

> 프론트 컨트롤러 패턴을 구현하지 않은 경우 발생할 수 있는 문제는 무엇인가요?
- 요청을 개별 컨트롤러에서 직접 처리하면 코드 중복이 발생하고, 공통 기능을 관리하기 어려워집니다. 또한 유지보수성이 떨어지며 애플리케이션의 복잡도가 증가할 수 있습니다.

## Servlet Filter와 Spring Interceptor의 차이는 무엇인가요?
> 차이점
- Servlet Filter와 Spring Interceptor는 요청과 응답을 가로채는 데 사용되지만, 서로 다른 레벨에서 동작
  
> Servlet Filter
- 동작 위치: 서블릿 컨테이너 레벨에서 동작하며, 서블릿 요청 이전과 이후에 실행됩니다.
- 기능: 요청과 응답의 전처리/후처리, 인증 및 인가, 로깅, 데이터 압축 등.
- 적용 범위: 모든 서블릿과 리소스에 적용될 수 있습니다.

> Spring Interceptor
- 동작 위치: Spring MVC 레벨에서 동작하며, 컨트롤러에 도달하기 전후에 실행됩니다.
- 기능: 특정 요청의 전처리/후처리, 인증, 데이터 검증 등.
- 적용 범위: Spring MVC의 핸들러에만 적용됩니다.

> Servlet Filter와 Spring Interceptor 중 어느 것을 사용해야 할지 결정하는 기준은 무엇인가요?
- 전역적인 요청 처리나 리소스 관리가 필요하다면 Servlet Filter를 사용하고, Spring MVC의 컨트롤러 요청 전후 처리라면 Spring Interceptor를 사용합니다.
> Spring에서 Filter와 Interceptor를 함께 사용할 수 있나요?
- 네, 가능합니다. Filter는 서블릿 레벨에서, Interceptor는 Spring MVC 레벨에서 동작하므로, 둘을 함께 사용하여 요청을 여러 단계에서 처리할 수 있습니다.
> Spring Interceptor에서 preHandle, postHandle, afterCompletion의 차이점은 무엇인가요?
- preHandle은 컨트롤러 실행 전, postHandle은 컨트롤러 실행 후, afterCompletion은 View 렌더링 후에 호출됩니다.

## Spring에서 CORS 에러를 해결하기 위한 방법을 설명해주세요.
- CORS(Cross-Origin Resource Sharing) 에러는 클라이언트가 다른 도메인에서 리소스를 요청할 때 발생
  > 해결 방법
  1. @CrossOrigin 어노테이션을 사용하여 특정 컨트롤러나 메서드에서 CORS 정책을 설정
  ``` java
  @CrossOrigin(origins = "http://example.com", allowedHeaders = "*", allowCredentials = "true")
  @GetMapping("/api/data")
  public ResponseEntity<String> getData() {
      return ResponseEntity.ok("data");
  }
  ```
  2. WebMvcConfigurer를 구현하여 전역적으로 CORS 설정을 관리
  ``` java
  @Configuration
  public class WebConfig implements WebMvcConfigurer {
      @Override
      public void addCorsMappings(CorsRegistry registry) {
          registry.addMapping("/**")
                  .allowedOrigins("http://example.com")
                  .allowedMethods("GET", "POST");
      }
  }
  ```

  3. Spring Security 설정에 CORS를 추가하여 보안 설정과 함께 적용
  ``` java
  @Configuration
  public class SecurityConfig extends WebSecurityConfigurerAdapter {
      @Override
      protected void configure(HttpSecurity http) throws Exception {
          http.cors()
         .and()
         .csrf().disable() // 필요에 따라 CSRF 비활성화
         .authorizeRequests()
         .anyRequest().authenticated();
      }
  }

  ```

> CORS 에러가 발생하는 원인은 무엇인가요?
- CORS 에러는 클라이언트가 다른 도메인에서 서버 자원을 요청할 때, 서버가 그 도메인을 허용하지 않을 경우 발생합니다. 이는 보안 상의 이유로 브라우저가 차단하기 때문입니다.
> Spring Security 설정에서 CORS를 처리하는 방법은 무엇인가요?
- Spring Security에서는 HttpSecurity.cors()를 사용해 전역적인 CORS 설정을 할 수 있습니다. 추가적으로 WebMvcConfigurer를 통해 세부 설정을 제어할 수 있습니다.
> @CrossOrigin 어노테이션을 사용할 때 주의할 점은 무엇인가요?
- @CrossOrigin 어노테이션은 특정 컨트롤러나 메서드에만 적용되므로, 전체 애플리케이션에 적용할 때는 WebMvcConfigurer를 사용하는 것이 좋습니다.


## Bean/Component 어노테이션에 대해서 설명해주시고, 둘의 차이점에 대해 설명해주세요.
- @Bean과 @Component는 모두 Spring에서 Bean을 등록하기 위한 어노테이션이지만, 사용하는 방식과 목적이 다름.

> @Bean
- 외부 라이브러리들을 Bean으로 등록하고 싶은 경우 사용
- 개발자가 생성한 인스턴스를 spring에게 Bean으로 관리해 달라고 요청하는 경우
- 1개 이상의 @Bean을 제공하는 클래스의 경우 반드시 @Configuration을 명시해 주어야 싱글톤이 보장
- 매소드 레벨에서 선언

> @Component
- 개발자가 직접 컨트롤이 가능한 class 경우 사용
- spring이 직접 인스턴스를 생성하여 Bean으로 등록하도록 하는 경우
- @Component는 @Service, @Repository, @Controller 등으로 확장
- 클래스 레벨에서 선언

> 차이점
- @Bean은 수동으로 Bean을 등록할 때 사용되며, 개발자가 Bean의 생성을 완전히 제어
- @Component는 자동 스캔을 통해 Bean을 등록하며, 개발자는 클래스에 어노테이션만 추가
  
> @Component와 @Bean의 사용 시점은 언제인가요?
- @Component는 클래스 수준에서 객체를 Bean으로 등록할 때 사용하고, @Bean은 개발자가 특정 메서드를 통해 직접 Bean을 생성하여 등록할 때 사용합니다.

> @Bean을 사용하는 이유는 무엇인가요?
- @Bean은 복잡한 객체 생성이나 외부 라이브러리 객체를 Spring 컨테이너에 등록해야 할 때 유용합니다. 이를 통해 수동으로 Bean을 설정하고 관리할 수 있습니다.

> @Component, @Bean 스이 이루어지지 않을 때, 이를 해결하는 방법은 무엇인가요?
1. @Component 스캔이 되지 않을 때
- 원인 : 주로 스캔 대상 패키지가 @ComponentScan에 포함되지 않았을 경우 
- 해결 방안 : @ComponentScan을 사용해 대상 패키지를 명시적으로 설정
<br> 
2. @Bean 스캔이 되지 않을 때
- 원인 : @Configuration 클래스가 Spring 컨텍스트에서 인식되지 않거나, 특정 프로파일이 활성화되지 않았기 때문
- 해결 방안 : @Configuration 클래스를 확인하거나, 프로파일 설정(application.yml, application.properties)을 확인

## POJO란 무엇인가요? Spring Framework에서 POJO는 무엇이 될 수 있을까요?
> 정의
- Plain old java object
- 특정 프레임워크, 라이브러리, 규약 등에 종속되지 않는 순수한 자바 객체

> 특징
- 특정 라이브러리나 프레임워크에 종속되지 않고, 비즈니스 로직을 구현할때 자유롭게 사용가능하며, 특정 API나 프레임워크에 대한 의존성이 없기 때문에 다른 환경에서도 쉽게 활용이 가능
  
> Spring Framework에서 POJO는 무엇이 될 수 있을까요?
- 도메인 객체 (Domain Objects) : 비즈니스 도메인의 개념을 표현하는 클래스들로, 엔티티, 값 객체 등이 해당. 비즈니스 로직과 데이터를 담고 있음
- DTO (Data Transfer Object) : 계층 간 데이터 전송을 위해 사용되는 객체로, 주로 요청 또는 응답 데이터를 담기 위해 사용됩니다. DTO는 데이터를 담고 전달하는 역할만 하며, 스프링과 같은 프레임워크에 종속되지 않음
- 비즈니스 로직을 가진 서비스 클래스 (어노테이션이 없는 경우) : 특정 어노테이션 없이 작성된 비즈니스 로직을 담당하는 서비스 클래스
- 유틸리티 클래스 (Utility Classes) : 문자열 처리, 날짜 계산 등을 수행하는 헬퍼 클래스
- 레포지토리 인터페이스 (Repository Interface) : 스프링 데이터 JPA나 다른 ORM 프레임워크의 레포지토리를 구현하는 인터페이스 자체

>  POJO와 Spring Bean의 차이점은 무엇인가요?
- POJO는 특정 프레임워크에 의존하지 않는 순수한 자바 객체. Spring Bean은 Spring 컨테이너에 의해 관리되는 객체로, POJO일 수도 있지만 Spring의 관리 하에 생명주기, 의존성 주입 등이 추가적으로 적용

> Spring Framework는 POJO 기반으로 설계되었다고 하는데, POJO가 특정 프레임워크에 의존하지 않는 이유는 무엇인가요?
- POJO는 특정 인터페이스나 상속을 강제하지 않으며, Spring은 POJO를 관리하기 위해 IoC 컨테이너를 사용. POJO는 프레임워크에 종속되지 않고 순수 자바 객체로 작성되어, 다양한 환경에서도 독립적으로 사용

> POJO와 spring 어노테이션의 관계
- Spring이 POJO 기반이라고 하는 이유는, 어노테이션을 통해 Spring이 관리하더라도, 비즈니스 로직은 특정 프레임워크에 종속되지 않고 자유롭게 구현할 수 있기 때문
- Spring 어노테이션을 사용하면 해당 클래스는 Spring에 의존하게 됨. 하지만, 이 의존성은 주로 Spring 컨테이너와 관련된 부분이며, 비즈니스 로직 자체는 여전히 순수 자바 객체로 작성

## Spring Web MVC에서 요청 마다 Thread가 생성되어 Controller를 통해 요청을 수행할텐데, 어떻게 1개의 Controller만 생성될 수 있을까요?
- Spring web MVC에서 컨트롤러는 기본적으로 싱글톤 스코프 (힙 메모리에 저장)이며, spring container가 해당 컨트롤러 빈을 한번만 생성합니다. 이후에 모든 요청에 대해서는 동일한 컨트롤러 인스턴스를 사용하여 처리되며, 상태 없는(stateless) 설계로 인해 여러 스레드가 동시에 접근해도 안전하게 동작합니다. 이는 인스턴스 변수를 사용하지 않고 로컬 변수를 사용해 데이터를 처리하기 때문입니다. 즉, 여러 요청이 동일한 컨트롤러 인스턴스를 공유하지만, 각 요청에 대해 별도의 스레드가 동작하기 때문에 1개의 컨트롤러로 처리가 가능합니다. 

> 컨트롤러가 상태를 가지지 않는(stateless) 방식으로 설계된다는 것은 무엇을 의미하나요?
- 모든 요청 데이터는 로컬 변수로 처리되며, 메서드 내에서만 존재하므로 각 요청이 독립적으로 처리될수있도록 설계된 방식입니다.

## Spring WEB MVC의 근간에는 Java Servlet 이 있는데요. Spring 은 Servlet을 어떻게 구성해서 이를 구현했을까요?
- Spring Web MVC는 Java servlet을 기반으로 동작하며, DispatcherServlet이 있습니다. DispatcherServlet은 Java Servlet의 HttpServlet을 상속받아 모든 요청을 중앙에서 처리하는 프론트 컨트롤러 역할을 수행합니다. 요청이 들어오면 DispatcherServlet은 HandlerMapping을 통해 적절한 컨트롤러를 찾아 호출하고, HandlerAdapter를 통해 컨트롤러 메서드를 실행합니다. 이후 반환된 결과를 ViewResolver를 통해 View로 변환하고 응답을 생성합니다. Spring은 이런 구조를 통해 Servlet Api를 확장해서 구현하였습니다. 

## Filter는 Servlet의 스펙이고, Interceptor는 Spring MVC의 스펙입니다. Spring Application에서 Filter와 Interceptor를 통해 예외를 처리할 경우 어떻게 해야 할까요?
> Filter
-  doFilter메서드에서 try-catch를 사용하여 예외 처리.
-  HttpServletResponse 상태코드를 설정하여 Client에 오류 메시지 전달

> Interceptor
- preHandle, postHandle 에서 발생한 예외는 @ControllerAdvice에서 처리
- afterCompletion에서는 뷰 렌더링(클라이언트로 전송된 이후)까지 완료된 후에 호출이므로, @ControllerAdvice로 처리되지않고 주로 로깅 용도로 활용. 실제 예외 발생시 로그만 남기고 추가적인 처리 없이 종료 <br>
  ex) db 커넥션, 파일 핸들러, 외부 api 호출 후 정리 작업 등 

> filter와 interceptor 중 예외 처리를 위해 어떤 것을 선택해야 하나요?
- 예외 처리가 spring mvc의 컨트롤러와 관련이 있거나 요청 흐름 중 발생할 가능성이 크다면 interceptor을 사용하는 것이 적합하고, 인증, 로깅, 필터링 등 전역적이고 독립적인 예외 처리가 필요하다면, filter가 적합합니다. 

## Spring Application을 구동할 때 메서드를 실행시키는 방법에 대해 설명해주세요.
> @PostConstruct
- Bean이 초기화된 후 호출, 애플리케이션 구동 시점에 해당 메서드를 자동으로 실행 (주로 초기화 작업 처리시 사용)
> CommandLineRunner 인터페이스
- 애플리케이션 구동 후 실행되는 코드를 정의 할수 있음
- run(String... args) 메서드를 구현하여 코드 작성
> ApplicationRunner 인터페이스
- CommandLineRunner와 유사하지만, 더 구조화된 ApplicationArguments 객체를 통해 인자를 전달받아 사용 가능
> @EventListener
- spring에서 제공하는 이벤트 시스템을 이용해 애플리케이션이 구동될때 실행할 코드 작성 가능

>실무에서 비동기 초기화 작업을 애플리케이션 구동 시 처리해야 했던 경험이 있나요? 그런 작업을 어떤 방식으로 처리했는지 설명해주세요.

## 의존성과 설정값을 생성자 인자로 주입해야 하는 이유에 대해 설명해주세요.
- 객체의 불변성 확보 : 생성자 주입을 통해 변경의 가능성을 배제하고 불변성 보장
- 컴파일 시점에 객체를 주입받아 테스트 코드 작성이 가능하며, 주입하는 객체가 null인 경우 컴파일 시점에 오류 발견 가능
- 필드 객체에 final 키워드를 사용할 수 있고, 컴파일 시점에 누락된 의존성 확인 가능
-  애플리케이션 구동 시점(객체 생성 시점)에 순환 참조 에러 방지 가능

> 생성자 주입을 통해 객체의 책임을 명확히 할 수 있는 이유는 무엇인가요?
- 생성자 주입은 객체가 의존하는 모든 것을 명시적으로 요구하기 때문에, 해당 객체가 어떤 의존성에 의존하는지 명확히 드러납니다. 이는 객체의 책임이 명확하게 정의되도록 도와주며, 해당 객체의 역할과 의존성을 쉽게 이해할 수 있게 합니다.
> 생성자 주입을 사용했을 때, 객체 간 결합도를 낮추는 방법에는 무엇이 있나요?
- 생성자 주입을 통해 결합도를 낮추기 위해서는 인터페이스를 통한 의존성 주입을 권장합니다. 구체적인 구현체 대신 인터페이스를 생성자 인자로 받아들이면, 객체 간 결합도를 낮추고, 다양한 구현체를 통해 의존성을 교체할 수 있어 유연성과 확장성을 높일 수 있습니다.

# JPA

## JPA 영속성 컨텍스트의 이점(5가지)을 설명해주세요.
> JPA 영속성 컨텍스트
- 엔티티를 영구 저장하는 환경. 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터베이스 역할

> 이점 
1. 1차 캐시
- 1차 캐시에 엔티티를 저장하여 같은 트랜잭션 내에서 동일한 엔티티 조회시에 db 재조회를 하지않고 캐시에서 가져옵니다. db 접근을 줄여 성능을 향상
  
2. 동일성 보장
- 동일한 영속성 컨텍스트 내에서 조회된 엔티티는 동일한 객체
  
3. 변경 감지( Dirty Checking )
- JPA는 영속성 컨텍스트에서 관리되는 엔티티의 원본 상태(스냅샷)를 저장하고, 트랜잭션 중에 엔티티가 변경되었는지 지속적으로 감시

4. 쓰기 지연
-   트랜잭션을 커밋하기 직전까지 내부 쿼리 저장소에 insert sql을 모아둔 후 커밋시에 모아둔 쿼리를 DB에 보내는것
  
5. 지연 로딩
- 연관된 엔티티를 즉시 조회하지 않고, 프록시 객체로만 로딩되고, 해당 엔티티가 실제로 필요할 때 db에서 조회하는 방식

>  1차 캐시는 언제 초기화되나요?
- 1차 캐시는 트랜잭션 범위 내에서 유지되며, 트랜잭션이 종료되면 영속성 컨텍스트와 함께 초기화됩니다. 새로운 트랜잭션이 시작되면 새로운 영속성 컨텍스트가 생성되고, 이때 새로운 1차 캐시가 관리됩니다.
> flush 호출 시점
- 트랜잭션이 커밋될 때.
- JPQL 또는 Criteria 쿼리가 실행될 때.
- entityManager.flush()를 명시적으로 호출할 때.

## JPA Propagation 전파단계를 설명해주세요.
> JPA Propagation
- 트랜잭션 동작 도중 다른 트랜잭션을 호출하는 상황에 선택할 수 있는 옵션 (@Transactional)
  
> 전파단계
- REQUIRED: 현재 트랜잭션이 있으면 사용, 없으면 새로 생성 (기본값).
- REQUIRES_NEW: 무조건 새로운 트랜잭션 생성. 기존의 트랜잭션은 보류
- SUPPORTS: 트랜잭션이 있으면 사용, 없으면 트랜잭션 없이 실행.
- NOT_SUPPORTED: 트랜잭션이 있으면 일시 중단하고, 트랜잭션 없이 실행.
- MANDATORY: 기존 트랜잭션이 반드시 있어야 하며, 없으면 예외 발생.
- NEVER: 트랜잭션이 있으면 예외 발생, 없으면 트랜잭션 없이 실행.
- NESTED: 현재 트랜잭션 안에서 중첩된 트랜잭션으로 실행.

## JPA를 쓴다면 그 이유에 대해서 설명해주세요.
> 정의
- JPA(Java Persistence API)는 자바 진영의 ORM 기술 표준.
- 자바 애플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스
  
> 사용 이유
- 객체지행적인 프로그래밍이 가능하고, 데이터베이스 독립성을 제공합니다. 개발자는 객체 모델에 집중하여 코드 작성이 가능하며, JPA가 자동으로 SQL을 생성함으로써 생산성을 높입니다. DB 변경시 큰 수정없이 유지보수가 가능하고, 다양한 최적화 기능을 통해 효율적인 데이터 처리가 가능합니다.

> JPA와 Hibernate의 차이점은 무엇인가요?
- JPA는 자바 표준 명세로, 특정 구현체가 아닌 인터페이스의 집합입니다. Hibernate는 JPA를 구현한 ORM 프레임워크로, JPA의 표준 기능 외에도 다양한 확장 기능을 제공합니다. JPA는 인터페이스, Hibernate는 그 구현체라고 이해할 수 있습니다.

## N + 1 문제는 무엇이고 이것이 발생하는 이유와 이를 해결하는 방법을 설명해주세요.
> N+1 문제 발생이유
- JPA 같은 ORM에서 발생하는 성능 문제로, 연관 관계가 설정된 엔티티를 조회할 경우 연관된 데이터 수만큼 연관관계의 조회 쿼리가 추가로 발생하는 현상
  
> 해결 방법
1. join fetch 사용
- 조회 시 바로 가져오고 싶은 엔티티 필드를 지정하는것 (join fetch a.subjects)
- ex ) @Query("select a from Academy a join fetch a.subjects s join fetch s.teacher")
- inner join
- 불필요한 쿼리문이 추가되는 단점 존재

2. @EntityGraph
- @EntityGraph의 attributePaths에 쿼리 수행시 바로 가져올 필드명을 지정 @EntityGraph(attributePaths = "members")
- outer join 

> N+1 문제를 해결하기 위한 @EntityGraph와 JPQL의 JOIN FETCH의 장단점은 무엇인가요?
- @EntityGraph는 코드 내에서 쿼리를 직접 작성하지 않고도 간단히 설정할 수 있어 가독성이 높고 유지보수가 용이합니다. 반면, JPQL의 JOIN FETCH는 복잡한 조건이나 동적 쿼리를 사용할 때 더 유연하게 동작합니다. @EntityGraph는 간단한 쿼리에 적합하고, 복잡한 쿼리에서는 JPQL을 선호합니다.

> 지연 로딩과 즉시 로딩을 혼용할 때 N+1 문제가 발생할 수 있는 상황을 설명해보세요.
- 지연 로딩과 즉시 로딩을 함께 사용하면, 예상치 못한 시점에 쿼리가 발생할 수 있습니다. 예를 들어, 부모 엔티티는 지연 로딩으로 설정되어 있고, 자식 엔티티는 즉시 로딩으로 설정된 경우, 부모 엔티티를 조회할 때 자식 엔티티에 대한 추가 쿼리가 발생하면서 N+1 문제가 생길 수 있습니다.



