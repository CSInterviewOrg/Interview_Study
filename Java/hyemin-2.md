## Static이란 무엇인가요?
- 클래스 레벨에서 변수, 메서드, 초기화 블록을 정의할때 사용
- static 으로 선언된 변수나 메서드는 클래스에 속하며, 이는 클래스가 메모리에 로드될때 초기화되며, 
인스턴스화 없이 클래스 이름을 통해 직접 접근

## 자바의 원시타입(Primitive type)들은 무엇이 있으며 각각 몇 바이트를 차지하나요?
- 정수형: byte (1바이트), short (2바이트), int (4바이트), long (8바이트) <br> 
- 실수형: float (4바이트), double (8바이트) <br>
- 문자형: char (2바이트, 유니코드) <br>
- 논리형: boolean (크기 명시 없음, 보통 1비트 또는 1바이트) <br>

## 접근 제어자의 종류와 이에 대해 설명해주세요.
- 클래스, 변수, 메서드 등에 대한 접근 권한을 설정하여 코드의 캡슐화/정보 은닉에 사용
- private : 같은 클래스 내에서만 접근 가능 
- default : 같은 패키지 내에서만 접근 가능
- protected : 같은 패키지 내, 다른 패키지의 자손 클래스에서 접근 가능
- public : 접근 제한 없음

## 객체 지향에 대해서 설명해주세요.
- 객체(Objects)들이 모여서 상호 협력하면서 데이터를 처리하는 방식의 프로그래밍 설계 방법
- 객체 지향 프로그래밍 : 객체를 중심으로 소프트웨어를 설계하고 개발하는 패러다임으로, 객체들이 서로 상호작용하여 프로그램이 동작하게됨. 코드의 재사용성, 확장성, 유지보수성을 높이는것
- 객체 지향 4가지 핵심 원칙 : 캡슐화, 상속, 다형성, 추상화
- 추상화 ( Abstraction ) : 클래스를 정의할 때 불필요한 부분들을 생략하고, 객체의 속성에서 중요한 것에 중점을 두어 개략화 하는 것 <br>
&rarr; 데이터 추상화 : 객체의 관련 속성만 표시 ( 대상을 간단한 개념으로 일반화 )  <br>
&rarr; 제어 추상화 : 불필요한 세부정보는 숨김 ( 사용자에게 해당 메서드의 작동방식과 같은 내부 로직은 숨김 )
- 상속 ( Inheritance ) : 상위 클래스의 속성과 기능을 재사용하여 하위 클래스가 전부 물려받는것
- 캡슐화 ( Encapsulation ) : 객체의 속성(Field)과 행위(Method)를 하나로 묶고, 외부로부터 내부를 감싸 숨겨 은닉.
ex) protected, default , private
- 다형성 ( Polymorphism ) : 같은 자료형에 여러가지 타입의 데이터를 대입하여 다양한 결과를 얻어낼 수 있는 성질
ex) 오버로딩, 오버라이딩, 업캐스팅, 다운캐스팅, 인터페이스, 추상메소드, 추상클래스 .. 

## SOLID 에 대해서 설명해주세요 ( 객체 지향 5대 원칙 ) 
- SRP( Single Responsibility Principle ) : 단일 책임 원칙
- OCP ( Open Closed Principle ) : 개방 폐쇄 원칙
- LSP ( Listov Substution Principle ) : 리스코프 치환 원칙
- ISP ( Interface Segregation Principle ) : 인터페이스 분리 원칙
- DIP ( Dependency Inversion Principle ) : 의존 역전 원칙

- SRP : 하나의 클래스는 하나의 책임만 가져야 함. 즉, 하나의 클래스는 하나의 기능 담당하여 하나의 책임을 수행하는데 집중되도록 클래스를 따로 여러개 설계하라는 원칙
-> 번외로 이건 실무에서도 내가 많이 중점으로 두고 개발을 한 사항
- OCP : 확장에 열려있어야 하며, 수정에는 닫혀있어야한다. 즉, 기능 추가 요청이 오면 클래스는 확장을 통해 손쉽게 구현하면서, 확장에 따른 클래스 수정은 최소화 하도록 프로그램을 작성하는 설계 기법
        추상화 사용을 통한 관계 구축을 권장-> 다형성과 확장을 가능케 하는 객체지향의 장점을 극대화하는 기본적인 설계 원칙
- LSP : 다형성의 특성을 이용하기 위해 상위 클래스 타입으로 객체를 선언하여 하위 클래스의 인스턴스를 받으면, 업캐스팅된 상태에서 부모의 메서드를 사용해도 동작이 의도대로 흘러가야 하는 것. 
- ISP : 인터페이스를 사용하는 클라이언트를 기준으로 분리함으로써, 클라이언트의 목적과 용도에 적합한 인터페이스만을 제공하는 것
- DIP : 어떤 class 를 참조해서 사용해야하는 상황이 생긴다면, 그 class 를 직접 참조하는 것이 아니라 그 대상의 상위 요소(추상 클래스, 인터페이스) 로 참조하라는 원칙

## 동일성(identity)와 동등성(equality)에 대해 설명해주세요. (equals(), ==)
- 동일성 : 두 객체가 메모리상에서 같은 객체인지를 판단. 즉, 동일한 메모리 주소를 가리키는지 확인. "==" 연산자를 사용하여 비교
- 동등성 : 두 객체의 값이나 상태가 같은지를 판단. 즉, 객체가 다르더라도 내부 값이 동일하면 동등하다고 판단. "equals()" 메서드를 사용하여 비교

## 원시타입과 참조타입의 차이에 대해 설명해주세요.
- 기본형 ( primitive type ) : 계산을 위한 실제 값 . 모든 값 타입은 메모리 스택에 저장
- 참조형 ( reference type ) : 객체의 주소를 저장 . 배열 타입, 열거 타입, 클래스, 인터페이스 . 메모리의 힙에 실제 값을 저장하고, 그 참조값(주소값)을 갖는 변수는 스택에 저장
> 원시타입과 참조타입의 차이점

 원시타입은 값 자체를 저장하고, 스택 메모리에 저장. 참조타입은 객체의 주소를 저장하며, 스택에는 주소값이 실제 객체는 힙 메모리에 저장

## String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.
- 모두 문자열을 다루지만, 동작 방식, 성능, 스레드 안정성에 차이가 있음
> String
 - String 클래스는 불변 객체. 한번 생성된 문자열은 변경할 수 없고, 문자열을 수정하는 작업에는 항상 새로운 객체를 생성 
- 문자열을 변경할 때마다 새로운 객체를 생성하므로, 메모리 낭비 발생, 성능 저하, String 객체는 불변이므로 스레드 안전
> Stringbuilder 
- 가변 객체로, 문자열을 수정할 때 객체를 새로 생성하지 않고, 기존 객체를 수정 
- 문자열을 자주 변경한느 작업에서 사용되며, 스레드 안정성이 필요 없는 상황에서 성능 최적화 가능
> StringBuffer 
- Stringbuilder와 유사하지만, 동기화 되어 있어 스레드 안전. 다중 스레드 환경에서 문자열을 자주 수정해야 하는 경우에 사용
