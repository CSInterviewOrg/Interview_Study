## JVM의 구조와 Java의 실행방식을 설명해주세요.
### JVM
- Java virtual machine, 자바 가상 머신
- 자바 코드를 컴퓨터가 이해할 수 있도록 기계어로 변환해주고 운영체제에 구애 받지 않고 프로그램을 실행할 수 있도록 도와주는 중개자 역할
- 가비지 컬렉션을 사용해서 메모리 관리를 자동으로 수행
- 레지스터 기반이 아닌 스택 기반으로 동작
### JVM 구조
크게 Garbage collector, Execution Engine, Class Loader, Runtime Data Area 4가지로 구분
1. **Class Loader**
    - 런타임 시에 동적으로 클래스 파일 로딩하고 runtime data area로 적재
1. **Execution Engine**
    - 메모리에 적재된 바이트 코드를 기계어로 변환해 명령어 단위로 읽어 실행하는 역할
    - 인터프리터 방식을 사용하다가 성능이 떨어질 때에 JIT 컴파일러 방식으로 실행해서 속도 향상 및 성능 최적화
    - JIT 컴파일러는 바이트 코드를 네이티브 코드(기계어)로 바꿔서 실행은 빠르지만 변환하는데 비용 발생
    - Class Loader를 통해 JVM 내의 Runtime Data Area에 배치된 바이트 코드를 명령어 단위로 읽어서 실행
1. **Garbage Collector**
    - 힙 메모리 영역에 생성된 객체 중에서 참조되지 않은 객체를 탐색 후 제거
1. **Runtime Data Area**
    - JVM의 메모리 영역, 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역
    1. **Method Area**
        1. 모든 쓰레드가 공유하는 메모리 영역
        2. 클래스, 인터페이스, 메소드, 필드 등의 바이트 코드 보관
    2. **Heap area**
        1. 모든 쓰레드가 공유, 생성된 모든 객체와 배열이 저장되는 영역
        2. 호출이 끝난 후, 삭제되지 않고 유지되다가 GC가 참조되지 않는 메모리 확인해서 제거하는 영역
    3. **Stack area**
        1. 쓰레드 마다 존재
        2. 메서드 안에서 사용되는 값, 호출되는 메서드의 매개변수, 지역변수 등을 임시로 저장
    4. **PC Register**
        1. 쓰레드마다 하나씩 존재하고 쓰레드 시작시 생성
        2. 쓰레드가 어떤 부분을 무슨 명령으로 실행해야 할지에 대한 기록하는 부분
        3. 현재 수행 중인 JVM 명령의 주소
    7. **Native method stack**
        1. 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역
### Java 실행 방식
1. 자바 컴파일러가 자바 소스 파일을 바이트 코드로 변환
2. Class Loader를 통해 바이트 코드를 JVM으로 로딩하여 Runtime Data Area에 배치
3. Execution Engine이 메모리 영역에 올라온 바이트 코드 실행

## GC가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.
### 가비지 컬렉션
자바의 메모리 관리 방법, heap 영역에서 더이상 사용하지 않는 객체의 메모리를 주기적으로 검사해서 삭제하는 역할
### 필요성
한정적인 메모리 자원을 효율적으로 사용하기 위해 필요하지 않은 부분은 지워서 메모리 누수 방지
### 동작 방식
- 객체가 참조되고 있는 상태(Reachable)와 아닌 상태(Unreachable)로 구분
    > 참고되고 있는 상태: 다른 영역에서 힙 영역에 있는 객체를 참조하는 경우
- Mark and Sweep 방식
    - 대상 객체를 식별하고 제거하며 객체가 제거되어 파편화된 메모리 영역을 앞에서부터 채워나가는 작업 수행
### 동작 과정
- 객체의 생존 기간에 따라 힙 영역을 young과 old 2가지 영역으로 설계
    - Young 영역
        - 새롭게 생성된 객체가 할당되는 영역
        - 많은 객체가 young 영역에 생성되었다가 사라짐 (대부분의 객체는 일회성이고 메모리에 오랫동안 남아있는 경우는 흔하지 않음)
        - young 영역에 대한 가비지 컬렉션 = Minor GC
    - Old 영역
        - young 영역에서 살아남은 객체가 복사되는 영역
        - young 영역보다 크게 할당, 영역 크기가 큰 만큼 가비지 적게 발생
        - old 영역에 대한 가비지 컬렉션 = Major GC or Full GC
- 공통적인 방식
    - Stop the world
        - 가비지 컬렉션 실행을 위해 JVM이 애플리케이션의 실행을 멈추는 작업
        - GC를 실행하는 쓰레드 제외한 모든 쓰레드의 작업 중단
    - Mark and sweep
        - 객체 탐색하고 식별하여 사용되고 있지 않은 객체를 메모리에서 제거
- Minor GC
    - 상대적으로 공간이 작아 메모리상의 객체를 찾아 제거할 때 드는 시간이 적음
    - 처음 생성되면 Eden 영역에 위치 → Eden 영역이 꽉차면 Minor GC 실행 → Mark 동작을 통해 reachable 객체 탐색 → 살아남은 객체는 Survivor 영역으로 이동 → reachable 객체는 메모리 해제(sweep) 과정 반복
- Major GC
    - 상대적으로 큰 공간을 가지기 때문에 객체 제거에 많은 시간 소요
    - 객체의 age(살아남은 횟수)가 임계값에 도달하면 Old 영역으로 이동(promotion) → Old 영역에 공간이 꽉차면 Major GC 실행(stop the world)
- 이외에 다른 방식
    - Serial GC
    - Parallel GC
    - CMS GC
    - G1 GC
    
## 컬렉션 프레임워크에 대해서 설명해주세요.
다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합
= 데이터를 저장하는 자료구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현해놓은 것

* 데이터를 저장하는 자료 구조에 따라 주요 인터페이스 정의
   * List
   * Set
   * Map
   이 중에서 List, Set은 모두 Collection 인터페이스를 상속 받지만, Map은 구조상의 차이로 별도로 정의 => List, Set의 공통된 부분을 Collection에서 정의

## 제네릭에 대해서 설명해주세요.
데이터의 타입을 일반화하는 것 = 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법

- 컴파일 시에 미리 타입 검사를 수행하기 때문에 가지는 장점
    - 클래스나 메소드 내부에서 사용되는 객체의 타입 안정성 상승
    - 반환값에 대한 타입 변환 및 테스트 리소스 감소

## 애노테이션에 대해서 설명해주세요.
주석과 같은 역할을 하면서 코드에 특별한 의미, 기능 부여

- 장점
    - 컴파일러에게 코드 작성 문법 에러를 체크하도록 정보 제공
    - 소프트웨어 개발 환경이 빌드나 배포시 코드를 자동으로 생성할 수 있도록 정보 제공
    - 런타임에 특정 기능을 실행하도록 정보 제공

## 오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있을까요?
둘다 메소드의 다형성을 구현하는 것에 사용
### 오버라이딩
* 상속받은 메소드를 재정의하는 것
* 부모 클래스에서 정의한 메소드를 자식 클래스에서 재정의하며 상속받은 메소드를 상황에 맞게 사용 가능 => 코드의 재사용성, 확장성 상승
### 오버로딩
* 같은 이름의 메소드를 여러 개 정의하는 것
* 메소드의 이름은 동일하지만 파라미터의 타입이나 개수의 차이를 통해 같은 기능을 하는 메소드를 다양한 방식으로 호출 가능 => 코드의 가독성, 재사용성 상승

> @ Override 어노테이션 사용 이유
> 부모 클래스에 있는 메소드를 오버 라이드 했다는 것을 명시적으로 선언
> 여러 개의 메소드가 있을 경우 어떤 메소드가 오버라이드 되었는지 명시적으로 표시
> 컴파일시 문법 체크 가능

## 인터페이스와 추상클래스의 차이점에 대해 설명해주세요.
설계의 목적과 프로젝트의 요구사항에 따라 사용 결정
### 인터페이스
* 모든 메서드가 추상 메서드로 구성되어 구현 클래스에서 구현해야 함
* 구현 객체가 같은 동작을 보장하도록 하기 위해 사용
* 다중 상속을 지원하기 때문에 유연성, 확장성 제공
### 추상 클래스
* 추상, 일반 메서드 모두 포함 가능
* 공통적인 기능은 미리 구현하고 일부 기능은 자식 클래스에서 구현함으로써 코드의 중복 방지, 유지 보수 용이, 개발 시간 단축 가능
* 단일 상속만 지원

## 클래스는 무엇이고 객체는 무엇인가요?
설계도 <-> 설계도를 바탕으로 생성된 실체
### 클래스
객체를 생성하기 위한 틀, 객체의 속성과 행위 정의
### 객체
클래스에 정의된 속성과 행위를 실제로 구현하는 것, 프로그램에서 실제로 작업을 수행하는 주체

## 정적(static)이란 무엇인가요?
* 클래스 변수나 메소드에 사용되며 클래스 로드 시에 메모리에 할당되어 프로그램 종료시까지 유지
* 클래스의 인스턴스 간에 공유되는 속성이나 메소드 정의시에 유용
* 코드의 안정성, 재사용성을 높이는 것에 좋지만 모든 인스턴스가 공유하기 때문에 값이 변경되면 모든 인스턴스에 영향을 줄 수 있음
* 가비지 컬렉터가 관리하는 범위가 아니기 때문에 과하게 선언될 경우 성능에 문제가 발생할 수 있음
## 자바의 원시타입들은 무엇이 있으며 각각 몇 바이트를 차지하나요?
### 원시타입
stack 메모리 공간에 실제 데이터 값을 저장하는 타입
* boolean 1byte
* char 2byte
* byte 1byte
* short 2byte
* int 4byte
* long 8byte
* float 4byte
* double 8byte

<-> 참조 타입: 기본형 외의 타입 / stack에 객체의 주소를 저장하는 타입
## 접근 제어자의 종류와 이에 대해 설명해주세요.
* 변수나 메소드의 사용 권한을 위해 설정
* 접근 허용 순서: private < default < protected < public
   * private: 변수나 메소드가 해당 클래스 안에서만 접근 가능
   * default: 동일한 패키지 안에서 접근 가능 (설정하지 않을 경우 기본값)
   * protected: 변수나 메소드는 동일 패키지의 클래스 또는 해당 클래스는 상속받는 클래스에서 접근 가능
   * public: 어떤 클래스에서도 접근 가능
* 적절한 사용을 통해 프로그램의 캡슐화를 강화하고 데이터 보호 및 프로그램의 안정성 상승
## 객체지향에 대해서 설명해주세요.
* 각각의 독립적인 객체들의 유기적인 결합을 통해 하나의 프로그램을 완성하는 방법론
* 각 부분이 독립적인 역할을 하기 때문에 필요한 부분만 수정하고 다른 부분은 수정하지 않아 코드의 변경을 최소화하여 유연하고 유지보수에 용이한 프로그램 만들 수 있음
* 코드의 재사용을 통해 반복적인 코드를 최소화하고 간결하게 표현 가능
* 객체 지향 프로그래밍의 4가지 특성
   * 추상화
   * 상속
   * 다형성
   * 캡슐화
## SOLID(객체지향 5대원칙)에 대해서 설명해주세요.
관리하기 쉽고 이해하기 쉬운 유연한 소프트웨어를 생성하기 위한 원칙
* Single Responsibility (단일 책임 원칙)
   * 한 클래스는 하나의 책임만 갖는다.
   * 용이한 테스트 코드 작성, 낮은 종속성
* Open/Closed (개방폐쇄의 원칙)
   * 확장에는 열려있지만 수정에는 닫혀있어야 한다.
   * 확장을 통해 기존 코드에 영향을 주지 않도록 한다.
* Liskov Substitution (리스코프 치환의 원칙)
   * 클래스 A가 클래스 B의 자식 클래스인 경우 프로그램 동작에 문제 없이 B를 A로 대체할 수 있어야 한다.
   * 부모 클래스를 상속하는 자식 클래스가 부모 클래스의 동작을 위반하지 않아야 한다.
* Interface Segregation (인터페이스 분리의 원칙)
   * 큰 인터페이스를 작은 인터페이스로 분리해야 한다.
   * 필요하지 않은 메서드까지 관계를 맺지 않아도 되도록 세부적으로 분리해야 한다.
* Dependency Inversion (의존성 역전의 원칙)
   * 구현 클래스에 의존하지 말고 인터페이스에 의존해야 한다.
   * 유연하게 변경에 대처 가능
## 동일성(identity)와 동등성(equality)에 대해 설명해주세요. (equals(), ==)
### 동일성
* 메모리 상에서 같은 객체인지 판단
* 객체의 메모리 주소를 비교
* '==' 연산자 사용
### 동등성
* 두 객체의 상태나 값이 같은지 비교
* equals() 메소드를 오버라이딩해서 사용
## 원시타입과 참조타입의 차이에 대해 설명해주세요.
### 원시 타입
   * 실제 데이터 값을 저장
   * 정적 메모리 영역인 stack에 저장
   * 8개의 타입이 있음
   * null 값 존재하지 않음
### 참조 타입
   * 객체의 메모리 주소값을 참조
   * 동적 메모리 영역인 heap에 저장, 가비지 컬렉터로 메모리 해제
   * 실제 객체는 heap 영역에 저장, stack 영역에 실제 객체들의 주소를 저장
   * 빈객체 null 값 존재 → NullPointerException 발생 가능
## String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.
### String
* 불변한 문자열을 위한 클래스
### StringBuilder
* 가변한 문자열을 위한 클래스
* 새로운 문자열을 추가하거나 변경하면 기존의 객체가 추가/변경됨
* 멀티 쓰레드 환경에서 안정적이지 않으나 StringBuffer 보다 빠른 연산
### StringBuffer
* 가변한 문자열을 위한 클래스
* 새로운 문자열을 추가하거나 변경하면 기존의 객체가 추가/변경됨
* 동기화를 지원하기 때문에 멀티 쓰레드 환경에서도 안전하게 동작

## Checked Exception과 Unchecked Exception에 대해 설명해주세요. 스프링 트랜잭션 추상화에서 rollback 대상은 무엇일까요?
프로그램 실행 시 발생할 수 있는 오류를 처리하는 예외(Exception)에는 RuntimeException클래스를 상속 받는 클래스와 상속받지 않는 클래스로 구분된다.   
가장 큰 구분점은 컴파일 시점에 예외 처리를 강제 하는지 여부이다.
### Checked Exception
- RuntimeException을 상속하지 않는 클래스
- 컴파일 시점에 확인
- 반드시 오류 처리를 해줘야 한다. (외부의 동작에 의해 발생하는 예외)
- 종류
    - IOException
    - SQLException
    - ClassNotFoundException
    - InterruptedException
### Unchecked Exception
- RuntimeException을 상속하는 클래스
- 런타임 시점에서 확인
- 오류 처리 강제 x (예상치 못한 오류 발생 가능)
- 종류
    - NullPointerException
    - ArrayIndexOutOfBoundsException
### 스프링 트랜잭션 추상화에서 rollback 대상
* Checked Exception은 롤백하지 않고 예외 throw (컴파일러에 의해 강제되는 부분이기 때문에 따로 롤백 처리하지 않음)
* Unchecked Exception은 롤백 후 예외 throw

Spring Transactional 어노테이션은 기본적으로 UncheckedException만 롤백 진행하지만 모든 경우에 해당하지는 않는다.
- Spring Transactional 어노테이션에 rollbackFor 옵션을 이용하면 CheckedException도 롤백 가능
- 예외처리문 (try-catch)를 이용하여 RuntimeException을 따로 처리해주면 롤백 진행되지 않도록 처리 가능

> **예외와 에러의 차이**   
> - 에러: 시스템 레벨에서 발생하는 심각한 수준의 문제, 미리 예측하여 로직으로 처리하기 힘듬
>   - ex. 서버 과부하로 인한 문제
> - 예외: 프로그래머가 작성한 코드로 인해 발생하는 문제, 미리 예측 가능하기 때문에 올바른 처리를 통해 핸들링해주어야 함

> **throw와 throws의 차이는 무엇인가요?**    
> 프로그래머가 직접 예외를 발생 시키기 위해 사용
> - throw: 예외를 강제로 발생 후 상위 블럭이나 catch문으로 예외 전달
> - throws: 예외가 발생하면 상위 메서드로 예외 전달
>   - try, catch 구문 사용하지 않음 → 예외 처리를 호출부로 위임하기 때문에
> - 함께 사용할 경우, catch문, 호출부 각각에서 예외 처리 (두번 발생)

## Java8에서 추가된 기능에 대해서 설명해주세요.
### Java 8
- Oracle JDK / Open JDK로 나뉨
- Lambda
    - 람다식을 이용하여 간단한 식으로 표현 가능 (=익명함수)
- Stream
    - 컬렉션의 요소를 하나씩 순회하면서 처리할 수 있는 패턴
    - 람다식 지원, 내부 반복자를 사용하여 병렬 처리 가능
- Interface default method
    - 인터페이스에서 메서드 정의, 구현 가능
- Optional
    - 예상치 못한 NullPointerException 발생을 대비해서 사용

### Java 11
- 람다 지역변수 var 사용 가능하고 파라미터 어노테이션 사용 가능
- HTTP Client
    - HTTP 표준 클라이언트 구현
    - HTTP/1.1, HTTP/2 지원

### Java 17
- Sealed Class
    - 상속할 클래스를 지정해두고 해당 클래스들만 상속, 구현을 허용하는 키워드
    - 어떤 클래스가 상속 또는 구현될지 빠르게 파악 가능
- Record Data Class
    - 불변 데이터를 객체 간에 전달하는 작업을 간단하게 해줌
- Text Blocks
    - 멀티라인의 문자열을 이스케이프 시쿼스(\n) 없이도 사용 가능
 
## try-with-resource에 대해서 설명해주세요.    
- nputStream과 같은 입출력과 관련된 리소스는 사용하고 나면 close 메소드를 호출하여 닫아주어야 한다.
- try-catch-finally 구문을 이용하여 Checked Exception 예외처리를 해주고 마지막에 finally 에서 리소스를 닫아준다.
- 코드의 복잡도 증가 등의 문제점 발생

Java7 부터 추가된 try-with-resources
- 리소스를 자동으로 반환
- try 문이 끝나자마자 자동으로 close 실행하여 파일을 닫거나 자원 해제

> **try-with-resources 문에서 `close()` 메서드가 여러 번 호출될 경우 어떤 일이 발생하나요?**    
> try-with-resources 블록이 종료되면 자원은 한번만 닫히고 여러번 호출될 경우 close() 메서드가 여러 번 호출될 수 있다.
> 구현체가 잘 처리하도록 설계되어 있어야 하며 일반적으로는 close() 메서드가 여러번 호출되어도 문제 없도록 구현된다.

## 강한 결합과 느슨한 결합이 무엇인지 설명해주세요.
모듈 간의 의존하는 정도의 차이

### 강한 결합
구현 클래스를 직접 참조하기 때문에 Client단에서 많은 정보를 알아야 하고 많은 코드 수정 필요

### 느슨한 결합
추상화에 의존하기 때문에 클래스 간 결합력이 약하고 Client 단에서 적은 정보만 알아도 됨

> **자바에서 느슨한 결합을 구현하기 위해 어떤 디자인 패턴을 사용할 수 있나요?**   
> - **팩토리 패턴(Factory Pattern):** 객체 생성 로직을 분리하여 클래스 간의 결합도를 낮춥니다.
> - **옵저버 패턴(Observer Pattern):** 객체의 상태 변화에 따른 통지 메커니즘을 구현하여 모듈 간의 느슨한 결합을 유지합니다.
> - **전략 패턴(Strategy Pattern):** 알고리즘을 캡슐화하고 교환 가능하도록 하여 클라이언트와 알고리즘 간의 결합도를 줄입니다.

## 직렬화와 역직렬화에 대해서 설명해주세요.
### 직렬화
자바 시스템에서 사용되는 객체를 저장, 전송할 수 있는 형태(외부에서 사용할 수 있는 형태)로 변환하는 것
- 필요한 이유
    - 원시타입은 stack에 값 자체를 저장하기 때문에 값을 일정한 형식의 바이트 형태로 변환하여 외부로 전달 가능하지만 참조타입은 실제 값이 heap에 존재하고 해당 객체의 주소값을 stack에 저장
    - 외부에서 전달받은 메모리 주소의 값이 참조타입일 경우 메모리 주소만으로 원하는 데이터를 찾지 못할 수 있음(프로그램 종료시 제거됨)
    - 직렬화를 통해 데이터를 바이너리 등의 형태로 만들어 저장하거나 통신할 때 파싱 가능한 유의미한 데이터로 만들어줌

### 역직렬화
저장된 데이터를 읽거나 통신 과정에서 받은 데이터를 다시 원래 객체로 변환하는 것

> **자바 직렬화의 성능 문제와 이를 해결하기 위한 대안은 무엇인가요?**     
> 자바 직렬화는 성능이 저하될 수 있고 직렬화된 바이트 스트림이 클 경우 문제가 될 수 있다.    
> Json, xml, protobuf, avro 등의 직렬화 프레임 워크를 사용하여 더 효율적이고 압축된 데이터 표현이 가능하다.

> **직렬화, 역직렬화를 활용한 실제 예시를 들어주세요.**

## 자바의 동시성 이슈(공유자원 접근)에 대해 설명해주세요.
### 동시성
- 여러 쓰레드가 동시에 공유 자원에 접근하며 발생하는 문제
- 데이터 손상, 데드락, race condition 등의 문제 발생 가능
    - 데드락: 각 프로세스가 원하는 자원이 다른 프로세스에 할당되어 있어 모든 프로세스가 대기 상태
    - race condition(경쟁 상태): 여러 프로세스가 공유 자원에 접근하는 순서에 따라 결과 값이 달라지는 현상
### 해결 방법
1. 동기화 (synchronization)
   - synchronized 키워드를 코드 블록에 적용하면 하나의 스레드에서만 실행될 수 있도록 설정 가능
   - 여러 스레드가 해당 코드에 접근하기 위해 대기하면 자원 낭비 및 성능 저하 초래 가능
1. volatile
   - volatile 키워드를 사용하면 변수는 항상 메인 메모리에서 읽고 쓰이는 것이 보장됨 → 변수에 대한 변경 사항이 다른 쓰레드에 즉시 반영
1. 불변 객체
1. Atomic
   - CAS(compare-and-swap) 알고리즘 사용하여 동시성 제어: 메모리에 위치한 값을 현재의 값(A)과 비교하여 두 값이 일치 할 때에만 메모리 값을 새로운 값(B)으로 업데이트
   - 다른 쓰레드의 접근을 허용 → synchronized 처럼 lock 해제를 위해 대기하지 않고 각자의 작업을 수행할 수 있음

> **자바에서 동시성(concurrency)와 병렬성(parallelism)의 차이점은 무엇인가요?**      
> 동시성은 여러 작업이 동시에 진행될 수 있도록 하고, 하나의 프로세스에서 멀티 쓰레드를 사용하여 작업을 병행 (작업의 관리 방식)    
> 병렬성은 여러 프러세스나 코어를 사용하여 동시에 여러 작업을 처리하는 것을 의미 (실제 하드웨어 자원을 활용한 처리)
  
## Mutable 객체와 Immutable 객체의 차이점에 대해 설명해주세요.
### Mutable 객체
- 수정 가능한 객체, 수정 시 기존 객체의 값 변경
- getter, setter 존재
- 쓰레드 안정성 보장 못함
- StringBuffer, StringBuilder 등

### Immutable 객체
- 수정 불가능, 수정하려면 새로운 객체 생성하여 재할당 필요
- getter, setter 존재 x
- thread-safe, 성능 좋음, 메모리 사용량 줄일 수 있음
- String Class

> **Mutable 객체를 불변 객체로 변환하려고 할 때 어떤 접근 방식을 사용할 수 있나요?**     
> 기존의 mutable 객체를 불변 객체로 변환하기 위해 객체의 상태를 변경하지 않는 새로운 클래스를 정의할 수 있습니다. 생성자에서 모든 필드를 초기화하고, getter 메서드만 제공하여 외부에서 객체의 상태를 변경할 수 없도록 합니다. 또한, 컬렉션이나 배열을 사용하는 경우, 복사본을 생성하여 불변성을 유지할 수 있습니다.

> **Immutable 객체를 사용하여 멀티스레딩 문제를 해결한 경험이 있나요?**

## 자바에서 null을 안전하게 다루는 방법에 대해 설명해주세요.
1. assert문
    1. 조건이 거짓일 경우 AssertionError 발생
    2. 알맞은 예외를 발생시켜야 하는 경우 사용하기 힘듬
2. java.util.Optional
    1. optional 을 사용하여 NullPointerException이 발생하지 않도록 방지
3. Nullable 어노테이션

> **자바 17의 `record`와 `null` 관련 문제는 어떻게 해결하나요?**     
> 자바 17에서 소개된 `record`는 기본적으로 불변 객체로 설계됩니다. `record`의 필드는 `final`이며, 생성자에서 필드를 초기화하고, 이후에는 변경할 수 없습니다. `record`를 사용할 때는 생성자에서 `null` 값 검사를 수행하거나, `Optional`을 활용하여 안전하게 처리할 수 있습니다.

## JDK와 JRE의 차이점을 설명하세요.
### JDK
- Java Development Kit
- 자바로 개발할 때 사용되는 sdk - 개발 시 필요한 라이브러리, 개발 도구, JRE 포함

### JRE
- Java Runtime Environment
- 자바로 만들어진 프로그램을 실행하는데 필요한 라이브러리, API, JVM 포함

> **JVM의 역할과 JDK/JRE와의 관계를 설명해 주세요.**      
> JVM (Java Virtual Machine)은 자바 바이트코드를 실행하는 가상 머신입니다. JDK와 JRE는 JVM을 포함하며, JDK는 개발 도구를 추가로 포함합니다. JRE는 JVM을 포함하여 자바 애플리케이션을 실행할 수 있는 환경을 제공합니다.

## Spring DI/IoC는 어떻게 동작하나요?
### IoC
- Inversion of Control, 제어 역전
- 객체(빈)를 직접 관리하지 않고 외부(스프링 컨테이너)에서 관리하고 제공받아 사용하는 것 = 객체의 생명주기를 프레임워크나 컨테이너가 관리하는 원칙
### DI
- 사용할 객체를 직접 생성하지 않고 외부에서 생성한 객체를 주입받아 사용하는 객체
- 코드의 결합도를 낮추고 재사용성, 테스트 용이성 향상
- 주입 방법에는 생성자 주입, 필드 주입, setter 통한 주입이 있는데 가장 권장하는 방식은 생성자를 통한 주입이다.

## Spring Bean이란 무엇인가요?
스프링 컨테이너가 관리하는 자바 객체
### 스프링 컨테이너
- 스프링 빈의 생명 주기를 관리하고 생성된 스프링 빈에게 추가적인 기능을 제공하는 역할 (IoC, DI 원리가 여기 적용됨)
- new 연산자, 인터페이스 호출 등의 역할을 대신 해줌 → 외부에서 제어 흐름 관리, 객체들의 의존관계 생성
- @Component 어노테이션을 붙여주면 빈으로 등록 가능

## 스프링 Bean의 생성 과정을 설명해주세요.
객체 생성 → 의존성 설정 → 초기화 → 사용 → 소멸
- 스프링 컨테이너가 초기화될 때 먼저 빈을 생성하고 의존관계 설정한 뒤 프로세스가 완료되면 빈이 지정한 메소드를 호출하여 초기화 진행, 컨테이너가 종료될 때 빈이 지정한 메서드를 호출해 소멸
- 빈 객체의 클래스가 InitializingBean 인터페이스나 Disposable Bean을 구현하기 때문에 해당 인터페이스에서 정의된 메소드를 호출해서 빈 객체를 초기화하거나 종료한다.
- 빈 초기화 어노테이션: @PostConstruct
- 빈 소멸 어노테이션: @PreDestroy

## 스프링 Bean의 Scope에 대해서 설명해주세요.
빈이 존재하는 범위
- 싱글톤: 기본적으로 싱글톤 범위를 가지는데 스프링 컨테이너의 시작과 종료까지 하나의 객체만 사용하는 방식을 의미
    - 컨테이너에서 하나의 빈을 생성하고 여러 요청이 들어오면 미리 생성한 빈을 사용할 수 있도록 반환해주는 방식
- 프로토타입: 빈의 생성부터 의존 관계 주입까지만 관여하는 짧은 스코프
    - 요청이 들어면 빈을 생성하고 필요한 의존 관계 주입, 요청수만큼 생성
    - 같은 동작이라도 각각 생성하여 반환해주고 반환해준 후에는 관리하지 않음
- 웹 관련
    - request: 웹의 요청이 들오고 나갈 때까지 유지
    - session: 웹 세션이 생성되고 종료될 때까지 유지
    - application: 웹의 서블릿 콘텍스트와 같은 범위로 유지

## IoC 컨테이너의 역할은 무엇이 있을까요?
* IoC: 객체 생성부터 생명주기 관리까지 애플리케이션의 흐름을 스프링 컨테이너에서 관리하기 때문에 애플리케에션은 비즈니스 로직에 더 집중하고, 코드의 결합도를 낮추고 유연성 높일 수 있음

### IoC 컨테이너 역할
- IoC 컨테이너는 애플리케이션의 객체 생성과 의존성 주입, 생명주기 관리를 책임지는데 이는 ApplicationContext 인터페이스를 통해 구현하고 애플리케이션 전반에 걸쳐 컴포넌트 관리
- 스프링 빈의 정의와 의존성 설정 → 애플리케이션의 설정, 구성 유연하게 관리 가능
- 애플리케이션의 컴포넌트 간에 필요한 의존성 자동으로 주입 → 어노테이션을 사용할 수 있음
- 애플리케이션의 구성 요소 결합도 낮추고 컴포넌트 재사용성 높여주고 애플리케이션 테스트 및 유지보수 용이하게 해줌

## DI 종류는 어떤것이 있고, 이들의 차이는 무엇인가요?
- 생성자를 통한 주입
    - 가장 권장하는 방식
    - 생성자에 @Autowired 어노테이션 붙여서 주입
    - 초기에 의존 관계 설정되기 때문에 예외 발생 방지 가능
    - 순환참조를 컴파일 단계에서 찾을 수 있다.
    - 유일하게 final 키워드 사용 가능 → 생성자로 인해 인스턴스가 생성될 때 한번만 할당, 객체의 불변성 보장
- 필드 객체 선언을 통한 주입
    - @Autowired 어노테이션만 붙이면 사용 가능하기 때문에 편함
    - 의존성을 주입하기 쉬운만큼 하나의 클래스가 많은 책임을 갖게 될 수 있기 때문에 단일 책임 원칙을 위반할 수 있음
    - 의존 관계 파악이 어렵고 순환 참조 방지 불가
- setter를 통한 주입
    - 선택적인 의존성 주입 가능
    - 주입 받지 않은 구현체를 사용하게 되면 NPE 예외 발생

## Autowiring 과정에 대해서 설명해주세요.
- BeanPostProcessor 라는 라이프 사이클 인터페이스의 구현체인 AutowiredAnnotationBeanPostProcessor에 의해 의존성 주입 실행
- BeanPostProcessor는 초기화 라이프 사이클 이전, 이후에 필요한 부가 작업을 할 수 있는 라이프 사이클 콜백 → 빈이 만들어지는 시점 이전이나 이후에 추가적인 작업을 하고 싶을 때 사용
- AutowiredAnnotationBeanPostProcessor가 빈 초기화 라이프 사이클 이전(빈 인스턴스 생성 이전)에 @Autowired 붙어있는 빈을 찾아 주입

1. BeanFactory(ApplicationContext)가 BeanPostProcessor 타입의 빈을 찾음
2. IoC 컨테이너에 등록되어 있는 다른 빈에게 BeanPostProcessor 적용
3. 다른 빈에 @Autowired 어노테이션을 처리하는 AutowiredAnnotationBeanPostProcessor 의 로직이 적용
4. 의존성 주입 발생

## Spring Web MVC의 Dispatcher Servlet의 동작 원리에 대해서 간단히 설명해주세요.
### Dispatcher Servlet
- HTTP 프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 보내주는 프론트 컨트롤러
> 프론트 컨트롤러: 서블릿 컨테이너 제일 앞단에서 서버로 들어오는 클라이언트의 모든 요청을 받아 처리해주는 컨트롤러
- 클라이언트로부터 어떤 요청이 오게 되면 모든 요청을 먼저 받고 세부 컨트롤러에게 전달하는 역할

### 동작 과정
1. 클라이언트의 요청이 Dispatcher Servlet으로 전달
2. 요청 정보를 통해 요청을 위임한 컨트롤러 찾기 위해 Handlier Mapping으로 전달
3. Handling Mapping이 controller에 처리 요청
4. controller의 처리 결과를 Handler Adapter에서 ModelAndView 객체로 변환해서 Dispatcher Servlet 으로 전달
5. Dispatcher Servlet에서 전달받은 ModelAndView 객체를 이용하여 View 검색
6. viewResolver에서 처리결과를 view에 전달
7. 처리 결과가 포함된 view를 Dispatcher Servlet에 전달
8. Dispatcher Servlet에서 응답을 클라이언트에 전달

## 프론트 컨트롤러 패턴이란 무엇인가요?
- 여러 서블릿 컨트롤러 앞단에 두어 컨트롤러의 공통영역을 처리해주는 역할
- 공통 영역 처리 후 요청에 맞게 컨트롤러로 보내 처리할 수 있도록 해줌
- 프론트 컨트롤러에서 나머지 컨트롤러를 호출하기 때문에 프론트 컨트롤러 제외한 나머지 컨트롤러는 서블릿 사용하지 않아도됨

## Servlet Filter와 Spring Interceptor의 차이는 무엇인가요?
### Spring Filter
Dispatcher Servlet에 요청이 전달되기 전, 후에 url 패턴에 맞는 모든 요청에 대해 부가 작업을 처리할 수 있는 기능 제공 → 스프링 컨테이너가 아닌 톰캣과 같은 웹 컨테이너에 의해 관리가 되고 스프링 범위 밖에서 처리

- 메소드
    - init
        - 필터 객체를 초기화하고 서비스에 추가하기 위한 메소드
        - 초기화한 후에는 doFilter를 통해 처리 실행
    - doFilter
        - url 패턴에 맞는 모든 HTTP 요청이 Dispatcher Servlet으로 전달되기 전에 웹 컨테이너에 의해 실행되는 메소드
        - FilterChain 파라미터를 통해 다음 대상으로 요청 전달
    - destroy
        - 처리된 필터 객체를 웹 컨테이너가 destroy를 호출하여 필터 객체를 종료된 것을 확인해서 후처리로 doFilter에 의해 처리되지 않음

### Spring Interceptor
Dispatcher Servlet이 controller를 호출하기 전후에 요청과 응답을 참조하거나 가공할 수 있는 기능 제공 → 웹 컨테이너가 아닌 Spring 내부 컨텍스트에서 처리, Spring MVC에서 제공하는 기능

Dispatcher Servlet이 Handling mapping을 통해 컨트롤러를 찾도록 요청하는데 그 결과로 HandlerExecutionChain 반환 → 인터셉터가 등록되어 있으면 순차적으로 인터센터를 실행한 뒤 컨트롤러 실행 / 인터셉터 없으면 바로 컨트롤러 실행 (인터셉터가 직접 컨트롤러로 요청 x)

- 메소드
    - preHandle
        - 컨트롤러 이전에 처리해야 하는 전처리 작업이나 요청 정보를 가공하거나 추가하는 경우에 사용
    - postHandle
        - 컨트롤러 이후에 처리해야 하는 후처리 작업이 있을 때 사용
    - afterCompletion
        - 모든 뷰에서 최종 결과를 생성하는 일을 포함해 모든 작업이 완료된 후 실행
        - 요청 처리 중에 사용한 리소스를 반환할 때 사용하기에 적합

### 차이점
1. request, response 객체 조작 가능 여부
    - 필터는 조작 가능 ↔ 인터셉트는 불가
    - 필터는 필터 체이닝 과정에서 원하는 request, response 전달 가능
    - 인터셉터는 현재 인터셉터의 결과가 true/false 인지 에 따라 다음 과정 실행 (request, response 전달 불가)
2. 사용되는 경우
   - 필터
        1. 보안 및 인증/인가 작업
        2. 모든 요청에 대한 로깅, 검사
        3. 이미지/데이터 압축 및 문자열 인코딩
        4. Spring 과 분리되는 작업
   - 인터셉터
        1. 세부적인 보안 및 인증/인가 작업
        2. API 호출에 대한 로깅, 검사
        3. controller로 넘겨주는 정보 가공

## Spring에서 CORS 에러를 해결하기 위한 방법을 설명해주세요.
1. CorsFilter 생성
    - Filter 인터페이스를 구현하는 커스텀 필터 생성
    - doFilter() 부분에 허용해줄 정책에 대해 커스텀
2. @CrossOrigin 어노테이션
    - 컨트롤러 상단부, 메소드 상단부에 어노테이션 추가
    - 설정해줄 컨트롤러나 메소드가 많아지면 모든 곳애 추가해주어야 한다는 단점 존재
3. WebMvcConfigurer 통해 설정
    - WebMvcConfigurer 를 구현한 WebConfig 클래스 내부에서 CORS 관련 설정
  
## Bean/Component 어노테이션에 대해서 설명해주시고, 둘의 차이점에 대해 설명해주세요.
둘다 스프링 컨테이너에 빈을 등록하는 어노테이션

### Bean
- 프로그래머가 직접 제어가 불가능한 외부 라이브러리를 빈으로 등록하려 할 때 사용
- 메소드 레벨에 선언
- Configuration 어노테이션과 함께 사용

### Component
- 프로그래머가 직접 작성한 클래스를 빈으로 등록하기 위한 어노테이션
- 클래스 레벨에 선언
