## JVM의 구조와 Java의 실행방식을 설명해주세요.
### JVM
- Java virtual machine, 자바 가상 머신
- 자바 코드를 컴퓨터가 이해할 수 있도록 기계어로 변환해주고 운영체제에 구애 받지 않고 프로그램을 실행할 수 있도록 도와주는 중개자 역할
- 가비지 컬렉션을 사용해서 메모리 관리를 자동으로 수행
- 레지스터 기반이 아닌 스택 기반으로 동작
### JVM 구조
크게 Garbage collector, Execution Engine, Class Loader, Runtime Data Area 4가지로 구분
1. **Class Loader**
    - 런타임 시에 동적으로 클래스 파일 로딩하고 runtime data area로 적재
1. **Execution Engine**
    - 메모리에 적재된 바이트 코드를 기계어로 변환해 명령어 단위로 읽어 실행하는 역할
    - 인터프리터 방식을 사용하다가 성능이 떨어질 때에 JIT 컴파일러 방식으로 실행해서 속도 향상 및 성능 최적화
    - JIT 컴파일러는 바이트 코드를 네이티브 코드(기계어)로 바꿔서 실행은 빠르지만 변환하는데 비용 발생
    - Class Loader를 통해 JVM 내의 Runtime Data Area에 배치된 바이트 코드를 명령어 단위로 읽어서 실행
1. **Garbage Collector**
    - 힙 메모리 영역에 생성된 객체 중에서 참조되지 않은 객체를 탐색 후 제거
1. **Runtime Data Area**
    - JVM의 메모리 영역, 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역
    1. **Method Area**
        1. 모든 쓰레드가 공유하는 메모리 영역
        2. 클래스, 인터페이스, 메소드, 필드 등의 바이트 코드 보관
    2. **Heap area**
        1. 모든 쓰레드가 공유, 생성된 모든 객체와 배열이 저장되는 영역
        2. 호출이 끝난 후, 삭제되지 않고 유지되다가 GC가 참조되지 않는 메모리 확인해서 제거하는 영역
    3. **Stack area**
        1. 쓰레드 마다 존재
        2. 메서드 안에서 사용되는 값, 호출되는 메서드의 매개변수, 지역변수 등을 임시로 저장
    4. **PC Register**
        1. 쓰레드마다 하나씩 존재하고 쓰레드 시작시 생성
        2. 쓰레드가 어떤 부분을 무슨 명령으로 실행해야 할지에 대한 기록하는 부분
        3. 현재 수행 중인 JVM 명령의 주소
    7. **Native method stack**
        1. 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역
### Java 실행 방식
1. 자바 컴파일러가 자바 소스 파일을 바이트 코드로 변환
2. Class Loader를 통해 바이트 코드를 JVM으로 로딩하여 Runtime Data Area에 배치
3. Execution Engine이 메모리 영역에 올라온 바이트 코드 실행

## GC가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.
### 가비지 컬렉션
자바의 메모리 관리 방법, heap 영역에서 더이상 사용하지 않는 객체의 메모리를 주기적으로 검사해서 삭제하는 역할
### 필요성
한정적인 메모리 자원을 효율적으로 사용하기 위해 필요하지 않은 부분은 지워서 메모리 누수 방지
### 동작 방식
- 객체가 참조되고 있는 상태(Reachable)와 아닌 상태(Unreachable)로 구분
    > 참고되고 있는 상태: 다른 영역에서 힙 영역에 있는 객체를 참조하는 경우
- Mark and Sweep 방식
    - 대상 객체를 식별하고 제거하며 객체가 제거되어 파편화된 메모리 영역을 앞에서부터 채워나가는 작업 수행
### 동작 과정
- 객체의 생존 기간에 따라 힙 영역을 young과 old 2가지 영역으로 설계
    - Young 영역
        - 새롭게 생성된 객체가 할당되는 영역
        - 많은 객체가 young 영역에 생성되었다가 사라짐 (대부분의 객체는 일회성이고 메모리에 오랫동안 남아있는 경우는 흔하지 않음)
        - young 영역에 대한 가비지 컬렉션 = Minor GC
    - Old 영역
        - young 영역에서 살아남은 객체가 복사되는 영역
        - young 영역보다 크게 할당, 영역 크기가 큰 만큼 가비지 적게 발생
        - old 영역에 대한 가비지 컬렉션 = Major GC or Full GC
- 공통적인 방식
    - Stop the world
        - 가비지 컬렉션 실행을 위해 JVM이 애플리케이션의 실행을 멈추는 작업
        - GC를 실행하는 쓰레드 제외한 모든 쓰레드의 작업 중단
    - Mark and sweep
        - 객체 탐색하고 식별하여 사용되고 있지 않은 객체를 메모리에서 제거
- Minor GC
    - 상대적으로 공간이 작아 메모리상의 객체를 찾아 제거할 때 드는 시간이 적음
    - 처음 생성되면 Eden 영역에 위치 → Eden 영역이 꽉차면 Minor GC 실행 → Mark 동작을 통해 reachable 객체 탐색 → 살아남은 객체는 Survivor 영역으로 이동 → reachable 객체는 메모리 해제(sweep) 과정 반복
- Major GC
    - 상대적으로 큰 공간을 가지기 때문에 객체 제거에 많은 시간 소요
    - 객체의 age(살아남은 횟수)가 임계값에 도달하면 Old 영역으로 이동(promotion) → Old 영역에 공간이 꽉차면 Major GC 실행(stop the world)
- 이외에 다른 방식
    - Serial GC
    - Parallel GC
    - CMS GC
    - G1 GC
    
## 컬렉션 프레임워크에 대해서 설명해주세요.
다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합
= 데이터를 저장하는 자료구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현해놓은 것

* 데이터를 저장하는 자료 구조에 따라 주요 인터페이스 정의
   * List
   * Set
   * Map
   이 중에서 List, Set은 모두 Collection 인터페이스를 상속 받지만, Map은 구조상의 차이로 별도로 정의 => List, Set의 공통된 부분을 Collection에서 정의

## 제네릭에 대해서 설명해주세요.
데이터의 타입을 일반화하는 것 = 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법

- 컴파일 시에 미리 타입 검사를 수행하기 때문에 가지는 장점
    - 클래스나 메소드 내부에서 사용되는 객체의 타입 안정성 상승
    - 반환값에 대한 타입 변환 및 테스트 리소스 감소

## 애노테이션에 대해서 설명해주세요.
주석과 같은 역할을 하면서 코드에 특별한 의미, 기능 부여

- 장점
    - 컴파일러에게 코드 작성 문법 에러를 체크하도록 정보 제공
    - 소프트웨어 개발 환경이 빌드나 배포시 코드를 자동으로 생성할 수 있도록 정보 제공
    - 런타임에 특정 기능을 실행하도록 정보 제공

## 오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있을까요?
둘다 메소드의 다형성을 구현하는 것에 사용
### 오버라이딩
* 상속받은 메소드를 재정의하는 것
* 부모 클래스에서 정의한 메소드를 자식 클래스에서 재정의하며 상속받은 메소드를 상황에 맞게 사용 가능 => 코드의 재사용성, 확장성 상승
### 오버로딩
* 같은 이름의 메소드를 여러 개 정의하는 것
* 메소드의 이름은 동일하지만 파라미터의 타입이나 개수의 차이를 통해 같은 기능을 하는 메소드를 다양한 방식으로 호출 가능 => 코드의 가독성, 재사용성 상승

> @ Override 어노테이션 사용 이유
> 부모 클래스에 있는 메소드를 오버 라이드 했다는 것을 명시적으로 선언
> 여러 개의 메소드가 있을 경우 어떤 메소드가 오버라이드 되었는지 명시적으로 표시
> 컴파일시 문법 체크 가능

## 인터페이스와 추상클래스의 차이점에 대해 설명해주세요.
설계의 목적과 프로젝트의 요구사항에 따라 사용 결정
### 인터페이스
* 모든 메서드가 추상 메서드로 구성되어 구현 클래스에서 구현해야 함
* 구현 객체가 같은 동작을 보장하도록 하기 위해 사용
* 다중 상속을 지원하기 때문에 유연성, 확장성 제공
### 추상 클래스
* 추상, 일반 메서드 모두 포함 가능
* 공통적인 기능은 미리 구현하고 일부 기능은 자식 클래스에서 구현함으로써 코드의 중복 방지, 유지 보수 용이, 개발 시간 단축 가능
* 단일 상속만 지원

## 클래스는 무엇이고 객체는 무엇인가요?
설계도 <-> 설계도를 바탕으로 생성된 실체
### 클래스
객체를 생성하기 위한 틀, 객체의 속성과 행위 정의
### 객체
클래스에 정의된 속성과 행위를 실제로 구현하는 것, 프로그램에서 실제로 작업을 수행하는 주체

## 정적(static)이란 무엇인가요?
* 클래스 변수나 메소드에 사용되며 클래스 로드 시에 메모리에 할당되어 프로그램 종료시까지 유지
* 클래스의 인스턴스 간에 공유되는 속성이나 메소드 정의시에 유용
* 코드의 안정성, 재사용성을 높이는 것에 좋지만 모든 인스턴스가 공유하기 때문에 값이 변경되면 모든 인스턴스에 영향을 줄 수 있음
* 가비지 컬렉터가 관리하는 범위가 아니기 때문에 과하게 선언될 경우 성능에 문제가 발생할 수 있음
## 자바의 원시타입들은 무엇이 있으며 각각 몇 바이트를 차지하나요?
### 원시타입
stack 메모리 공간에 실제 데이터 값을 저장하는 타입
* boolean 1byte
* char 2byte
* byte 1byte
* short 2byte
* int 4byte
* long 8byte
* float 4byte
* double 8byte

<-> 참조 타입: 기본형 외의 타입 / stack에 객체의 주소를 저장하는 타입
## 접근 제어자의 종류와 이에 대해 설명해주세요.
* 변수나 메소드의 사용 권한을 위해 설정
* 접근 허용 순서: private < default < protected < public
   * private: 변수나 메소드가 해당 클래스 안에서만 접근 가능
   * default: 동일한 패키지 안에서 접근 가능 (설정하지 않을 경우 기본값)
   * protected: 변수나 메소드는 동일 패키지의 클래스 또는 해당 클래스는 상속받는 클래스에서 접근 가능
   * public: 어떤 클래스에서도 접근 가능
* 적절한 사용을 통해 프로그램의 캡슐화를 강화하고 데이터 보호 및 프로그램의 안정성 상승
## 객체지향에 대해서 설명해주세요.
* 각각의 독립적인 객체들의 유기적인 결합을 통해 하나의 프로그램을 완성하는 방법론
* 각 부분이 독립적인 역할을 하기 때문에 필요한 부분만 수정하고 다른 부분은 수정하지 않아 코드의 변경을 최소화하여 유연하고 유지보수에 용이한 프로그램 만들 수 있음
* 코드의 재사용을 통해 반복적인 코드를 최소화하고 간결하게 표현 가능
* 객체 지향 프로그래밍의 4가지 특성
   * 추상화
   * 상속
   * 다형성
   * 캡슐화
## SOLID(객체지향 5대원칙)에 대해서 설명해주세요.
관리하기 쉽고 이해하기 쉬운 유연한 소프트웨어를 생성하기 위한 원칙
* Single Responsibility (단일 책임 원칙)
   * 한 클래스는 하나의 책임만 갖는다.
   * 용이한 테스트 코드 작성, 낮은 종속성
* Open/Closed (개방폐쇄의 원칙)
   * 확장에는 열려있지만 수정에는 닫혀있어야 한다.
   * 확장을 통해 기존 코드에 영향을 주지 않도록 한다.
* Liskov Substitution (리스코프 치환의 원칙)
   * 클래스 A가 클래스 B의 자식 클래스인 경우 프로그램 동작에 문제 없이 B를 A로 대체할 수 있어야 한다.
   * 부모 클래스를 상속하는 자식 클래스가 부모 클래스의 동작을 위반하지 않아야 한다.
* Interface Segregation (인터페이스 분리의 원칙)
   * 큰 인터페이스를 작은 인터페이스로 분리해야 한다.
   * 필요하지 않은 메서드까지 관계를 맺지 않아도 되도록 세부적으로 분리해야 한다.
* Dependency Inversion (의존성 역전의 원칙)
   * 구현 클래스에 의존하지 말고 인터페이스에 의존해야 한다.
   * 유연하게 변경에 대처 가능
## 동일성(identity)와 동등성(equality)에 대해 설명해주세요. (equals(), ==)
### 동일성
* 메모리 상에서 같은 객체인지 판단
* 객체의 메모리 주소를 비교
* '==' 연산자 사용
### 동등성
* 두 객체의 상태나 값이 같은지 비교
* equals() 메소드를 오버라이딩해서 사용
## 원시타입과 참조타입의 차이에 대해 설명해주세요.
### 원시 타입
   * 실제 데이터 값을 저장
   * 정적 메모리 영역인 stack에 저장
   * 8개의 타입이 있음
   * null 값 존재하지 않음
### 참조 타입
   * 객체의 메모리 주소값을 참조
   * 동적 메모리 영역인 heap에 저장, 가비지 컬렉터로 메모리 해제
   * 실제 객체는 heap 영역에 저장, stack 영역에 실제 객체들의 주소를 저장
   * 빈객체 null 값 존재 → NullPointerException 발생 가능
## String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.
### String
* 불변한 문자열을 위한 클래스
### StringBuilder
* 가변한 문자열을 위한 클래스
* 새로운 문자열을 추가하거나 변경하면 기존의 객체가 추가/변경됨
* 멀티 쓰레드 환경에서 안정적이지 않으나 StringBuffer 보다 빠른 연산
### StringBuffer
* 가변한 문자열을 위한 클래스
* 새로운 문자열을 추가하거나 변경하면 기존의 객체가 추가/변경됨
* 동기화를 지원하기 때문에 멀티 쓰레드 환경에서도 안전하게 동작

## Checked Exception과 Unchecked Exception에 대해 설명해주세요. 스프링 트랜잭션 추상화에서 rollback 대상은 무엇일까요?
프로그램 실행 시 발생할 수 있는 오류를 처리하는 예외(Exception)에는 RuntimeException클래스를 상속 받는 클래스와 상속받지 않는 클래스로 구분된다.   
가장 큰 구분점은 컴파일 시점에 예외 처리를 강제 하는지 여부이다.
### Checked Exception
- RuntimeException을 상속하지 않는 클래스
- 컴파일 시점에 확인
- 반드시 오류 처리를 해줘야 한다. (외부의 동작에 의해 발생하는 예외)
- 종류
    - IOException
    - SQLException
    - ClassNotFoundException
    - InterruptedException
### Unchecked Exception
- RuntimeException을 상속하는 클래스
- 런타임 시점에서 확인
- 오류 처리 강제 x (예상치 못한 오류 발생 가능)
- 종류
    - NullPointerException
    - ArrayIndexOutOfBoundsException
### 스프링 트랜잭션 추상화에서 rollback 대상
* Checked Exception은 롤백하지 않고 예외 throw (컴파일러에 의해 강제되는 부분이기 때문에 따로 롤백 처리하지 않음)
* Unchecked Exception은 롤백 후 예외 throw

Spring Transactional 어노테이션은 기본적으로 UncheckedException만 롤백 진행하지만 모든 경우에 해당하지는 않는다.
- Spring Transactional 어노테이션에 rollbackFor 옵션을 이용하면 CheckedException도 롤백 가능
- 예외처리문 (try-catch)를 이용하여 RuntimeException을 따로 처리해주면 롤백 진행되지 않도록 처리 가능

> **예외와 에러의 차이**   
> - 에러: 시스템 레벨에서 발생하는 심각한 수준의 문제, 미리 예측하여 로직으로 처리하기 힘듬
>   - ex. 서버 과부하로 인한 문제
> - 예외: 프로그래머가 작성한 코드로 인해 발생하는 문제, 미리 예측 가능하기 때문에 올바른 처리를 통해 핸들링해주어야 함

> **throw와 throws의 차이는 무엇인가요?**    
> 프로그래머가 직접 예외를 발생 시키기 위해 사용
> - throw: 예외를 강제로 발생 후 상위 블럭이나 catch문으로 예외 전달
> - throws: 예외가 발생하면 상위 메서드로 예외 전달
>   - try, catch 구문 사용하지 않음 → 예외 처리를 호출부로 위임하기 때문에
> - 함께 사용할 경우, catch문, 호출부 각각에서 예외 처리 (두번 발생)

## Java8에서 추가된 기능에 대해서 설명해주세요.
### Java 8
- Oracle JDK / Open JDK로 나뉨
- Lambda
    - 람다식을 이용하여 간단한 식으로 표현 가능 (=익명함수)
- Stream
    - 컬렉션의 요소를 하나씩 순회하면서 처리할 수 있는 패턴
    - 람다식 지원, 내부 반복자를 사용하여 병렬 처리 가능
- Interface default method
    - 인터페이스에서 메서드 정의, 구현 가능
- Optional
    - 예상치 못한 NullPointerException 발생을 대비해서 사용

### Java 11
- 람다 지역변수 var 사용 가능하고 파라미터 어노테이션 사용 가능
- HTTP Client
    - HTTP 표준 클라이언트 구현
    - HTTP/1.1, HTTP/2 지원

### Java 17
- Sealed Class
    - 상속할 클래스를 지정해두고 해당 클래스들만 상속, 구현을 허용하는 키워드
    - 어떤 클래스가 상속 또는 구현될지 빠르게 파악 가능
- Record Data Class
    - 불변 데이터를 객체 간에 전달하는 작업을 간단하게 해줌
- Text Blocks
    - 멀티라인의 문자열을 이스케이프 시쿼스(\n) 없이도 사용 가능
 
## try-with-resource에 대해서 설명해주세요.    
- nputStream과 같은 입출력과 관련된 리소스는 사용하고 나면 close 메소드를 호출하여 닫아주어야 한다.
- try-catch-finally 구문을 이용하여 Checked Exception 예외처리를 해주고 마지막에 finally 에서 리소스를 닫아준다.
- 코드의 복잡도 증가 등의 문제점 발생

Java7 부터 추가된 try-with-resources
- 리소스를 자동으로 반환
- try 문이 끝나자마자 자동으로 close 실행하여 파일을 닫거나 자원 해제

> **try-with-resources 문에서 `close()` 메서드가 여러 번 호출될 경우 어떤 일이 발생하나요?**    
> try-with-resources 블록이 종료되면 자원은 한번만 닫히고 여러번 호출될 경우 close() 메서드가 여러 번 호출될 수 있다.
> 구현체가 잘 처리하도록 설계되어 있어야 하며 일반적으로는 close() 메서드가 여러번 호출되어도 문제 없도록 구현된다.

## 강한 결합과 느슨한 결합이 무엇인지 설명해주세요.
모듈 간의 의존하는 정도의 차이

### 강한 결합
구현 클래스를 직접 참조하기 때문에 Client단에서 많은 정보를 알아야 하고 많은 코드 수정 필요

### 느슨한 결합
추상화에 의존하기 때문에 클래스 간 결합력이 약하고 Client 단에서 적은 정보만 알아도 됨

> **자바에서 느슨한 결합을 구현하기 위해 어떤 디자인 패턴을 사용할 수 있나요?**   
> - **팩토리 패턴(Factory Pattern):** 객체 생성 로직을 분리하여 클래스 간의 결합도를 낮춥니다.
> - **옵저버 패턴(Observer Pattern):** 객체의 상태 변화에 따른 통지 메커니즘을 구현하여 모듈 간의 느슨한 결합을 유지합니다.
> - **전략 패턴(Strategy Pattern):** 알고리즘을 캡슐화하고 교환 가능하도록 하여 클라이언트와 알고리즘 간의 결합도를 줄입니다.

## 직렬화와 역직렬화에 대해서 설명해주세요.
### 직렬화
자바 시스템에서 사용되는 객체를 저장, 전송할 수 있는 형태(외부에서 사용할 수 있는 형태)로 변환하는 것
- 필요한 이유
    - 원시타입은 stack에 값 자체를 저장하기 때문에 값을 일정한 형식의 바이트 형태로 변환하여 외부로 전달 가능하지만 참조타입은 실제 값이 heap에 존재하고 해당 객체의 주소값을 stack에 저장
    - 외부에서 전달받은 메모리 주소의 값이 참조타입일 경우 메모리 주소만으로 원하는 데이터를 찾지 못할 수 있음(프로그램 종료시 제거됨)
    - 직렬화를 통해 데이터를 바이너리 등의 형태로 만들어 저장하거나 통신할 때 파싱 가능한 유의미한 데이터로 만들어줌

### 역직렬화
저장된 데이터를 읽거나 통신 과정에서 받은 데이터를 다시 원래 객체로 변환하는 것

> **자바 직렬화의 성능 문제와 이를 해결하기 위한 대안은 무엇인가요?**     
> 자바 직렬화는 성능이 저하될 수 있고 직렬화된 바이트 스트림이 클 경우 문제가 될 수 있다.    
> Json, xml, protobuf, avro 등의 직렬화 프레임 워크를 사용하여 더 효율적이고 압축된 데이터 표현이 가능하다.

> **직렬화, 역직렬화를 활용한 실제 예시를 들어주세요.**

## 자바의 동시성 이슈(공유자원 접근)에 대해 설명해주세요.
### 동시성
- 여러 쓰레드가 동시에 공유 자원에 접근하며 발생하는 문제
- 데이터 손상, 데드락, race condition 등의 문제 발생 가능
    - 데드락: 각 프로세스가 원하는 자원이 다른 프로세스에 할당되어 있어 모든 프로세스가 대기 상태
    - race condition(경쟁 상태): 여러 프로세스가 공유 자원에 접근하는 순서에 따라 결과 값이 달라지는 현상
### 해결 방법
1. 동기화 (synchronization)
   - synchronized 키워드를 코드 블록에 적용하면 하나의 스레드에서만 실행될 수 있도록 설정 가능
   - 여러 스레드가 해당 코드에 접근하기 위해 대기하면 자원 낭비 및 성능 저하 초래 가능
1. volatile
   - volatile 키워드를 사용하면 변수는 항상 메인 메모리에서 읽고 쓰이는 것이 보장됨 → 변수에 대한 변경 사항이 다른 쓰레드에 즉시 반영
1. 불변 객체
1. Atomic
   - CAS(compare-and-swap) 알고리즘 사용하여 동시성 제어: 메모리에 위치한 값을 현재의 값(A)과 비교하여 두 값이 일치 할 때에만 메모리 값을 새로운 값(B)으로 업데이트
   - 다른 쓰레드의 접근을 허용 → synchronized 처럼 lock 해제를 위해 대기하지 않고 각자의 작업을 수행할 수 있음

> **자바에서 동시성(concurrency)와 병렬성(parallelism)의 차이점은 무엇인가요?**      
> 동시성은 여러 작업이 동시에 진행될 수 있도록 하고, 하나의 프로세스에서 멀티 쓰레드를 사용하여 작업을 병행 (작업의 관리 방식)    
> 병렬성은 여러 프러세스나 코어를 사용하여 동시에 여러 작업을 처리하는 것을 의미 (실제 하드웨어 자원을 활용한 처리)
  
## Mutable 객체와 Immutable 객체의 차이점에 대해 설명해주세요.
### Mutable 객체
- 수정 가능한 객체, 수정 시 기존 객체의 값 변경
- getter, setter 존재
- 쓰레드 안정성 보장 못함
- StringBuffer, StringBuilder 등

### Immutable 객체
- 수정 불가능, 수정하려면 새로운 객체 생성하여 재할당 필요
- getter, setter 존재 x
- thread-safe, 성능 좋음, 메모리 사용량 줄일 수 있음
- String Class

> **Mutable 객체를 불변 객체로 변환하려고 할 때 어떤 접근 방식을 사용할 수 있나요?**     
> 기존의 mutable 객체를 불변 객체로 변환하기 위해 객체의 상태를 변경하지 않는 새로운 클래스를 정의할 수 있습니다. 생성자에서 모든 필드를 초기화하고, getter 메서드만 제공하여 외부에서 객체의 상태를 변경할 수 없도록 합니다. 또한, 컬렉션이나 배열을 사용하는 경우, 복사본을 생성하여 불변성을 유지할 수 있습니다.

> **Immutable 객체를 사용하여 멀티스레딩 문제를 해결한 경험이 있나요?**

## 자바에서 null을 안전하게 다루는 방법에 대해 설명해주세요.
1. assert문
    1. 조건이 거짓일 경우 AssertionError 발생
    2. 알맞은 예외를 발생시켜야 하는 경우 사용하기 힘듬
2. java.util.Optional
    1. optional 을 사용하여 NullPointerException이 발생하지 않도록 방지
3. Nullable 어노테이션

> **자바 17의 `record`와 `null` 관련 문제는 어떻게 해결하나요?**     
> 자바 17에서 소개된 `record`는 기본적으로 불변 객체로 설계됩니다. `record`의 필드는 `final`이며, 생성자에서 필드를 초기화하고, 이후에는 변경할 수 없습니다. `record`를 사용할 때는 생성자에서 `null` 값 검사를 수행하거나, `Optional`을 활용하여 안전하게 처리할 수 있습니다.

## JDK와 JRE의 차이점을 설명하세요.
### JDK
- Java Development Kit
- 자바로 개발할 때 사용되는 sdk - 개발 시 필요한 라이브러리, 개발 도구, JRE 포함

### JRE
- Java Runtime Environment
- 자바로 만들어진 프로그램을 실행하는데 필요한 라이브러리, API, JVM 포함

> **JVM의 역할과 JDK/JRE와의 관계를 설명해 주세요.**      
> JVM (Java Virtual Machine)은 자바 바이트코드를 실행하는 가상 머신입니다. JDK와 JRE는 JVM을 포함하며, JDK는 개발 도구를 추가로 포함합니다. JRE는 JVM을 포함하여 자바 애플리케이션을 실행할 수 있는 환경을 제공합니다.

## Spring DI/IoC는 어떻게 동작하나요?
### IoC
- Inversion of Control, 제어 역전
- 객체(빈)를 직접 관리하지 않고 외부(스프링 컨테이너)에서 관리하고 제공받아 사용하는 것 = 객체의 생명주기를 프레임워크나 컨테이너가 관리하는 원칙
### DI
- 사용할 객체를 직접 생성하지 않고 외부에서 생성한 객체를 주입받아 사용하는 객체
- 코드의 결합도를 낮추고 재사용성, 테스트 용이성 향상
- 주입 방법에는 생성자 주입, 필드 주입, setter 통한 주입이 있는데 가장 권장하는 방식은 생성자를 통한 주입이다.

## Spring Bean이란 무엇인가요?
스프링 컨테이너가 관리하는 자바 객체
### 스프링 컨테이너
- 스프링 빈의 생명 주기를 관리하고 생성된 스프링 빈에게 추가적인 기능을 제공하는 역할 (IoC, DI 원리가 여기 적용됨)
- new 연산자, 인터페이스 호출 등의 역할을 대신 해줌 → 외부에서 제어 흐름 관리, 객체들의 의존관계 생성
- @Component 어노테이션을 붙여주면 빈으로 등록 가능

## 스프링 Bean의 생성 과정을 설명해주세요.
객체 생성 → 의존성 설정 → 초기화 → 사용 → 소멸
- 스프링 컨테이너가 초기화될 때 먼저 빈을 생성하고 의존관계 설정한 뒤 프로세스가 완료되면 빈이 지정한 메소드를 호출하여 초기화 진행, 컨테이너가 종료될 때 빈이 지정한 메서드를 호출해 소멸
- 빈 객체의 클래스가 InitializingBean 인터페이스나 Disposable Bean을 구현하기 때문에 해당 인터페이스에서 정의된 메소드를 호출해서 빈 객체를 초기화하거나 종료한다.
- 빈 초기화 어노테이션: @PostConstruct
- 빈 소멸 어노테이션: @PreDestroy

## 스프링 Bean의 Scope에 대해서 설명해주세요.
빈이 존재하는 범위
- 싱글톤: 기본적으로 싱글톤 범위를 가지는데 스프링 컨테이너의 시작과 종료까지 하나의 객체만 사용하는 방식을 의미
    - 컨테이너에서 하나의 빈을 생성하고 여러 요청이 들어오면 미리 생성한 빈을 사용할 수 있도록 반환해주는 방식
- 프로토타입: 빈의 생성부터 의존 관계 주입까지만 관여하는 짧은 스코프
    - 요청이 들어면 빈을 생성하고 필요한 의존 관계 주입, 요청수만큼 생성
    - 같은 동작이라도 각각 생성하여 반환해주고 반환해준 후에는 관리하지 않음
- 웹 관련
    - request: 웹의 요청이 들오고 나갈 때까지 유지
    - session: 웹 세션이 생성되고 종료될 때까지 유지
    - application: 웹의 서블릿 콘텍스트와 같은 범위로 유지

## IoC 컨테이너의 역할은 무엇이 있을까요?
* IoC: 객체 생성부터 생명주기 관리까지 애플리케이션의 흐름을 스프링 컨테이너에서 관리하기 때문에 애플리케에션은 비즈니스 로직에 더 집중하고, 코드의 결합도를 낮추고 유연성 높일 수 있음

### IoC 컨테이너 역할
- IoC 컨테이너는 애플리케이션의 객체 생성과 의존성 주입, 생명주기 관리를 책임지는데 이는 ApplicationContext 인터페이스를 통해 구현하고 애플리케이션 전반에 걸쳐 컴포넌트 관리
- 스프링 빈의 정의와 의존성 설정 → 애플리케이션의 설정, 구성 유연하게 관리 가능
- 애플리케이션의 컴포넌트 간에 필요한 의존성 자동으로 주입 → 어노테이션을 사용할 수 있음
- 애플리케이션의 구성 요소 결합도 낮추고 컴포넌트 재사용성 높여주고 애플리케이션 테스트 및 유지보수 용이하게 해줌

## DI 종류는 어떤것이 있고, 이들의 차이는 무엇인가요?
- 생성자를 통한 주입
    - 가장 권장하는 방식
    - 생성자에 @Autowired 어노테이션 붙여서 주입
    - 초기에 의존 관계 설정되기 때문에 예외 발생 방지 가능
    - 순환참조를 컴파일 단계에서 찾을 수 있다.
    - 유일하게 final 키워드 사용 가능 → 생성자로 인해 인스턴스가 생성될 때 한번만 할당, 객체의 불변성 보장
- 필드 객체 선언을 통한 주입
    - @Autowired 어노테이션만 붙이면 사용 가능하기 때문에 편함
    - 의존성을 주입하기 쉬운만큼 하나의 클래스가 많은 책임을 갖게 될 수 있기 때문에 단일 책임 원칙을 위반할 수 있음
    - 의존 관계 파악이 어렵고 순환 참조 방지 불가
- setter를 통한 주입
    - 선택적인 의존성 주입 가능
    - 주입 받지 않은 구현체를 사용하게 되면 NPE 예외 발생

## Autowiring 과정에 대해서 설명해주세요.
- BeanPostProcessor 라는 라이프 사이클 인터페이스의 구현체인 AutowiredAnnotationBeanPostProcessor에 의해 의존성 주입 실행
- BeanPostProcessor는 초기화 라이프 사이클 이전, 이후에 필요한 부가 작업을 할 수 있는 라이프 사이클 콜백 → 빈이 만들어지는 시점 이전이나 이후에 추가적인 작업을 하고 싶을 때 사용
- AutowiredAnnotationBeanPostProcessor가 빈 초기화 라이프 사이클 이전(빈 인스턴스 생성 이전)에 @Autowired 붙어있는 빈을 찾아 주입

1. BeanFactory(ApplicationContext)가 BeanPostProcessor 타입의 빈을 찾음
2. IoC 컨테이너에 등록되어 있는 다른 빈에게 BeanPostProcessor 적용
3. 다른 빈에 @Autowired 어노테이션을 처리하는 AutowiredAnnotationBeanPostProcessor 의 로직이 적용
4. 의존성 주입 발생

## Spring Web MVC의 Dispatcher Servlet의 동작 원리에 대해서 간단히 설명해주세요.
### Dispatcher Servlet
- HTTP 프로토콜로 들어오는 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 보내주는 프론트 컨트롤러
> 프론트 컨트롤러: 서블릿 컨테이너 제일 앞단에서 서버로 들어오는 클라이언트의 모든 요청을 받아 처리해주는 컨트롤러
- 클라이언트로부터 어떤 요청이 오게 되면 모든 요청을 먼저 받고 세부 컨트롤러에게 전달하는 역할

### 동작 과정
1. 클라이언트의 요청이 Dispatcher Servlet으로 전달
2. 요청 정보를 통해 요청을 위임한 컨트롤러 찾기 위해 Handlier Mapping으로 전달
3. Handling Mapping이 controller에 처리 요청
4. controller의 처리 결과를 Handler Adapter에서 ModelAndView 객체로 변환해서 Dispatcher Servlet 으로 전달
5. Dispatcher Servlet에서 전달받은 ModelAndView 객체를 이용하여 View 검색
6. viewResolver에서 처리결과를 view에 전달
7. 처리 결과가 포함된 view를 Dispatcher Servlet에 전달
8. Dispatcher Servlet에서 응답을 클라이언트에 전달

## 프론트 컨트롤러 패턴이란 무엇인가요?
- 여러 서블릿 컨트롤러 앞단에 두어 컨트롤러의 공통영역을 처리해주는 역할
- 공통 영역 처리 후 요청에 맞게 컨트롤러로 보내 처리할 수 있도록 해줌
- 프론트 컨트롤러에서 나머지 컨트롤러를 호출하기 때문에 프론트 컨트롤러 제외한 나머지 컨트롤러는 서블릿 사용하지 않아도됨

## Servlet Filter와 Spring Interceptor의 차이는 무엇인가요?
### Spring Filter
Dispatcher Servlet에 요청이 전달되기 전, 후에 url 패턴에 맞는 모든 요청에 대해 부가 작업을 처리할 수 있는 기능 제공 → 스프링 컨테이너가 아닌 톰캣과 같은 웹 컨테이너에 의해 관리가 되고 스프링 범위 밖에서 처리

- 메소드
    - init
        - 필터 객체를 초기화하고 서비스에 추가하기 위한 메소드
        - 초기화한 후에는 doFilter를 통해 처리 실행
    - doFilter
        - url 패턴에 맞는 모든 HTTP 요청이 Dispatcher Servlet으로 전달되기 전에 웹 컨테이너에 의해 실행되는 메소드
        - FilterChain 파라미터를 통해 다음 대상으로 요청 전달
    - destroy
        - 처리된 필터 객체를 웹 컨테이너가 destroy를 호출하여 필터 객체를 종료된 것을 확인해서 후처리로 doFilter에 의해 처리되지 않음

### Spring Interceptor
Dispatcher Servlet이 controller를 호출하기 전후에 요청과 응답을 참조하거나 가공할 수 있는 기능 제공 → 웹 컨테이너가 아닌 Spring 내부 컨텍스트에서 처리, Spring MVC에서 제공하는 기능

Dispatcher Servlet이 Handling mapping을 통해 컨트롤러를 찾도록 요청하는데 그 결과로 HandlerExecutionChain 반환 → 인터셉터가 등록되어 있으면 순차적으로 인터센터를 실행한 뒤 컨트롤러 실행 / 인터셉터 없으면 바로 컨트롤러 실행 (인터셉터가 직접 컨트롤러로 요청 x)

- 메소드
    - preHandle
        - 컨트롤러 이전에 처리해야 하는 전처리 작업이나 요청 정보를 가공하거나 추가하는 경우에 사용
    - postHandle
        - 컨트롤러 이후에 처리해야 하는 후처리 작업이 있을 때 사용
    - afterCompletion
        - 모든 뷰에서 최종 결과를 생성하는 일을 포함해 모든 작업이 완료된 후 실행
        - 요청 처리 중에 사용한 리소스를 반환할 때 사용하기에 적합

### 차이점
1. request, response 객체 조작 가능 여부
    - 필터는 조작 가능 ↔ 인터셉트는 불가
    - 필터는 필터 체이닝 과정에서 원하는 request, response 전달 가능
    - 인터셉터는 현재 인터셉터의 결과가 true/false 인지 에 따라 다음 과정 실행 (request, response 전달 불가)
2. 사용되는 경우
   - 필터
        1. 보안 및 인증/인가 작업
        2. 모든 요청에 대한 로깅, 검사
        3. 이미지/데이터 압축 및 문자열 인코딩
        4. Spring 과 분리되는 작업
   - 인터셉터
        1. 세부적인 보안 및 인증/인가 작업
        2. API 호출에 대한 로깅, 검사
        3. controller로 넘겨주는 정보 가공

## Spring에서 CORS 에러를 해결하기 위한 방법을 설명해주세요.
1. CorsFilter 생성
    - Filter 인터페이스를 구현하는 커스텀 필터 생성
    - doFilter() 부분에 허용해줄 정책에 대해 커스텀
2. @CrossOrigin 어노테이션
    - 컨트롤러 상단부, 메소드 상단부에 어노테이션 추가
    - 설정해줄 컨트롤러나 메소드가 많아지면 모든 곳애 추가해주어야 한다는 단점 존재
3. WebMvcConfigurer 통해 설정
    - WebMvcConfigurer 를 구현한 WebConfig 클래스 내부에서 CORS 관련 설정
  
## Bean/Component 어노테이션에 대해서 설명해주시고, 둘의 차이점에 대해 설명해주세요.
둘다 스프링 컨테이너에 빈을 등록하는 어노테이션

### Bean
- 프로그래머가 직접 제어가 불가능한 외부 라이브러리를 빈으로 등록하려 할 때 사용
- 메소드 레벨에 선언
- Configuration 어노테이션과 함께 사용

### Component
- 프로그래머가 직접 작성한 클래스를 빈으로 등록하기 위한 어노테이션
- 클래스 레벨에 선언

## POJO란 무엇인가요? Spring Framework에서 POJO는 무엇이 될 수 있을까요?
### POJO
- Plain Old Java Object, 자바로 생성하는 순수한 객체
- EJB 등에서 사용되는 java bean이 아닌 getter, setter 로 구성된 가장 순수한 형태의 기본 클래스
- EJB의 사용과 프로그램의 규모 증가로 자바 코드는 가독성이 떨어져서 유지보수가 여려워지고 직접 특정 클래스에 의존하는 등 객체 지향성을 잃어가기 때문에 다시 순수했던 객체지향으로 돌아가자는 취지로 나옴
- 특징
    - default 생성자 있어야 함
    - 다른 자바 프로그램들이 클래스의 값에 접근 가능
    - 미리 정의된 클래스나 인터페이스를 사용하면 안됨
### POJO 프레임워크
POJO 장점과 EJB에서 제공하는 서비스와 기술을 그대로 사용할 수 있도록 도와주는 프레임워크

1. 하이버네이트
    - persistence 기술과 오브젝트-관계형 DB 매핑을 POJO를 이용해서 사용할 수 있게 만드는 POJO 기반의 퍼시스턴스 프레임워크
    - JDBC API를 직접 사용하는 것과 비슷한 성능을 제공, 복잡한 퍼시스턴스 로직 개발 가능
2. Spring
    - 엔터프라이즈 서비스를 POJO 기반으로 만든 비즈니스 오브젝트에서 사용할 수 있게 해주는 프레임워크
    - POJO 프로그래밍을 지향하는 프레임워크이기 때문에 다른 환경, 기술에 종속되지 않도록 IoC/DI, AOP 등을 지원

> [하이버네이트와 스프링의 차이점]
> - 하이버네이트는 JPA 구현체 (인터페이스와 구현체의 관계와 같은)
> - 스프링 data JPA는 JPA에 대한 데이터 접근 추상화, 스프링에서 제공하는 모듈 중 하나로 jpa 위에 추가적인 기능을 제공해서 jpa 기반 개발을 편하게 만들어주는 프레임워크

## Spring Web MVC에서 요청 마다 Thread가 생성되어 Controller를 통해 요청을 수행할텐데, 어떻게 1개의 Controller만 생성될 수 있을까요?
- 생성한 controller 클래스에 대한 정보가 JVM 메모리 영역 중 Method Area에 올라가기 때문에 가능
- controller 하나를 생성하면 객체는 heap 영역에 생성되지만 해당 클래스의 정보는 Method Area에 저장되기 때문에 모든 쓰레드가 접근가능하여 객체의 바이너리 코드 공유 가능
- 여러개의 쓰레드가 싱글톤으로 생성된 controller를 참고하여 실행됨
- controller가 상태를 갖지 않도록 구현하는 것이 중요함

### 쓰레드 풀
- 프로그램 실행에 필요한 쓰레드 미리 생성
- 매 요청마다 쓰레드를 생성하고 소멸하는 것을 성능 저하 일으킬 수 있음 → 쓰레드풀 활용
- 동작 방식
  1. core size만큼 쓰레드 생성
  2. 유저 요청이 들어올 때마다 큐에 저장
  3. 남는 쓰레드가 있다면 큐에서 요청을 꺼내 쓰레드에 할당 후 처리
  4. 쓰레드가 없다면 큐에서 대기
  5. 큐가 꽉차면 쓰레드 새로 생성
  6. 쓰레드가 최대 사이즈에 도달하고 큐도 꽉차면 connection-refused 오류 반환
  7. 큐가 비어있고 core size 이상의 쓰레드가 생성되었을 경우 쓰레드 destroy

## Spring WEB MVC의 근간에는 Java Servlet 이 있는데요. Spring 은 Servlet을 어떻게 구성해서 이를 구현했을까요?
### 서블릿
- 자바를 이용해서 웹 페이지를 동적으로 생성하는 기술
- HTTP 요청을 받아 처리하고 그 결과를 웹 브라우저에게 돌려주는 역할
- 웹 서버가 요청을 받아 서블릿 컨테이너에게 전달하고 서블릿 컨테이너는 요청을 처리할 서블릿을 찾아 실행
- 서블릿 컨테이너는 서블릿 생명주기를 관리하고 요청에 따라 서블릿을 로딩, 초기화, 실행, 종료 하는 역할
- 서블릿이 싱글톤으로 관리되기 때문에 서블릿은 생성되고 소멸되지 않고 같은 요청이 들어오면 또다시 호출 → 이런 서블릿 생명주기를 서블릿 컨테이너에서 담당
### 스프링
- 서블릿을 포함해 다양한 웹 개발 기능 제공하는 프레임워크
- 전면 컨트롤러인 Dispatcher Servlet을 두어 앞단에서 공통 로직을 처리하도록 수행 → 서블릿은 하나만 두고 모든 요청을 다 받음
- 웹 요청 처리 관련된 구현을 직접하지 않고 비즈니스 로직에 집중할 수 있음 (IoC)

## Filter는 Servlet의 스펙이고, Interceptor는 Spring MVC의 스펙입니다. Spring Application에서 Filter와 Interceptor를 통해 예외를 처리할 경우 어떻게 해야 할까요?

### 인터셉터 예외 처리
1. @ExceptionHanlder 어노테이션을 이용해서 에러 핸들링
2. @ControllerAdvie 어노테이션을 사용해서 전체 컨트롤러에 대해 에러 핸들링

### 필터 예외 처리
1. 필터는 @RestControllerAdvice, @ControllerAdvice의 에러 핸들링 범위에 포함되지 못함 → ErrorController에서 처리
2. 필터의 상위에 예외 처리하는 필터를 만들어서 Filter Chain에 추가

> [서블릿 예외에 대한 처리]
>
> WAS에 에러 요청 페이지 상태 코드가 전달되면 WAS에서 직접 URL 요청 → 필터, 서블릿, 인터셉터도 다시 한번 호출되는데 이미 확인된 부분이기 때문에 WAS에서 재요청시 한번더 필터와 인터셉터를 호출하는 것은 비효율적
> 1. Filter Dispatcher Type을 이용한 중복 처리 제거
>    - Dispatcher Type에 현재 요청 타입을 알려줌
>    - Dispatcher Type에 따라 다른 필터를 호출할지 여부 판단 가능
> 2. Interceptor 의 중복 처리
>    - 요청 타입에 따라 인터셉터 호출 설정 불가 (항상 호출)
>    - 요청 경로에 따라 쉽게 인터셉터 추가 제외 가능 → excludePathPatterns를 이용해서 에러 요청 페이지 경로를 제외

## Spring Application을 구동할 때 메서드를 실행시키는 방법에 대해 설명해주세요.
생성자 호출시에 스프링빈이 초기화되지 않으면 NPE 문제가 필드 초기화 과정에서 발생 가능 → 문제를 해결하고 스프링 시작 로딩 때 로직 실행하는 방법

1. @PostConstruct 어노테이션: 특정 클래스의 메소드에 붙여서 해당 클래스의 객체 내 모든 빈들이 초기화 직후 한번 실행되어야 하는 메소드
2. Initializing Bean 인터페이스: PostConstruct 와 방식은 유사하고 어노테이션 대신 InitializingBean 인터페이스와 afterPropertiesSet() 메소드 구현해서 사용
3. ApplicationListener: 특정 빈에 초점을 맞추지 않고 모든 빈의 초기화가 완료된 후에 실행
4. CommandLineRunner: CommandLineRunner 인터페이스의 run 콜백 메소드 안에 원하는 로직 작성 → Spring ApplicationContext 초기화 완료 후에 실행
5. ApplicationRunner: CommandLineRunner 과 동일하게 run이라는 콜백 메소드 안에 로직 작성

## 의존성과 설정값을 생성자 인자로 주입해야 하는 이유에 대해 설명해주세요.
1. 객체의 변경 가능성을 배제하고 불변성 보장
2. 컴파일 시점에 객체를 주입받기 때문에 누락되는 경우 오류 발견 가능, 테스트 코드 작성 가능
3. final 키워드를 사용하기 때문에 컴파일 시점에 누락된 의존성 확인 가능
4. 객체 생성 시점에 순환 참조 에러 확인 가능

## JPA 영속성 컨텍스트의 이점(5가지)을 설명해주세요.
### 영속성 컨텍스트 (Persistence Context)
- Entity를 영구적으로 저장하는 환경
- 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 논리적 개념
- EntityManager를 생성할 때 함께 생성되고(1:1) EntityManager를 통해 접근하고 관리 가능
- 엔티티를 식별자 값으로 구분하기 때문에 식별자 값 반드시 존재
    
### 이점
1. 1차 캐시
   - db 조회하면 db에 쿼리를 날리지 않고 영속성 컨테스트에 저장되어 있는 값을 반환
   - 영속성 컨텍스트에 값이 없을 경우 db에서 값을 조회한 후 1차 캐시에 저장하고 반환
   - DB 조회 횟수 줄일 수 있음
   - 요청이 끝나고 영속성 컨텍스트가 제거되면 1차 캐시도 사라짐
2. 동일성 보장: 1차 캐시에 있는 동일한 인스턴스를 반환하기 때문에 동일성 보장
3. 쓰기 지연: 커밋하는 시점에 쿼리 날리는 것
   - 쓰기 지연 sql 저장소에 쿼리문을 임시로 저장했다가 커밋하는 시점에 저장되어 있는 쿼리를 모아서 날림
   - 하나씩 처리하지 않고 한번에 처리하기 때문에 최적화 가능        
4. 변경 감지: 트랜잭션되면 flush 호출하고 엔티티와 1차 캐시의 스냅샷 비교 → 변경이 있을 경우 update 쿼리를 쓰기 지연 sql에 저장, 커밋 전에 내부적으로 flush 호출해서 변경된 사항 쿼리로 발송
5. 지연 로딩: 연관관계 매핑되어 있는 엔티티 조회시 프록시를 반환하여 쿼리는 진짜 필요할 때 날림

> [Flush]
> - 영속성 컨테스트의 변경 내용을 데이터베이스에 반영
> - 플러시 발생 방법
>   - em.flush()
>   - 트랜잭션 커밋
>   - jpql 커밋 실행

## JPA Propagation 전파단계를 설명해주세요.
### 트랜잭션 전파 속성
- Spring의 @Transactional 어노테이션은 여러 트랜잭션을 묶어서 하나의 트랜잭션 경계를 만들 수 있다.
- 이미 트랜잭션이 진행 중일 때 추가 트랜잭션을 어떻게 진행할지 결정하는 것
    - 기존 트랜잭션에 참여하거나 별도 트랜잭션을 진행하거나 에러를 발생하거나 등을 선택할 수 있다.
### 전파 속성 7가지
- 스프링에는 7가지 속성 존재
- REQUERED
    - default 속성
    - 2개의 논리 트랜잭션을 묶어서 1개의 물리 트랜잭션을 사용하는 것 → 내부 트랜잭션은 기존에 존재하는 외부 트랜잭션에 참여하여 외부 트랜잭션을 그대로 이어감 (외부 트랜잭션 범위가 내부까지 확장)
- REQUERES_NEW
    - 외부 트랜잭션과 내부 트랜잭션을 완전히 분리 → 2개의 물리 트랜잭션 사용, 각각 트랜잭션 별로 커밋과 롤백 수행
    - 2개의 커넥션이 존재하고 내부 트랜잭션이 처리중일 때는 외부 트랜잭션이 대기하기 때문에 데이터베이스 커넥션 고갈 가능
- 이 외에 SUPPORTS, MANDATORY, NOT_SUPPORTED, NEVER, NESTED 가 있음

## JPA를 쓴다면 그 이유에 대해서 설명해주세요.
### JPA
- Java Persistence API, 자바 ORM 기술에 대한 API 표준 명세서
- 자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 효율적으로 관리할 수 있는 프레임워크
- 객체 지향 프로그래밍에서 다루는 복잡한 객체 관계를 RDB가 이애할 수 있는 방식으로 쉽게 변환 가능 → Entity라는 자바 객체와 데이터 베이스 테이블을 매핑하여 객체의 변화를 데이터베이스에 자동으로 반영할 수 있도록 해줌
### 장점
- 개발 생산성, 유지 보수성 향상
- SQL에 의존하지 않고 객체 중심적으로 개발 가능
- 패러다임 불일치 해결
### 고려할 사항
- 불필요한 쿼리 실행 or 데이터베이스와의 상호작용이 비효율적일 수 있기 때문에 성능 최적화를 위한 전략 필요
- N + 1 문제 등 해결 필요

## N + 1 문제는 무엇이고 이것이 발생하는 이유와 이를 해결하는 방법을 설명해주세요.
### N + 1 문제
- 연관관계가 설정된 엔티티를 조회할 경우 데이터 개수만큼 연관관계의 조회 쿼리가 발생하는 문제
- 즉시 로딩일 경우, 데이터를 조회하고 해당 데이터의 연관 관계인 하위 엔티티를 추가로 조회하기 때문에 발생
- 지연 로딩일 경우, 데이터를 조회하고 추가 조회하지는 않지만 하위 엔티티를 사용하게 되면 추가 조회가 발생하기 때문에 결국에는 N + 1 문제 발생
### 해결 방법
1. Fetch Join
    - 지연 로딩으로 설정되어 있는 연관관계에 있는 엔티티에 join 쿼리를 발생시켜 한번에 조회할 수 있는 방법 (미리 join 해놓고 한번에 모든 데이터 호출)
    - db 스키마를 엔티티로 변환해서 영속성 컨텍스트에 저장
        - fetch join을 하면 연관관계는 영속성 컨텍스트에 1차 캐시로 저장되기 때문에 다시 엔티티를 탐색하더라고 조회 쿼리 실행 x
    - 1:N 관계가 두개 이상인 경우 사용할 수 없고 쿼리문 작성 필요
2. @BatchSize
    - 지연 로딩시 프록시 객체를 조회할 때 where in 절로 묶어서 한번에 조회할 수 있게 해주는 옵션
    - fetch join 보다 더 많은 쿼리 개수 발생 가능
3. @EntityGraph
    - attributePaths에 같이 조회할 연관 엔티티명 작성
    - outer join을 기본으로 사용하기 때문에 성능 최적화에 유리하지는 않음 (fetch join은 inner join)
    - 1:N 관계를 여러개 join할 수 있음
