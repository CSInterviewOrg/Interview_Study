**가상화란 무엇이며, 운영 체제에서 왜 중요한가요?**

- 가상화란 컴퓨팅의 실제 물리 자원인 CPU, Memory, Disk..를 가상 자원 또는 논리적인 자원인 Process, Virtual Memory, File으로 추상화 시키는 것입니다.
- 이러한 가상화가 중요한 이유는 디테일하고 불필요한 정보를 감추고 필요한 정보에만 집중하여 시스템이 보다 효율적이고 정확하게 작동할 수 있게끔 하기 위함입니다. → 예를 들어서 실제로 CPU는 한개이지만 여러 개의 가상 CPU(Process)로 분할하여 여러 프로그램을 동시에 실행 시킬 수 있는 것이 하나의 예입니다.
    - Program: 실행 중이 아니며 디스크에 존재하는 것
    - Process: CPU에 스케줄링 되는(CPU 스케줄링에 대기하는 것도 포함하는) 프로그램
    - Job: CPU에 스케줄링 되고 있는 프로세스
- 그래서 운영체제는 이러한 물리 자원 또는 하드웨어 자원을 가상화(추상화) 시키며 추상화된 자원들을 관리하는 Resource Manager입니다.
- 참고: https://pawoo0211.tistory.com/61

**운영 체제가 CPU, 메모리, 디스크를 가상화한 것은 무엇인가요?**

- CPU → 프로세스
- 메모리 → Virtual Memory
- 디스크 → File System

**운영체제에서 커널이란 무엇이며 시스템 콜에 대해서 설명해주세요**

- 커널이란 실질적으로 하드웨어 자원에 접근하거나 하드웨어 자원을 관리하는 운영체제의 핵심 부분입니다.
    - 운영체제와 커널의 차이점은 운영체제에 포함되는 많은 요소 중 핵심 요소가 커널입니다.
- 커널 모드: CPU가 특권 명령어를 실행할 수 있는 모드로 실질적으로 하드웨어 자원에 접근할 수 있는 상태입니다. 커널 모드가 아닐 경우 하드웨어 자원에 접근할 수 없습니다.
- 유저 모드: 사용자 Application이 실행 되는 모드로 하드웨어 자원에 대해서 직접적으로 접근할 수 없는 모드입니다. 그렇기에 유저 모드에서 하드웨어 자원에 접근할 경우 반드시 커널을 통해서 접근을 할 수 있습니다.
- 시스템 콜: 유저 모드에서 하드웨어 자원에 접근하는 상황이 있을 때 사용 되는 명령어이며 시스템 콜을 사용하게 되면 유저 모드에서 커널 모드로 변경된 후 하드웨어 자원에 접근되게 됩니다.
- 이렇게 유저 모드와 커널 모드를 나눈 이유는 특정 Application에 의해 하드웨어 자원이 손상되지 않기 위함입니다. 만약에 여러 개의 Application이 있는 상태에서 특정 Application에 의해 하드웨어 자원이 손상될 경우 해당 컴퓨팅 하드웨어 자원을 사용하고 있는 모든 Application이 영향을 받기위 이러한 피해를 방지하기 위함으로 모드가 나뉘어졌습니다.
- 그림 참고 링크: https://minnie.tuhs.org/CompArch/Lectures/week07.html

**인터럽트란 무엇이며 인터럽트와 시스템 콜의 차이점에 대해서 설명해주세요.**

- 인터럽트란 CPU가 현재 실행 중인 작업을 멈추고 어떠한 작업을 처리해야 하는 메커니즘을 말합니다.
- 인터럽트란 하드웨어 인터럽트와 소프트웨어 인터럽트 둘 다 존재합니다. 먼저 시스템 콜과 인터럽트 둘 다 커널 모드로 변경하여 하드웨어에 접근한다는 공통점이 있습니다. 하지만 시스템 콜은 명시적으로 이벤트가 발생하며 인터럽트는 비동기적인 이벤트가 발생한다는 차이점이 있으며 인터럽트는 어떠한 예외 상황을 처리하기 위한 메커니즘이라는 차이점이 있습니다. 실제로 시스템 콜이 내부적으로 처리 되는 과정에서 인터럽트가 동작 되기에 인터럽트에 시스템 콜이 포함된다는 점이 있습니다.
    - 하드웨어 인터럽트: 하드웨어 장치에서 인터럽트를 발생시키는 것
    - 소프트웨어 인터럽트: 소프트웨어 프로그램에 의해서 인터럽트를 발생시키는 것

**멀티프로세싱 시스템에서 스케줄링이 중요한 이유는 무엇인가요?**

- 성능 최적화를 위함입니다. 예를 들어서 유튜브로 노래를 들으면서 네이버에서 옷을 사려고 쇼핑을 할 때 스케줄링 성능이 좋지 않다면 유튜브에서 노래가 나왔다가 끊긴 상태에서 쇼핑을 하며 반대로 유튜브에서 노래는 나오는데 쇼핑을 할 수 없는 상황이 발생합니다.

**CPU 스케줄링 알고리즘의 종류와 특징은?(라운드 로빈, 우선순위 스케줄링, 멀티 레벨 큐)**

- 먼저 CPU 스케줄링 알고리즘에 앞서 알아야 할 용어들이 있습니다. 용어는 아래 정리 드리며 이러한 아래 용어의 값들로 인해 스케줄링 알고리즘의 성능이 결정됩니다.
    - Turnaround Time(반환 시간): 처음 스케줄링 이후 완료까지 걸리는 전체 시간으로 사용자 입장에서 전체 작업이 완료되어 결과를 받을 때까지의 시간입니다.
    - Response Time(응답 시간): 사용자 입장에서 요청을 보냈을 때 처음으로 반응(실제로 실행) 되는 시간입니다.
    - Fairness(형평성): 얼마나 균등(균일)하게 작업이 처리 되는지를 결정하는 지표로 사용자 입장에서 특정 작업이 너무 오래 될 경우 나머지 작업을 오래 기다리게 될 수 있는 확인하는 지표입니다.
    - Throughput(처리율): 얼마나 많은 작업을 처리할 수 있는지 확인하는 지표입니다.
    - DeadLine(마감 시간): 작업이 반드시 끝나야 하는 시간입니다.
- FIFO Scheduling Algorithm
    - 먼저 도착한 프로세스를 먼저 처리하는 알고리즘 기법입니다.
    - 작업 시간이 긴 프로세스가 먼저 도착하여 스케줄링이 되는 경우 나머지 프로세스가 늦게 처리 되는 단점이 있는 알고리즘입니다.
- Priority Scheduling
    - 각 프로세스에 우선순위를 부여하고 우선순위가 높은 프로세스부터 처리하는 스케줄링 알고리즘입니다.
    - 하나의 예로 **Shortest Job First 알고리즘 기법이 있는데 해당 기법은 실행시간이 적은 Job에 대해서 높은 우선순위를 부여하는 알고리즘입니다.**
    - 하지만 우선순위를 부여할 때 첫 스케줄링이 될 때를 기준으로 지정하기에 실행시간이 늦은  Job이 먼저 도착한다면 여전히 실행시간이 긴 Job이 오래 처리될 수 있다는 단점이 있습니다.
        - 이러한 단점을 해결하기 위해 STCF(Shortest Time-to Completion First) 알고리즘 기법이 나왔는데, 위와 동일한 상황에서 늦게 도착한 Job의 실행 시간이 더 짧을 경우 현재 실행 중인 Job을 중지시키고 실행시간이 긴 Job을 먼저 실행시기킵니다. 이에 따라서 Context Switching이 발생할 수 있습니다.
- **Round-Robin**
    - 프로세스가 처리해야 할 작업을 어떠한 시간 간격 만큼 잘라서 처리하는 스케줄링 알고리즘입니다. 그렇기에 실행시간이 짧던, 길던 모든 Job은 동일한 스케줄링 시간을 갖게 됩니다.
    - 라운드 로빈 알고리즘은 평균 응답 시간(사용자의 요청에 따른 반응 시간)은 빨라질 수 있지만 전체 프로세스가 스케줄링 되어 완료되는 시간인 평균 반환 시간은 늘어날 수 있다는 단점이 있습니다. 또한 이 부분에서 알 수 있듯이 평균 반환 시간과 평균 응답 시간은 반비례 관계로 Trade-off 관계에 있다는 것을 알 수 있습니다.
- **MLFQ(Multi Level Feedback Queue)**
    - 우선순위를 갖는 여러 개의 큐에 실행 되어야 할 Job들이 존재하여 스케줄링 되는 알고리즘 기법입니다. 일반적으로 사용 되는 규칙은 아래와 같습니다. 해당 기법은 응답 시간과 반환 시간의 반비례 관계를 최적화한 알고리즘입니다.
        - 규칙1: 우선순위가 "A(프로세스) > B(프로세스)"일 경우(같은 큐에 위치할 경우) A 실행
        - 규칙2: A와 B의 우선순위가 같을 경우 먼저 도착(요청)한 순서로 time slice만큼 각각 일정 시간 수행
        - 규칙3: 새로운 job(프로세스)가 도착할 경우 가장 높은 우선순위 부여
        - 규칙4: time slice 만큼 작업을 실행한 job은 우선순위가 감소
        - 규칙5: 특정 시간 동안 time slice에 대한 작업을 진행했는데 너무 오래 되는 경우 우선순위를 낮춤
    - 참고 링크: https://pawoo0211.tistory.com/63

**컨텍스트 스위칭이란 무엇이며, 컨텍스트 스위칭에 따라 오버헤드가 발생하는 이유가 무엇인가요?**

- Context Switching이란 CPU가 현재 실행중인 프로세스의 Context(프로세스 정보)를 PCB에 저장하고 다음 실행할 프로세스에 대한 PCB를 이용하여 CPU에 불러오는 것을 말합니다.
    - Context Save (컨텍스트 저장): 현재 실행 중인 프로세스를 저장하는 것
    - Context Load (컨텍스트 로드): 다음에 실행할 프로세스를 로딩하는 것
- 컨텍스트 스위칭에 따라서 오버헤드가 발생하는 이유
    - 현재 프로세스를 저정하고 다음 프로세스를 불러오는 것에 시간이 소요됩니다.
    - 다음 프로세스를 어떤 것을 불러올지에 대해서 CPU 연산이 발생하여 시간이 소요됩니다.
- 멀티 프로세스와 멀티 스레드 간에서도 Context Switching이 일어나지만 이에 대한 오버헤드는 멀티 프로세스가 더 큽니다.

**프로세스와 스레드의 차이점은 무엇인가?**

- Process
    - 프로세스란 CPU를 할당 받고 실제 수행되는 프로그램을 의미합니다.
    - 프로세스는 자신만의 고유한 메모리를 가지고 있습니다.
    - 각각의 프로세스는 “Code”, ”Data”, “Stack”, “Heap” 영역을 가지고 있습니다.
    - 프로세스는 프로세스들끼리 자원을 공유하지 않습니다.
        - 하지만 프로세스간의 통신을 이용 할 경우 접근이 가능합니다.
- Thread
    - 쓰레드란 프로세스 내에서의 실행되는 흐름의 단위입니다.
    - 하나의 프로세스는 최소 1개 이상의 쓰레드를 가지고 있습니다.
    - 각각의 쓰레드는 자신만의 **“Stack”**을 가지며 **“Code”**, **“Data”**, **“Heap”** 영역은 프로세스 내에서 쓰레드들끼리 공유합니다.
    - 쓰레드는 쓰레드들끼리 자원을 공유합니다.

**PCB(Process Control Block)란 무엇이며, 어떤 정보를 포함하나요?**

- PCB는 프로세스의 상태 및 자원 정보를 가지고 있는 데이터 구조를 의미합니다.
- PCB에 대한 정보는 아래와 같습니다.
    - 프로세스 식별 정보
    - 프로세스 상태
    - 프로세스 카운터: 프로세스가 어디에서 중단 되었는지 알 수 있는 주소
    - CPU 레지스터
    - 등등…
- 결론적으로 이러한 PCB를 통해서 프로세스를 관리하고 프로세스의 상태를 저장하며 프로세스가 사용하는 자원을 관리하고 추적할 수 있습니다.
- 참고 링크: https://pawoo0211.tistory.com/61

**프로세스 주소 공간이란 무엇이며, 프로세스마다 고유한 주소 공간을 가지는 이유는?**

- 프로세스 주소 공간은 각 프로세스가 사용하는 가상 메모리 영역을 말합니다. 해당 메모리 영역은 코드, 데이터, 힙, 스택으로 나뉘어집니다.
- 프로세스마다 고유한 주소 공간을 가지는 이유는 아래와 같습니다.
    1. 프로세스의 무분별한 메모리 접근에 의해서 하드웨어 자원이 망가질 경우 다른 프로세스에 영향이 갈 수 있기 때문입니다.
    2. 실제로 사용 가능한 메모리 공간을 찾기 위함입니다.
- 참고 링크: https://pawoo0211.tistory.com/52
